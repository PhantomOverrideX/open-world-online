<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- CSP: mirrors launcher policy ‚Äî blocks XSS, inline eval, unknown origins -->
  <meta http-equiv="Content-Security-Policy"
    content="default-src 'self' blob: data: https://jeiweoaqvaldgkgdgzvu.supabase.co;
             script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://*.supabase.co;
             style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
             font-src 'self' https://fonts.gstatic.com data:;
             connect-src 'self' blob: https://jeiweoaqvaldgkgdgzvu.supabase.co https://*.supabase.co wss://*.supabase.co;
             img-src 'self' blob: data:;
             media-src 'self' blob: data:;
             object-src 'none';
             base-uri 'self';">
  <title>OPEN SIEGE ‚Äî ONLINE</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@700;900&display=swap');
    * { box-sizing:border-box; margin:0; padding:0; }
    body { overflow:hidden; background:#000; font-family:'Share Tech Mono',monospace; color:#0f0; }
    body::after {
      content:''; position:fixed; inset:0; pointer-events:none; z-index:9990;
      background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,.07) 2px,rgba(0,0,0,.07) 4px);
    }
    #crosshair {
      position:fixed; top:50%; left:50%; width:18px; height:18px; margin:-9px;
      border:1.5px solid rgba(0,255,0,0.85); border-radius:50%; z-index:9999; pointer-events:none;
    }
    #crosshair::before, #crosshair::after { content:''; position:absolute; background:rgba(0,255,0,0.85); }
    #crosshair::before { width:1px; height:6px; left:50%; top:-8px; margin-left:-.5px; }
    #crosshair::after  { width:6px; height:1px; top:50%; left:-8px; margin-top:-.5px; }

    /* ‚îÄ‚îÄ HUD ‚îÄ‚îÄ */
    #hud { position:fixed; inset:0; pointer-events:none; z-index:100; }
    #hud-tl { position:absolute; top:14px; left:14px; }
    #hud-tr { position:absolute; top:14px; right:14px; text-align:right; }
    #hud-bl { position:absolute; bottom:14px; left:14px; }
    .lbl { font-size:10px; color:#0a0; letter-spacing:2px; margin-bottom:2px; }
    .val { font-family:'Orbitron',monospace; font-size:22px; color:#0f0; text-shadow:0 0 8px #0f0; }
    .val.danger { color:#f44; text-shadow:0 0 8px #f44; }
    #hbar-wrap { width:180px; height:8px; background:#030; border:1px solid #0a0; margin-top:4px; }
    #hbar { height:100%; transition:width .1s, background .3s; }
    #kills-display { font-size:11px; color:#0af; letter-spacing:1px; margin-top:4px; }
    #xp-bar-wrap { width:180px; height:6px; background:#001a1a; border:1px solid #0aa; margin-top:4px; }
    #xp-bar-fill { height:100%; width:0%; background:#00ccff; transition:width .3s; }
    #xp-label { font-size:9px; color:#0af; letter-spacing:1px; margin-top:2px; }
    #controls-hint { font-size:10px; color:#0a0; letter-spacing:1px; margin-top:4px; opacity:.7; }

    /* ‚îÄ‚îÄ HOTBAR ‚îÄ‚îÄ */
    #hotbar-wrap {
      position:fixed; bottom:18px; left:50%; transform:translateX(-50%);
      display:flex; gap:6px; z-index:200; pointer-events:auto;
    }
    .hotbar-slot {
      width:54px; height:54px; border:1px solid #1a331a;
      background:rgba(0,8,0,0.82); position:relative;
      cursor:pointer; transition:border-color .15s, background .15s;
      display:flex; flex-direction:column; align-items:center;
      justify-content:center; user-select:none;
    }
    .hotbar-slot:hover       { border-color:#0f0; background:rgba(0,20,0,0.92); }
    .hotbar-slot.drag-over   { border-color:#ffd700; background:rgba(30,25,0,0.92); }
    .hotbar-slot.has-item    { border-color:#336633; }
    .hotbar-slot .hs-icon    { font-size:22px; line-height:1; }
    .hotbar-slot .hs-qty     {
      position:absolute; bottom:2px; right:4px;
      font-size:10px; color:#ffd700; font-family:'Orbitron',monospace;
    }
    .hotbar-slot .hs-key     {
      position:absolute; top:2px; left:4px;
      font-size:8px; color:#0a0; letter-spacing:1px; opacity:.6;
    }
    .hotbar-slot .hs-name    {
      font-size:7px; color:#0a0; letter-spacing:.5px; margin-top:2px;
      text-align:center; line-height:1.2; max-width:52px;
      overflow:hidden; white-space:nowrap; text-overflow:ellipsis;
    }
    /* active glow when used */
    .hotbar-slot.used {
      border-color:#ffd700 !important;
      background:rgba(30,25,0,0.95) !important;
      animation:hotbar-flash .25s ease-out;
    }
    @keyframes hotbar-flash { 0%{box-shadow:0 0 18px #ffd700} 100%{box-shadow:none} }
    .hotbar-slot.active-weapon {
      border-color:#0f0 !important;
      background:rgba(0,25,0,0.95) !important;
      box-shadow:0 0 10px rgba(0,255,0,0.3);
    }

    /* ‚îÄ‚îÄ INVENTORY OVERLAY ‚îÄ‚îÄ */
    #inv-overlay {
      display:none; position:fixed; inset:0;
      background:rgba(0,0,0,0.7); z-index:600;
      align-items:center; justify-content:center;
      pointer-events:auto;
    }
    #inv-overlay.open { display:flex; }
    #inv-panel {
      background:#050f05; border:1px solid #1a331a;
      padding:20px; min-width:420px;
      font-family:'Orbitron',monospace;
    }
    #inv-title {
      font-size:12px; color:#0f0; letter-spacing:4px;
      margin-bottom:4px;
    }
    #inv-subtitle {
      font-size:9px; color:#336633; letter-spacing:2px;
      margin-bottom:16px;
    }
    #inv-grid {
      display:grid; grid-template-columns:repeat(6,54px);
      gap:5px; margin-bottom:16px;
    }
    .inv-slot {
      width:54px; height:54px; border:1px solid #1a331a;
      background:rgba(0,8,0,0.6); position:relative;
      cursor:pointer; transition:border-color .15s, background .15s;
      display:flex; flex-direction:column; align-items:center;
      justify-content:center; user-select:none;
    }
    .inv-slot:hover     { border-color:#0f0; background:rgba(0,20,0,0.92); }
    .inv-slot.drag-over { border-color:#ffd700; background:rgba(30,25,0,0.92); }
    .inv-slot.has-item  { border-color:#336633; }
    .inv-slot .is-icon  { font-size:22px; line-height:1; }
    .inv-slot .is-qty   {
      position:absolute; bottom:2px; right:4px;
      font-size:10px; color:#ffd700; font-family:'Orbitron',monospace;
    }
    .inv-slot .is-name  {
      font-size:7px; color:#0a0; letter-spacing:.5px; margin-top:2px;
      text-align:center; line-height:1.2; max-width:52px;
      overflow:hidden; white-space:nowrap; text-overflow:ellipsis;
    }
    #inv-hotbar-label {
      font-size:9px; color:#336633; letter-spacing:2px; margin-bottom:8px;
    }
    #inv-hotbar-row {
      display:flex; gap:5px; margin-bottom:16px;
    }
    #inv-close-btn {
      width:100%; padding:8px; background:transparent;
      border:1px solid #1a331a; color:#0a0; cursor:pointer;
      font-family:'Orbitron',monospace; font-size:10px; letter-spacing:3px;
      transition:border-color .15s;
    }
    #inv-close-btn:hover { border-color:#0f0; color:#0f0; }
    #inv-tooltip {
      position:fixed; background:#050f05; border:1px solid #336633;
      padding:8px 12px; font-size:10px; color:#0f0;
      pointer-events:none; z-index:700; display:none;
      font-family:'Orbitron',monospace; letter-spacing:1px;
      max-width:180px; line-height:1.6;
    }
    /* dragging ghost */
    #inv-drag-ghost {
      position:fixed; pointer-events:none; z-index:800;
      font-size:26px; opacity:.8; display:none;
      transform:translate(-50%,-50%);
    }


    /* ‚îÄ‚îÄ BOUNTY ‚îÄ‚îÄ */
    #bounty-val-wrap { margin-top:6px; }
    #bounty-val-lbl { font-size:10px; color:#ff8800; letter-spacing:2px; margin-bottom:2px; }
    #bounty-val { font-family:'Orbitron',monospace; font-size:14px; color:#ff8800; text-shadow:0 0 8px #ff8800; letter-spacing:1px; }
    #bounty-notify {
      position:fixed; top:50%; left:50%; transform:translate(-50%,-120px);
      font-family:'Orbitron',monospace; font-size:22px; font-weight:900;
      color:#ffd700; text-shadow:0 0 24px #ffd700, 0 0 6px #ff8800;
      letter-spacing:4px; pointer-events:none; z-index:502;
      display:none; text-align:center; white-space:nowrap;
    }
    #bounty-notify .bn-sub { font-size:13px; color:#ffaa00; margin-top:4px; letter-spacing:2px; }

    /* ‚îÄ‚îÄ BOUNTY HANDLER SCREEN ‚îÄ‚îÄ */
    #bounty-handler-screen {
      position:fixed; inset:0; z-index:860;
      background:rgba(10,5,0,0.96); backdrop-filter:blur(6px);
      display:none; flex-direction:column;
      align-items:center; justify-content:center;
    }
    #bounty-handler-screen.active { display:flex; }
    #bh-title {
      font-family:'Orbitron',monospace; font-size:26px; font-weight:900;
      color:#ff8800; letter-spacing:8px; text-shadow:0 0 20px #ff6600;
      margin-bottom:4px;
    }
    #bh-subtitle { font-size:10px; color:#884400; letter-spacing:3px; margin-bottom:6px; }
    #bh-progress-bar-wrap {
      width:480px; height:10px; background:#1a0800; border:1px solid #ff6600;
      margin-bottom:6px; position:relative;
    }
    #bh-progress-bar { height:100%; background:linear-gradient(90deg,#ff6600,#ffd700); transition:width .4s; }
    #bh-progress-label { font-size:11px; color:#ff8800; letter-spacing:2px; margin-bottom:22px; }
    #bh-tier-grid {
      display:grid; grid-template-columns:repeat(3,200px); gap:12px;
      margin-bottom:22px; max-height:340px; overflow:visible;
    }
    .bh-tier {
      border:1px solid #552200; padding:16px 12px; text-align:center;
      background:#0d0500; transition:background .1s, border-color .1s;
      position:relative;
    }
    .bh-tier.claimable { border-color:#ff8800; background:#1a0800; cursor:pointer; animation:bh-pulse 1.4s infinite; }
    .bh-tier.claimed   { border-color:#333; opacity:0.45; }
    .bh-tier.locked    { border-color:#331100; opacity:0.6; }
    @keyframes bh-pulse { 0%,100%{ box-shadow:0 0 0 rgba(255,136,0,0); } 50%{ box-shadow:0 0 14px rgba(255,136,0,0.55); } }
    .bh-tier:hover.claimable { background:#261000; border-color:#ffd700; }
    .bh-tier-rank { font-family:'Orbitron',monospace; font-size:10px; color:#ff6600; letter-spacing:3px; margin-bottom:6px; }
    .bh-tier-kills { font-family:'Orbitron',monospace; font-size:20px; font-weight:900; color:#ffaa44; margin-bottom:4px; }
    .bh-tier-kills span { font-size:10px; color:#884400; display:block; letter-spacing:2px; margin-top:2px; }
    .bh-tier-reward { font-size:10px; color:#ffcc66; letter-spacing:1px; line-height:1.8; margin-top:6px; }
    .bh-tier-status { font-size:9px; letter-spacing:2px; margin-top:8px; }
    .bh-tier.claimable .bh-tier-status { color:#ffd700; }
    .bh-tier.claimed   .bh-tier-status { color:#444; }
    .bh-tier.locked    .bh-tier-status { color:#442200; }
    #bh-close-hint { font-size:10px; color:#442200; letter-spacing:3px; opacity:0.7; }

    /* ‚îÄ‚îÄ CHAT ‚îÄ‚îÄ */
    #chat-box {
      position:fixed; bottom:14px; right:14px; width:320px; z-index:200;
      pointer-events:none;
    }
    #chat-messages {
      display:flex; flex-direction:column; gap:3px;
      max-height:220px; overflow:hidden;
      margin-bottom:6px;
    }
    .chat-msg {
      background:rgba(0,10,0,0.72); border-left:2px solid #0a0;
      padding:4px 8px; font-size:11px; line-height:1.4;
      color:#cfc; letter-spacing:0.5px;
      animation:msgIn 0.15s ease;
      word-break:break-word;
    }
    .chat-msg .chat-name { color:#0f0; font-weight:bold; margin-right:4px; }
    .chat-msg.mine .chat-name { color:#0af; }
    .chat-msg.system { border-left-color:#880; color:#fa0; font-style:italic; }
    .chat-msg.killfeed { border-left-color:#ff4444; color:#ffaa44; font-style:normal; }
    @keyframes msgIn { from{opacity:0;transform:translateX(8px)} to{opacity:1;transform:none} }
    #chat-input-row {
      display:none; align-items:center; gap:6px;
      background:rgba(0,12,0,0.88); border:1px solid #0a0;
      padding:5px 8px; pointer-events:all;
    }
    #chat-input-row.open { display:flex; }
    #chat-prompt { font-size:10px; color:#0a0; letter-spacing:1px; white-space:nowrap; }
    #chat-input {
      flex:1; background:transparent; border:none; outline:none;
      font-family:'Share Tech Mono',monospace; font-size:12px;
      color:#0f0; caret-color:#0f0;
    }
    #chat-send {
      font-family:'Share Tech Mono',monospace; font-size:10px; color:#000;
      background:#0a0; border:none; padding:2px 8px; cursor:pointer;
      letter-spacing:1px;
    }
    #chat-send:hover { background:#0f0; }
    #chat-hint {
      position:fixed; bottom:14px; right:14px;
      font-size:10px; color:#0a0; letter-spacing:2px; z-index:201;
      opacity:.55; pointer-events:none;
    }
    #chat-hint.hidden { display:none; }

    /* ‚îÄ‚îÄ OVERLAYS ‚îÄ‚îÄ */
    #death-flash { position:fixed; inset:0; background:rgba(255,0,0,0); pointer-events:none; z-index:500; transition:background 0.15s; }
    #death-msg {
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      font-family:'Orbitron',monospace; font-size:36px; font-weight:900;
      color:#f44; text-shadow:0 0 30px #f44; letter-spacing:4px; pointer-events:none;
      z-index:501; display:none; text-align:center;
    }
    #death-msg .sub { font-size:14px; color:#f84; margin-top:8px; letter-spacing:3px; }
    #hit-marker {
      position:fixed; top:50%; left:50%; width:24px; height:24px;
      margin:-12px; pointer-events:none; z-index:9998; opacity:0;
    }
    #hit-marker::before, #hit-marker::after { content:''; position:absolute; background:#f44; }
    #hit-marker::before { width:24px; height:2px; top:11px; left:0; }
    #hit-marker::after  { width:2px; height:24px; top:0; left:11px; }
    #click-hint {
      position:fixed; bottom:52px; left:50%; transform:translateX(-50%);
      font-size:11px; color:#0a0; letter-spacing:3px; z-index:600;
      animation:blink 1.2s infinite;
    }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.15} }

    /* ‚îÄ‚îÄ AUTH MODAL ‚îÄ‚îÄ */
    #auth-modal {
      position:fixed; inset:0; background:rgba(0,0,0,0.95);
      display:flex; align-items:center; justify-content:center; z-index:800;
    }
    #auth-modal.hidden { display:none; }
    #auth-box {
      border:1px solid #0a0; padding:36px 44px; text-align:center;
      background:#010e01; min-width:340px; max-width:400px;
      box-shadow:0 0 40px rgba(0,255,0,0.08);
    }
    #auth-title { font-family:'Orbitron',monospace; font-size:20px; font-weight:900;
      color:#0f0; letter-spacing:6px; margin-bottom:4px;
      text-shadow:0 0 20px rgba(0,255,0,0.4); }
    #auth-sub { font-size:10px; color:#0a0; letter-spacing:2px; margin-bottom:28px; }
    #auth-step-label { font-size:9px; color:#060; letter-spacing:3px; margin-bottom:16px; }
    .auth-field-wrap { text-align:left; margin-bottom:16px; }
    .auth-lbl { font-size:9px; color:#0a0; letter-spacing:2px; margin-bottom:4px; display:block; }
    .auth-input {
      background:rgba(0,255,0,0.04); border:1px solid #0a0;
      outline:none; font-family:'Share Tech Mono',monospace; font-size:15px;
      color:#0f0; width:100%; padding:8px 10px; caret-color:#0f0;
      letter-spacing:1px; box-sizing:border-box;
      transition:border-color 0.15s;
    }
    .auth-input:focus { border-color:#0f0; background:rgba(0,255,0,0.07); }
    .pass-wrap { position:relative; }
    .pass-wrap .auth-input { padding-right:36px; }
    .pass-eye {
      position:absolute; right:9px; top:50%; transform:translateY(-50%);
      background:none; border:none; cursor:pointer; padding:2px 4px;
      color:#0a0; font-size:15px; line-height:1; user-select:none;
      transition:color 0.15s;
    }
    .pass-eye:hover { color:#0f0; }
    #auth-error { font-size:10px; color:#f44; letter-spacing:1px;
      min-height:16px; margin-bottom:12px; }
    .auth-btn {
      font-family:'Orbitron',monospace; font-size:12px; font-weight:700;
      color:#000; background:#0f0; border:none; padding:11px 0;
      cursor:pointer; letter-spacing:3px; width:100%; margin-bottom:10px;
      transition:background 0.12s;
    }
    .auth-btn:hover { background:#4f4; }
    .auth-btn.secondary {
      background:transparent; color:#0a0; border:1px solid #0a0;
      font-size:11px;
    }
    .auth-btn.secondary:hover { color:#0f0; border-color:#0f0; background:rgba(0,255,0,0.06); }
    .auth-btn:disabled { opacity:0.5; cursor:default; }
    #auth-toggle { font-size:10px; color:#0a0; letter-spacing:1px; margin-top:8px; cursor:default; }
    #auth-toggle span { color:#0f0; cursor:pointer; text-decoration:underline; }
    #auth-toggle span:hover { color:#4f4; }

    /* ‚îÄ‚îÄ SCOPE OVERLAY ‚îÄ‚îÄ */
    #scope {
      position:fixed; inset:0; z-index:9995; pointer-events:none;
      display:none;
    }
    #scope.active { display:block; }

    /* Dark vignette ‚Äî leaves a circular clear window in the centre */
    #scope-vignette {
      position:absolute; inset:0;
      /* radial gradient: transparent circle, black surround */
      background: radial-gradient(circle 38vmin at 50% 50%,
        transparent 0%,
        transparent 37%,
        rgba(0,0,0,0.96) 41%,
        rgba(0,0,0,1)    44%);
    }

    /* SVG reticle (mil-dots, chevrons, cross-hairs) injected by JS */
    #scope-svg {
      position:absolute; inset:0; width:100%; height:100%;
    }

    /* Zoom level indicator */
    #scope-zoom {
      position:absolute; bottom:calc(50% - 13vmin - 22px); left:50%;
      transform:translateX(-50%);
      font-size:11px; color:rgba(0,200,0,0.7); letter-spacing:3px;
      font-family:'Share Tech Mono',monospace;
    }

    /* ‚îÄ‚îÄ PAUSE SCREEN ‚îÄ‚îÄ */
    #pause-screen {
      position:fixed; inset:0; z-index:700;
      background:rgba(0,0,0,0.82);
      display:none; flex-direction:column;
      align-items:center; justify-content:center;
      backdrop-filter:blur(3px);
    }
    #pause-screen.active { display:flex; }
    #pause-title {
      font-family:'Orbitron',monospace; font-size:42px; font-weight:900;
      color:#0f0; text-shadow:0 0 30px #0f0, 0 0 60px rgba(0,255,0,0.3);
      letter-spacing:8px; margin-bottom:6px;
    }
    #pause-sub {
      font-size:11px; color:#0a0; letter-spacing:4px; margin-bottom:48px;
    }
    .pause-btn {
      font-family:'Orbitron',monospace; font-size:14px; font-weight:700;
      color:#000; background:#0f0; border:none; padding:14px 52px;
      letter-spacing:4px; cursor:pointer; margin-bottom:14px;
      transition:background 0.12s, box-shadow 0.12s;
      box-shadow:0 0 0 rgba(0,255,0,0);
    }
    .pause-btn:hover {
      background:#4f4;
      box-shadow:0 0 18px rgba(0,255,0,0.5);
    }
    .pause-btn.secondary {
      background:transparent; color:#0a0;
      border:1px solid #0a0; font-size:11px;
      padding:10px 40px; letter-spacing:3px;
    }
    .pause-btn.secondary:hover { color:#0f0; border-color:#0f0; background:rgba(0,255,0,0.06); box-shadow:none; }
    #pause-divider {
      width:200px; height:1px; background:rgba(0,255,0,0.15);
      margin:10px 0 24px;
    }
    #pause-keybinds {
      font-size:10px; color:#0a0; letter-spacing:2px; text-align:center;
      line-height:2; opacity:0.65; margin-top:28px;
    }
    #pause-keybinds span { color:#0f0; }

    /* ‚îÄ‚îÄ SHOP ‚îÄ‚îÄ */
    #shop-screen {
      position:fixed; inset:0; z-index:800;
      background:rgba(0,5,0,0.94);
      display:none; flex-direction:column;
      align-items:center; justify-content:center;
      backdrop-filter:blur(4px);
    }
    #shop-screen.active { display:flex; }
    #shop-title {
      font-family:'Orbitron',monospace; font-size:32px; font-weight:900;
      color:#0f0; letter-spacing:8px; text-shadow:0 0 20px #0f0;
      margin-bottom:6px;
    }
    #shop-coins-display {
      font-size:13px; color:#ffd700; letter-spacing:3px; margin-bottom:30px;
    }
    #shop-grid {
      display:grid; grid-template-columns:repeat(5,160px); gap:10px; max-width:860px;
    }
    .shop-item {
      border:1px solid #0a0; padding:16px 12px; cursor:pointer;
      background:#010e01; text-align:center;
      transition:background 0.1s, border-color 0.1s;
    }
    .shop-item:hover { background:#021502; border-color:#0f0; }
    .shop-item.cant-afford { opacity:0.45; cursor:default; }
    .shop-item-name {
      font-family:'Orbitron',monospace; font-size:11px; color:#0f0;
      letter-spacing:2px; margin-bottom:6px;
    }
    .shop-item-desc { font-size:10px; color:#0a0; letter-spacing:1px; margin-bottom:8px; line-height:1.5; }
    .shop-item *  { pointer-events:none; }  /* clicks fall through to parent onclick */
    .shop-item-cost { font-size:13px; color:#ffd700; letter-spacing:2px; }
    .upgrade-lv { font-size:9px; color:#0af; letter-spacing:2px; margin-top:4px; opacity:0.8; }
    #shop-close-hint { font-size:10px; color:#0a0; letter-spacing:3px; margin-top:28px; opacity:0.6; }

    /* ‚îÄ‚îÄ BUY FACTOR ‚îÄ‚îÄ */
    .bf-row { display:flex; align-items:center; gap:6px; margin-bottom:18px; font-family:'Orbitron',monospace; }
    .bf-label { font-size:10px; color:#888; letter-spacing:2px; margin-right:4px; }
    .bf-btn {
      padding:4px 10px; font-size:10px; font-family:'Orbitron',monospace; letter-spacing:1px;
      border:1px solid #333; background:#111; color:#666; cursor:pointer;
      transition:all 0.12s;
    }
    .bf-btn:hover { border-color:#0f0; color:#0f0; }
    .bf-btn.active { border-color:#0f0; background:#021502; color:#0f0; box-shadow:0 0 8px rgba(0,255,0,0.3); }
    #shop-screen .bf-btn.active { border-color:#0f0; color:#0f0; }
    #weaponsmith-screen .bf-btn.active { border-color:#ff4400; color:#ff4400; box-shadow:0 0 8px rgba(255,68,0,0.4); }
    #weaponsmith-screen .bf-btn:hover { border-color:#ff4400; color:#ff4400; }

    /* ‚îÄ‚îÄ WEAPONSMITH SCREEN ‚îÄ‚îÄ */
    #weaponsmith-screen {
      position:fixed; inset:0; z-index:800;
      background:rgba(10,0,0,0.95);
      display:none; flex-direction:column;
      align-items:center; justify-content:center;
      backdrop-filter:blur(4px);
    }
    #weaponsmith-screen.active { display:flex; }
    #weapon-title {
      font-family:'Orbitron',monospace; font-size:28px; font-weight:900;
      color:#ff4400; letter-spacing:8px; text-shadow:0 0 20px #ff4400;
      margin-bottom:6px;
    }
    #weapon-coins-display { font-size:13px; color:#ffd700; letter-spacing:3px; margin-bottom:8px; }
    #weapon-grid {
      display:grid; grid-template-columns:repeat(3,200px); gap:14px; max-width:680px;
    }
    .weapon-item {
      border:1px solid #441100; padding:16px 12px; cursor:pointer;
      background:#0e0100; text-align:center;
      transition:background 0.1s, border-color 0.1s;
    }
    .weapon-item:hover { background:#1a0300; border-color:#ff4400; }
    .weapon-item.cant-afford { opacity:0.45; cursor:default; }
    .weapon-item-name {
      font-family:'Orbitron',monospace; font-size:11px; color:#ff6600;
      letter-spacing:2px; margin-bottom:6px;
    }
    .weapon-item-desc { font-size:10px; color:#662200; letter-spacing:1px; margin-bottom:8px; line-height:1.5; }
    .weapon-item * { pointer-events:none; }
    .weapon-item-cost { font-size:13px; color:#ffd700; letter-spacing:2px; }
    #weapon-close-hint { font-size:10px; color:#442200; letter-spacing:3px; margin-top:24px; opacity:0.6; }

    /* ‚îÄ‚îÄ RED BULL HUD ‚îÄ‚îÄ */
    #redbull-hud {
      position:fixed; top:52px; left:50%; transform:translateX(-50%);
      display:none; font-family:'Orbitron',monospace; font-size:11px;
      color:#ff4444; letter-spacing:2px; pointer-events:none;
      background:rgba(40,0,0,0.7); padding:4px 14px; border:1px solid #ff4444;
      text-shadow:0 0 8px #ff0000;
    }


    /* ‚îÄ‚îÄ BOSS SCREEN ‚îÄ‚îÄ */
    #boss-screen {
      position:fixed; inset:0; z-index:860;
      background:rgba(0,5,20,0.96); backdrop-filter:blur(6px);
      display:none; flex-direction:column;
      align-items:center; justify-content:flex-start;
      padding-top:24px; overflow-y:auto;
    }
    #boss-screen.active { display:flex; }
    #boss-title {
      font-family:'Orbitron',monospace; font-size:24px; font-weight:900;
      color:#00aaff; letter-spacing:8px; text-shadow:0 0 20px #0066ff;
      margin-bottom:6px;
    }
    #boss-player-info {
      font-size:11px; color:#6699cc; letter-spacing:2px; margin-bottom:16px;
    }
    #boss-fight-grid {
      display:grid; grid-template-columns:repeat(5,180px); gap:12px;
      margin-bottom:20px; max-width:960px;
    }
    .boss-item {
      border:1px solid #003366; padding:14px 10px; cursor:pointer;
      background:#000d1a; text-align:center;
      transition:background 0.12s, border-color 0.12s;
    }
    .boss-item:hover { background:#001a33; border-color:#00aaff; }
    .boss-item.cant-afford { opacity:0.35; cursor:default; }
    .boss-item-name {
      font-family:'Orbitron',monospace; font-size:10px; color:#00aaff;
      letter-spacing:1px; margin-bottom:7px; line-height:1.4;
    }
    .boss-item-stats { font-size:9px; color:#336699; letter-spacing:1px; margin-bottom:5px; line-height:1.6; }
    .boss-item-cost { font-size:10px; color:#ffd700; letter-spacing:1px; margin-bottom:5px; }
    .boss-item-reward { font-size:9px; color:#44ff88; letter-spacing:1px; }
    #boss-close-hint { font-size:10px; color:#003355; letter-spacing:3px; opacity:0.7; margin-bottom:16px; }
    #boss-hud {
      position:fixed; top:0; left:50%; transform:translateX(-50%);
      width:380px; padding:8px 16px; background:rgba(0,5,20,0.85);
      border-bottom:1px solid #003366; display:none; z-index:700; text-align:center;
    }
    #boss-hud-name { font-family:'Orbitron',monospace; font-size:11px; color:#00aaff; letter-spacing:3px; margin-bottom:4px; }
    #boss-hud-bar-wrap { width:100%; height:10px; background:#000d1a; border:1px solid #003366; }
    #boss-hud-bar { height:100%; width:100%; background:#0088ff; transition:width .1s; }

    #boss-warning { font-size:10px; color:#ff8844; letter-spacing:2px; margin-bottom:18px; max-width:640px; text-align:center; line-height:1.8; }

    /* ‚îÄ‚îÄ REBIRTH SCREEN ‚îÄ‚îÄ */
    #rebirth-screen {
      position:fixed; inset:0; z-index:850;
      background:rgba(10,0,20,0.96); backdrop-filter:blur(6px);
      display:none; flex-direction:column;
      align-items:center; justify-content:center;
    }
    #rebirth-screen.active { display:flex; }
    #rebirth-title {
      font-family:'Orbitron',monospace; font-size:28px; font-weight:900;
      color:#cc44ff; letter-spacing:8px; text-shadow:0 0 24px #aa22ff;
      margin-bottom:4px;
    }
    #rebirth-count-display {
      font-size:11px; color:#9966cc; letter-spacing:4px; margin-bottom:6px;
    }
    #rebirth-cost-display {
      font-size:14px; color:#ffd700; letter-spacing:3px; margin-bottom:6px;
    }
    #rebirth-afford {
      font-size:11px; letter-spacing:2px; margin-bottom:22px;
    }
    #rebirth-warning {
      font-size:10px; color:#ff6666; letter-spacing:2px; margin-bottom:20px;
      max-width:580px; text-align:center; line-height:1.8;
    }
    #rebirth-buff-grid {
      display:grid; grid-template-columns:repeat(3,180px); gap:14px;
      margin-bottom:24px;
    }
    .rebirth-item {
      border:1px solid #6600aa; padding:18px 14px; cursor:pointer;
      background:#0d001a; text-align:center;
      transition:background 0.12s, border-color 0.12s;
    }
    .rebirth-item:hover { background:#1a0033; border-color:#cc44ff; }
    .rebirth-item.cant-afford { opacity:0.35; cursor:default; }
    .rebirth-icon { font-size:24px; margin-bottom:8px; }
    .rebirth-name {
      font-family:'Orbitron',monospace; font-size:10px; color:#cc44ff;
      letter-spacing:2px; margin-bottom:6px;
    }
    .rebirth-desc { font-size:10px; color:#9966cc; letter-spacing:1px; margin-bottom:8px; line-height:1.6; }
    .rebirth-stack { font-size:9px; color:#664488; letter-spacing:1px; }
    #rebirth-close-hint { font-size:10px; color:#440066; letter-spacing:3px; opacity:0.7; }

    /* Coin pop */
    #coin-pop {
      position:fixed; bottom:90px; left:50%; transform:translateX(-50%);
      font-family:'Orbitron',monospace; font-size:16px; color:#ffd700;
      text-shadow:0 0 10px #ffd700; letter-spacing:3px;
      pointer-events:none; z-index:600; opacity:0;
      transition:opacity 0.3s;
    }
    /* Floating damage / info numbers */
    .float-pop {
      position:fixed; left:50%;
      font-family:'Orbitron',monospace; font-size:14px; font-weight:700;
      letter-spacing:2px; pointer-events:none; z-index:601;
      text-shadow:0 0 8px currentColor;
      animation:floatUp 1.1s ease-out forwards;
    }
    @keyframes floatUp {
      0%  { opacity:1; transform:translateX(-50%) translateY(0); }
      80% { opacity:1; }
      100%{ opacity:0; transform:translateX(-50%) translateY(-48px); }
    }
    /* God mode indicator */
    #god-mode-indicator {
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      font-family:'Orbitron',monospace; font-size:10px; color:rgba(0,255,180,0.55);
      letter-spacing:3px; pointer-events:none; z-index:599; display:none;
    }

    /* ‚îÄ‚îÄ INTERACT PROMPT ‚îÄ‚îÄ */
    #interact-prompt {
      position:fixed; top:58%; left:50%; transform:translateX(-50%);
      font-family:'Orbitron',monospace; font-size:13px; color:#ffd700;
      text-shadow:0 0 12px #ffd700; letter-spacing:3px;
      pointer-events:none; z-index:600; display:none;
      background:rgba(0,0,0,0.6); padding:6px 18px; border:1px solid rgba(255,215,0,0.6);
    }
    /* ‚îÄ‚îÄ PLAYER LIST (TAB) ‚îÄ‚îÄ */
    #player-list-overlay {
      position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.82); border:1px solid rgba(255,255,255,0.15);
      min-width:380px; max-width:480px; padding:0; z-index:700;
      display:none; pointer-events:none; backdrop-filter:blur(4px);
    }
    #player-list-overlay.visible { display:block; }
    #pl-header {
      background:rgba(255,255,255,0.06); padding:8px 16px;
      display:flex; justify-content:space-between;
      font-family:'Orbitron',monospace; font-size:11px; color:#aaa; letter-spacing:2px;
      border-bottom:1px solid rgba(255,255,255,0.08);
    }
    #pl-rows { padding:6px 0; }
    .pl-row {
      display:flex; align-items:center; padding:5px 16px; gap:12px;
      font-family:'Orbitron',monospace; font-size:11px; border-bottom:1px solid rgba(255,255,255,0.04);
    }
    .pl-row:last-child { border-bottom:none; }
    .pl-you { background:rgba(255,215,0,0.06); }
    .pl-name { flex:1; color:#eee; letter-spacing:1px; }
    .pl-name.you { color:#ffd700; }
    .pl-lvl  { width:55px; color:#88aaff; text-align:right; }
    .pl-bounty { width:70px; color:#ff8800; text-align:right; }
    .pl-hp   { width:55px; color:#44ff88; text-align:right; }
    #pl-footer { padding:5px 16px; font-family:'Orbitron',monospace; font-size:10px; color:#555; letter-spacing:1px; border-top:1px solid rgba(255,255,255,0.06); }

    /* ‚îÄ‚îÄ ADMIN PLAYER INFO CARD ‚îÄ‚îÄ */
    #admin-player-card {
      background:rgba(0,20,0,0.6); border:1px solid #004400;
      padding:12px 14px; margin-bottom:14px; display:none;
    }
    #admin-player-card.visible { display:block; }
    #admin-player-card h3 { color:#00ff41; font-size:12px; letter-spacing:3px; margin:0 0 10px; }
    .apc-grid {
      display:grid; grid-template-columns:1fr 1fr; gap:4px 20px;
    }
    .apc-row { display:flex; justify-content:space-between; font-size:11px; padding:2px 0; border-bottom:1px solid #001800; }
    .apc-key { color:#448844; }
    .apc-val { color:#00ff41; font-weight:bold; }
    .apc-online { color:#00ff41; }
    .apc-offline { color:#664400; }

    /* ‚îÄ‚îÄ CAR DEALER SCREEN ‚îÄ‚îÄ */
    #car-dealer-screen {
      position:fixed; inset:0; background:rgba(0,0,0,0.88); z-index:870;
      display:none; flex-direction:column; align-items:center; justify-content:center;
      font-family:'Orbitron',monospace;
    }
    #car-dealer-screen.active { display:flex; }
    #car-dealer-title { font-size:22px; color:#ff8800; letter-spacing:5px; text-shadow:0 0 18px #ff8800; margin-bottom:4px; }
    #car-dealer-sub { font-size:11px; color:#996633; letter-spacing:3px; margin-bottom:28px; }
    #car-dealer-balance { font-size:13px; color:#ffdd44; letter-spacing:2px; margin-bottom:20px; }
    #car-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:14px; max-width:900px; width:92%; max-height:72vh; overflow-y:auto; padding:4px; }
    .car-card { background:rgba(30,20,5,0.9); border:2px solid #442200; padding:16px 12px; text-align:center; cursor:pointer; transition:border-color .2s, box-shadow .2s; }
    .car-card:hover { border-color:#ff8800; box-shadow:0 0 18px rgba(255,136,0,0.4); }
    .car-card.owned { border-color:#00cc44; box-shadow:0 0 12px rgba(0,200,60,0.3); cursor:default; }
    .car-card.cant-afford { opacity:0.45; cursor:default; }
    .car-card.military { border-color:#3a5a1a; background:rgba(5,20,5,0.95); }
    .car-card.military:hover { border-color:#88cc44; box-shadow:0 0 18px rgba(80,180,0,0.4); }
    .car-card.military.owned { border-color:#44ff88; }
    .car-card-icon { font-size:34px; margin-bottom:8px; }
    .car-card-name { font-size:12px; color:#ff8800; letter-spacing:3px; margin-bottom:5px; }
    .car-card.military .car-card-name { color:#88cc44; }
    .car-card-desc { font-size:10px; color:#886644; margin-bottom:8px; line-height:1.5; }
    .car-card.military .car-card-desc { color:#557733; }
    .car-card-speed { font-size:10px; color:#ffaa44; margin-bottom:8px; }
    .car-card.military .car-card-speed { color:#88cc44; }
    .car-card-cost { font-size:12px; color:#ffdd44; letter-spacing:1px; }
    .car-card.owned .car-card-cost { color:#00cc44; }
    #car-dealer-close { margin-top:20px; font-size:11px; color:#554433; letter-spacing:3px; cursor:pointer; }
    #car-dealer-close:hover { color:#ff8800; }
    /* ‚îÄ‚îÄ HORSE DEALER ‚îÄ‚îÄ */
    #horse-dealer-screen {
      position:fixed; inset:0; background:rgba(10,5,0,0.92); z-index:870;
      display:none; flex-direction:column; align-items:center; justify-content:center;
      font-family:'Orbitron',monospace;
    }
    #horse-dealer-screen.active { display:flex; }
    #horse-dealer-title { font-size:22px; color:#cc8800; letter-spacing:5px; text-shadow:0 0 18px #aa6600; margin-bottom:4px; }
    #horse-dealer-sub { font-size:11px; color:#775533; letter-spacing:3px; margin-bottom:24px; }
    #horse-dealer-balance { font-size:13px; color:#ffdd44; letter-spacing:2px; margin-bottom:20px; }
    #horse-grid { display:grid; grid-template-columns:repeat(3,200px); gap:16px; margin-bottom:24px; }
    .horse-card { background:rgba(20,10,0,0.95); border:2px solid #553300; padding:18px 14px; text-align:center; cursor:pointer; transition:border-color .2s, box-shadow .2s; }
    .horse-card:hover { border-color:#cc8800; box-shadow:0 0 16px rgba(180,100,0,0.4); }
    .horse-card.owned { border-color:#44cc44; box-shadow:0 0 12px rgba(0,180,0,0.3); cursor:default; }
    .horse-card.cant-afford { opacity:0.45; cursor:default; }
    .horse-card-icon { font-size:36px; margin-bottom:10px; }
    .horse-card-name { font-size:12px; color:#cc8800; letter-spacing:3px; margin-bottom:6px; }
    .horse-card-desc { font-size:10px; color:#775533; margin-bottom:8px; line-height:1.5; }
    .horse-card-speed { font-size:10px; color:#ddaa44; margin-bottom:8px; }
    .horse-card-cost { font-size:12px; color:#ffdd44; letter-spacing:1px; }
    .horse-card.owned .horse-card-cost { color:#44cc44; }
    #horse-dealer-close { margin-top:16px; font-size:11px; color:#553300; letter-spacing:3px; cursor:pointer; }
    #horse-dealer-close:hover { color:#cc8800; }
    /* ‚îÄ‚îÄ CAR HUD ‚îÄ‚îÄ */
    #car-hud { position:fixed; bottom:90px; left:50%; transform:translateX(-50%); display:none; font-family:'Orbitron',monospace; font-size:12px; color:#ff8800; text-align:center; letter-spacing:2px; pointer-events:none; background:rgba(0,0,0,0.55); padding:6px 20px; border:1px solid #442200; }
    #car-hud-speed { font-size:18px; color:#ffcc44; }
    #car-exit-hint { position:fixed; bottom:145px; left:50%; transform:translateX(-50%); display:none; font-family:'Orbitron',monospace; font-size:11px; color:#999; letter-spacing:2px; pointer-events:none; }

    /* ‚îÄ‚îÄ ADMIN CONSOLE ‚îÄ‚îÄ */
    #admin-console {
      position:fixed; inset:0; background:rgba(0,0,0,0.93); z-index:999;
      display:none; flex-direction:column;
      font-family:'Courier New',monospace;
      border:2px solid #00ff41; box-shadow:0 0 40px rgba(0,255,65,0.3);
    }
    #admin-console.active { display:flex; }
    #admin-bar {
      background:#001a00; border-bottom:1px solid #00ff41;
      padding:8px 16px; display:flex; align-items:center; justify-content:space-between;
    }
    #admin-bar-title { color:#00ff41; font-size:14px; letter-spacing:3px; }
    #admin-bar-user  { color:#44ff88; font-size:11px; }
    #admin-bar-close { color:#ff4444; cursor:pointer; font-size:16px; padding:0 6px; }
    #admin-bar-close:hover { text-shadow:0 0 8px #ff4444; }
    #admin-body { display:flex; flex:1; overflow:hidden; }
    /* LEFT ‚Äî tabs */
    #admin-tabs {
      width:170px; background:#000d00; border-right:1px solid #004400;
      display:flex; flex-direction:column; padding:12px 0;
    }
    .admin-tab {
      padding:10px 16px; color:#448844; font-size:12px; letter-spacing:1px;
      cursor:pointer; border-left:3px solid transparent; transition:all .15s;
    }
    .admin-tab:hover { color:#00ff41; background:rgba(0,255,65,0.05); }
    .admin-tab.active { color:#00ff41; border-left-color:#00ff41; background:rgba(0,255,65,0.08); }
    /* RIGHT ‚Äî panel */
    #admin-panel { flex:1; padding:20px; overflow-y:auto; }
    .admin-section { display:none; }
    .admin-section.active { display:block; }
    .admin-section h2 { color:#00ff41; font-size:13px; letter-spacing:3px; margin:0 0 16px; border-bottom:1px solid #004400; padding-bottom:8px; }
    .admin-row { display:flex; align-items:center; gap:10px; margin-bottom:12px; }
    .admin-lbl { color:#448844; font-size:12px; width:130px; flex-shrink:0; }
    .admin-inp {
      background:#001a00; border:1px solid #004400; color:#00ff41;
      font-family:'Courier New',monospace; font-size:12px;
      padding:5px 10px; width:200px; outline:none;
    }
    .admin-inp:focus { border-color:#00ff41; box-shadow:0 0 6px rgba(0,255,65,0.3); }
    .admin-btn {
      background:rgba(0,255,65,0.1); border:1px solid #00ff41; color:#00ff41;
      font-family:'Courier New',monospace; font-size:11px; letter-spacing:2px;
      padding:5px 14px; cursor:pointer; transition:all .15s;
    }
    .admin-btn:hover { background:rgba(0,255,65,0.25); box-shadow:0 0 8px rgba(0,255,65,0.4); }
    .admin-btn.danger { border-color:#ff4444; color:#ff4444; background:rgba(255,68,68,0.1); }
    .admin-btn.danger:hover { background:rgba(255,68,68,0.25); }
    #admin-log {
      background:#000d00; border:1px solid #004400; color:#44ff88;
      font-size:11px; padding:10px; height:120px; overflow-y:auto;
      margin-top:16px; white-space:pre-wrap; line-height:1.6;
    }
    #admin-players-list { margin-bottom:16px; }
    .admin-player-row {
      display:flex; align-items:center; gap:8px; padding:5px 0;
      border-bottom:1px solid #001a00; font-size:11px; color:#44ff88;
    }
    .admin-player-name { width:120px; color:#00ff41; }
    .admin-player-stat { width:70px; color:#448844; }

    /* ‚îÄ‚îÄ EDIT PLAYER CARD (inline editable) ‚îÄ‚îÄ */
    .apc-edit-row {
      display:grid; grid-template-columns:130px 1fr 46px;
      align-items:center; gap:6px; padding:3px 0;
      border-bottom:1px solid #001800;
    }
    .apc-edit-row .apc-key { color:#448844; font-size:10px; }
    .apc-inp {
      background:#001000; border:1px solid #003300; color:#00ff41;
      font-family:'Courier New',monospace; font-size:11px;
      padding:3px 6px; outline:none; width:100%; box-sizing:border-box;
    }
    .apc-inp:focus { border-color:#00ff41; }
    .apc-set-btn {
      background:rgba(0,255,65,0.08); border:1px solid #004400; color:#448844;
      font-family:'Courier New',monospace; font-size:9px; letter-spacing:1px;
      padding:3px 4px; cursor:pointer; white-space:nowrap;
    }
    .apc-set-btn:hover { border-color:#00ff41; color:#00ff41; background:rgba(0,255,65,0.18); }
    .apc-readonly-row {
      display:flex; justify-content:space-between; font-size:11px;
      padding:3px 0; border-bottom:1px solid #001800;
    }

    /* ‚îÄ‚îÄ HACK CLIENT (Admin Hacks Tab) ‚îÄ‚îÄ */
    .hc-row {
      display:flex; align-items:center; justify-content:space-between;
      padding:7px 10px; border:1px solid #3a0050; border-radius:3px;
      background:rgba(80,0,120,0.1); transition:all .15s; margin-bottom:4px;
    }
    .hc-row.hc-active { border-color:#c800ff; background:rgba(200,0,255,0.12); box-shadow:0 0 8px rgba(200,0,255,0.25); }
    .hc-left { display:flex; flex-direction:column; gap:2px; }
    .hc-label { color:#e060ff; font-size:12px; letter-spacing:1px; }
    .hc-row.hc-active .hc-label { color:#ff80ff; text-shadow:0 0 6px #ff00ff; }
    .hc-desc { color:#604080; font-size:10px; }
    .hc-row.hc-active .hc-desc { color:#a050c0; }
    .hc-btn {
      background:rgba(200,0,255,0.08); border:1px solid #5a0080; color:#8040a0;
      font-family:'Courier New',monospace; font-size:11px; letter-spacing:1px;
      padding:4px 12px; cursor:pointer; border-radius:2px; min-width:58px; transition:all .15s;
    }
    .hc-btn:hover { background:rgba(200,0,255,0.2); border-color:#c800ff; color:#ff80ff; }
    .hc-row.hc-active .hc-btn { background:rgba(200,0,255,0.25); border-color:#ff00ff; color:#ff00ff; text-shadow:0 0 6px #ff00ff; }
    .hc-script-row {
      display:flex; align-items:center; justify-content:space-between;
      padding:7px 10px; border:1px solid #003300; border-radius:3px;
      background:rgba(0,80,0,0.1); transition:all .15s; margin-bottom:4px;
    }
    .hc-script-row.hc-active { border-color:#00ff41; background:rgba(0,255,65,0.08); }
    .hc-script-name { color:#00cc44; font-size:11px; letter-spacing:1px; }
    .hc-script-row.hc-active .hc-script-name { color:#00ff41; text-shadow:0 0 6px #00ff41; }
    .hc-script-source { color:#224422; font-size:9px; margin-top:2px; max-width:250px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .hc-script-btns { display:flex; gap:5px; }
    .hc-sbtn {
      background:transparent; border:1px solid #004400; color:#448844;
      font-family:'Courier New',monospace; font-size:9px; letter-spacing:1px;
      padding:3px 8px; cursor:pointer; border-radius:2px;
    }
    .hc-sbtn:hover { border-color:#00ff41; color:#00ff41; }
    .hc-sbtn.danger { border-color:#440000; color:#884444; }
    .hc-sbtn.danger:hover { border-color:#ff4444; color:#ff4444; }
    #hc-admin-hint { font-size:9px; color:#503060; letter-spacing:1px; margin-top:12px; border-top:1px solid #2a0040; padding-top:8px; }

    /* ‚îÄ‚îÄ HACK TERMINAL (login screen) ‚îÄ‚îÄ */
    #auth-modal.hacker-mode { align-items:center; gap:0; }
    #hack-terminal {
      width:460px; height:480px; background:#000408;
      border:1px solid #00ff41; border-right:none;
      display:none; flex-direction:column;
      font-family:'Courier New',monospace;
    }
    #hack-terminal.ht-visible { display:flex; }
    #ht-bar {
      background:#001200; border-bottom:1px solid #003300;
      padding:5px 10px; font-size:9px; color:#00ff41; letter-spacing:2px;
      display:flex; justify-content:space-between; align-items:center; flex-shrink:0;
    }
    #ht-bar-dot { width:8px; height:8px; background:#00ff41; border-radius:50%; animation:htblink 1.2s infinite; }
    @keyframes htblink { 0%,100%{opacity:1} 50%{opacity:0.2} }
    #ht-output {
      flex:1; overflow-y:auto; padding:10px 12px;
      font-size:11px; line-height:1.8; color:#00cc33;
    }
    #ht-output::-webkit-scrollbar { width:4px; }
    #ht-output::-webkit-scrollbar-thumb { background:#003300; }
    .ht-line { display:block; white-space:pre-wrap; word-break:break-all; }
    .ht-cmd   { color:#00ff41; }
    .ht-info  { color:#448844; }
    .ht-warn  { color:#ffaa00; }
    .ht-error { color:#ff4444; }
    .ht-ok    { color:#00ff88; }
    .ht-data  { color:#88aaff; }
    #ht-input-row {
      border-top:1px solid #003300; padding:7px 10px;
      display:flex; align-items:center; gap:6px;
      background:#000d00; flex-shrink:0;
    }
    #ht-prompt { color:#00ff41; font-size:11px; white-space:nowrap; letter-spacing:1px; }
    #ht-input {
      background:transparent; border:none; outline:none;
      color:#00ff41; font-family:'Courier New',monospace; font-size:11px;
      flex:1; caret-color:#00ff41; letter-spacing:1px;
    }
    #auth-modal.hacker-mode #auth-box { border-left:none; }
  </style>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // Supabase config (publishable key)
    const SUPABASE_URL = "https://jeiweoaqvaldgkgdgzvu.supabase.co";
    const SUPABASE_KEY = "sb_publishable_4_o-75VVd79_BxKj-RZoBQ_A0pV4dkO";
    let db;
    try { db = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY); }
    catch(e) { console.error("Supabase init failed:", e); }

    // ‚îÄ‚îÄ Server-side validation helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // callEdgeFn: fire-and-forget call to a Supabase Edge Function.
// ‚îÄ‚îÄ Anti-debug timing detector ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Checks if execution was paused (breakpoint) by measuring setInterval drift.
// Cannot prevent DevTools, but logs anomalies to server for account flagging.
(function _antiDebug(){
  let _lastTick = Date.now();
  let _dbFlagSent = false;
  setInterval(function(){
    const now  = Date.now();
    const gap  = now - _lastTick;
    _lastTick  = now;
    // Normal gap should be ~2000ms. If > 8s, execution was paused.
    if(gap > 8000 && !_dbFlagSent && typeof accountUsername !== 'undefined' && accountUsername){
      _dbFlagSent = true; // send once per session
      if(typeof callEdgeFn === 'function'){
        callEdgeFn('anticheat', { username: accountUsername, type:'debugger_pause', gap });
      }
      setTimeout(()=>{ _dbFlagSent = false; }, 60000); // allow re-flag after 60s
    }
  }, 2000);
})();
    // Returns parsed JSON or null on network error.
    const _EDGE_BASE = SUPABASE_URL + '/functions/v1';
    async function callEdgeFn(fn, payload) {
      try {
        const r = await fetch(_EDGE_BASE + '/' + fn, {
          method:  'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + SUPABASE_KEY },
          body:    JSON.stringify(payload)
        });
        return await r.json();
      } catch(e) {
        console.warn('[AC] Edge function error (', fn, '):', e);
        return null;
      }
    }
    // Anti-cheat reporter ‚Äî posts position to server every 3s for plausibility check.
    // Server is silent for legit players (no response payload acted upon here).
    // Only cheaters get a 'correction' broadcast snapping them back.
    function _startAntiCheat() {
      setInterval(async () => {
        if (!window.accountUsername || !window.myName || !window._chanReady) return;
        callEdgeFn('anticheat', {
          playerId: window.playerId,
          username: window.accountUsername,
          x: window.camera ? window.camera.position.x : 0,
          z: window.camera ? window.camera.position.z : 0,
        });
        // fire-and-forget ‚Äî response is never awaited here so zero latency impact
      }, 3000);
    }
  </script>
</head>
<body>

<!-- Auth modal ‚Äî login / register / callsign -->
<div id="auth-modal">
  <!-- HACK TERMINAL ‚Äî shown when HACKTERM username entered -->
  <div id="hack-terminal">
    <div id="ht-bar">
      <span>HACK_TERMINAL v2.4.1 &nbsp;|&nbsp; HPL RUNTIME READY</span>
      <div id="ht-bar-dot"></div>
    </div>
    <div id="ht-output"></div>
    <div id="ht-input-row">
      <span id="ht-prompt">C:\HACKTERM&gt;</span>
      <input id="ht-input" autocomplete="off" spellcheck="false" placeholder="type command..." />
    </div>
  </div>
  <!-- FILE PICKER ‚Äî hidden, triggered by 'upload' command -->
  <input type="file" id="ht-file-input" accept=".zip" style="display:none" />

  <div id="auth-box">
    <div id="auth-title">OPEN SIEGE</div>
    <div id="auth-sub">// SECURE AUTHENTICATION REQUIRED //</div>

    <!-- STEP 1: Login / Register -->
    <div id="auth-step1">
      <div id="auth-step-label">STEP 1 OF 2 ‚Äî CREDENTIALS</div>
      <div class="auth-field-wrap">
        <label class="auth-lbl" for="auth-user">USERNAME</label>
        <input id="auth-user" class="auth-input" maxlength="20" autocomplete="username" spellcheck="false" placeholder="YOUR_USERNAME"/>
      </div>
      <div class="auth-field-wrap">
        <label class="auth-lbl" for="auth-pass">PASSWORD</label>
        <div class="pass-wrap">
          <input id="auth-pass" class="auth-input" type="password" maxlength="64" autocomplete="current-password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"/>
          <button type="button" class="pass-eye" onclick="togglePassVis()" title="Show/hide password" id="pass-eye-btn">üëÅ</button>
        </div>
      </div>
      <div id="auth-error"></div>
      <button class="auth-btn" id="auth-login-btn" onclick="authLogin()">‚ñ∂ LOGIN</button>
      <button class="auth-btn secondary" id="auth-reg-btn" onclick="authRegister()">+ CREATE ACCOUNT</button>
      <div id="auth-toggle">New soldier? <span onclick="authShowRegisterHint()">Create an account</span></div>

    </div>

    <!-- STEP 2: Soldier callsign (shown after credentials verified) -->
    <div id="auth-step2" style="display:none">
      <div id="auth-step-label">STEP 2 OF 2 ‚Äî CALLSIGN</div>
      <div class="auth-field-wrap">
        <label class="auth-lbl" for="auth-callsign">SOLDIER CALLSIGN</label>
        <input id="auth-callsign" class="auth-input" maxlength="16" autocomplete="off" spellcheck="false" placeholder="SOLDIER"/>
      </div>
      <div id="auth-error2"></div>
      <button class="auth-btn" id="auth-deploy-btn" onclick="authDeploy()">‚ñ∂ DEPLOY</button>
    </div>
  </div>
</div>

<div id="crosshair"></div>
<div id="hit-marker"></div>
<div id="death-flash"></div>
<div id="death-msg"><div>YOU DIED</div><div class="sub">RESPAWNING...</div></div>
<div id="bounty-notify"><div id="bn-title">BOUNTY CLAIMED!</div><div class="bn-sub" id="bn-amount">+0 ‚¨°</div></div>
<div id="interact-prompt">[ E ] TRADE</div>

<div id="hud">
  <div id="hud-tl">
    <div class="lbl">HEALTH</div>
    <div id="hval" class="val">100</div>
    <div id="hbar-wrap"><div id="hbar" style="width:100%;background:#0f0"></div></div>
    <div id="kills-display">KILLS: <span id="kval">0</span> &nbsp;|&nbsp; LVL <span id="lvl-display">0</span></div>
    <div id="xp-bar-wrap"><div id="xp-bar-fill"></div></div>
    <div id="xp-label">LVL 0 ‚Äî 0/50 XP</div>
  </div>
  <div id="hud-tr">
    <div class="lbl">PLAYERS ONLINE</div>
    <div id="pcount" class="val">1</div>
    <div class="lbl" style="margin-top:8px">ZONE</div>
    <div id="zone-indicator" style="font-family:'Orbitron',monospace;font-size:13px;color:#0f0;letter-spacing:2px;margin-top:2px">SAFE</div>
    <div class="lbl" style="margin-top:6px">THREAT LEVEL</div>
    <div id="tier-indicator" style="font-family:'Orbitron',monospace;font-size:11px;color:#0f0;letter-spacing:2px;margin-top:2px">‚Äî</div>
    <div id="rebirth-hud" style="font-size:9px;color:#aa66ff;letter-spacing:1px;margin-top:6px;line-height:1.6;display:none"></div>
    <div class="lbl" style="margin-top:6px">SUPPLY DEPOT</div>
    <div id="shop-bearing" style="font-size:11px;color:#ffd700;letter-spacing:2px;margin-top:2px">-- m ‚Üë</div>
  </div>
  <div id="hud-bl">
    <div class="lbl">WEAPON</div>
    <!-- This label will be updated dynamically by the weapon system -->
    <div id="gval" class="val">RIFLE</div>
    <div class="lbl" style="margin-top:6px">AMMO</div>
    <div id="ammo-val" class="val" style="font-size:16px">120 / 120</div>
    <div class="lbl" style="margin-top:6px">‚¨° COINS</div>
    <div id="coins-val" class="val" style="font-size:16px;color:#ffd700;text-shadow:0 0 8px #ffd700">0</div>
    <div id="bounty-val-wrap">
      <div id="bounty-val-lbl">YOUR BOUNTY</div>
      <div id="bounty-val">‚¨° 5</div>
      <div id="contract-progress-lbl" style="font-size:9px;color:#884400;letter-spacing:1px;margin-top:4px;display:none"></div>
    </div>
    <div id="controls-hint">WASD=MOVE &nbsp; SPACE=JUMP &nbsp; T=CHAT &nbsp; 1-6=WEAPON &nbsp; E=SHOP &nbsp; I=INVENTORY</div>
  </div>
</div>

<!-- Chat -->
<div id="chat-box">
  <div id="chat-messages"></div>
  <div id="chat-input-row">
    <span id="chat-prompt">SAY ‚ñ∏</span>
    <input id="chat-input" maxlength="120" autocomplete="off" spellcheck="false" placeholder="type message..."/>
    <button id="chat-send" onclick="sendChat()">SEND</button>
  </div>
</div>
<div id="chat-hint">[ T ] CHAT</div>

<div id="click-hint">[ CLICK TO CAPTURE MOUSE ]</div>

<div id="scope">
  <div id="scope-vignette"></div>
  <svg id="scope-svg" viewBox="0 0 1000 1000" preserveAspectRatio="xMidYMid meet">
    <!-- centre dot -->
    <circle cx="500" cy="500" r="2.5" fill="rgba(0,220,0,0.9)"/>
    <!-- crosshair lines (gap in centre) -->
    <line x1="500" y1="170" x2="500" y2="440" stroke="rgba(0,220,0,0.85)" stroke-width="1.2"/>
    <line x1="500" y1="560" x2="500" y2="830" stroke="rgba(0,220,0,0.85)" stroke-width="1.2"/>
    <line x1="170" y1="500" x2="440" y2="500" stroke="rgba(0,220,0,0.85)" stroke-width="1.2"/>
    <line x1="560" y1="500" x2="830" y2="500" stroke="rgba(0,220,0,0.85)" stroke-width="1.2"/>
    <!-- mil-dots (horizontal) -->
    <circle cx="350" cy="500" r="3.5" fill="rgba(0,220,0,0.75)"/>
    <circle cx="650" cy="500" r="3.5" fill="rgba(0,220,0,0.75)"/>
    <circle cx="270" cy="500" r="2.5" fill="rgba(0,220,0,0.55)"/>
    <circle cx="730" cy="500" r="2.5" fill="rgba(0,220,0,0.55)"/>
    <!-- mil-dots (vertical) -->
    <circle cx="500" cy="600" r="3.5" fill="rgba(0,220,0,0.75)"/>
    <circle cx="500" cy="700" r="3.5" fill="rgba(0,220,0,0.75)"/>
    <circle cx="500" cy="760" r="2.5" fill="rgba(0,220,0,0.55)"/>
    <!-- range chevrons (below centre) -->
    <polyline points="480,640 500,658 520,640" fill="none" stroke="rgba(0,220,0,0.65)" stroke-width="1.2"/>
    <polyline points="487,670 500,683 513,670" fill="none" stroke="rgba(0,220,0,0.5)"  stroke-width="1.1"/>
    <polyline points="492,696 500,706 508,696" fill="none" stroke="rgba(0,220,0,0.38)" stroke-width="1"/>
    <!-- lens edge ring (subtle) -->
    <circle cx="500" cy="500" r="462" fill="none" stroke="rgba(0,200,0,0.18)" stroke-width="1"/>
    <circle cx="500" cy="500" r="467" fill="none" stroke="rgba(0,200,0,0.08)" stroke-width="2"/>
  </svg>
  <div id="scope-zoom">4√ó</div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script>
// ============================================================================
//  SCENE SETUP
// ============================================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0d1a2e);
scene.fog = new THREE.FogExp2(0x0d1a2e, 0.006);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.15, 160);
camera.rotation.order = 'YXZ';
const GROUND_Y = 1.65;
camera.position.set(0, GROUND_Y, 0);

// Perf: no antialias, request discrete GPU, cap pixel ratio at 1x (biggest GPU win)
const renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:"high-performance" });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 1));
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ============================================================================
//  LIGHTING & STARS
// ============================================================================
scene.add(new THREE.AmbientLight(0x5070a0, 1.2));
const moon = new THREE.DirectionalLight(0x7090d0, 1.4);
moon.position.set(30,80,20); scene.add(moon);

// Stars
const sv=[];
for(let i=0;i<400;i++) sv.push((Math.random()-.5)*400, 60+Math.random()*80, (Math.random()-.5)*400);
const sGeo=new THREE.BufferGeometry();
sGeo.setAttribute('position',new THREE.Float32BufferAttribute(sv,3));
scene.add(new THREE.Points(sGeo, new THREE.PointsMaterial({color:0xccddff,size:0.4})));

// Ground
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(200,200),
  new THREE.MeshBasicMaterial({color:0x1a2e1a})
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// ============================================================================
//  WORLD GENERATION (BUILDINGS, TREES, SANDBAGS, COLLIDERS)
// ============================================================================
function seededRng(seed){let s=seed;return()=>{s=(s*16807)%2147483647;return(s-1)/2147483646;};}
const rng=seededRng(42);
const colliders=[];

// ‚îÄ‚îÄ TREE SYSTEM: InstancedMesh ‚Äî 4 total draw calls regardless of tree count ‚îÄ‚îÄ
// Trees are collected then built all at once after all addTree() calls.
const _treeList = [];
function addTree(x, z, scale){
  scale = scale||1;
  const h = (3.5 + rng()*2.5)*scale;
  _treeList.push({x, z, scale, h});
  colliders.push({type:'circle', x, z, r:0.75*scale});
}
function _buildTrees(){
  const n = _treeList.length;
  const dummy = new THREE.Object3D();
  // Shared geometry templates (unit size ‚Äî scale per instance)
  const trunkGeo = new THREE.CylinderGeometry(0.18, 0.28, 1, 5);
  const coneGeo  = new THREE.ConeGeometry(1, 1, 5);
  const trunkMat = new THREE.MeshLambertMaterial({color:0x3d2210});
  const fMat1    = new THREE.MeshLambertMaterial({color:0x1a3d12});
  const fMat2    = new THREE.MeshLambertMaterial({color:0x0d2a08});
  const iT  = new THREE.InstancedMesh(trunkGeo, trunkMat, n);
  const iC0 = new THREE.InstancedMesh(coneGeo,  fMat1, n);
  const iC1 = new THREE.InstancedMesh(coneGeo,  fMat2, n);
  const iC2 = new THREE.InstancedMesh(coneGeo,  fMat1, n);
  iT.frustumCulled = iC0.frustumCulled = iC1.frustumCulled = iC2.frustumCulled = false;
  _treeList.forEach(({x,z,scale,h}, i)=>{
    // Trunk: height=h, radii scaled
    dummy.position.set(x, h/2, z); dummy.scale.set(scale, h, scale);
    dummy.updateMatrix(); iT.setMatrixAt(i, dummy.matrix);
    // Three cone tiers
    [[0,1.5,2.2],[0.7,1.2,2.2],[1.35,0.9,2.2]].forEach(([yOff,r,ch], ti)=>{
      dummy.position.set(x, h*0.55+yOff*scale, z);
      dummy.scale.set(r*scale, ch*scale, r*scale);
      dummy.updateMatrix();
      [iC0,iC1,iC2][ti].setMatrixAt(i, dummy.matrix);
    });
  });
  [iT,iC0,iC1,iC2].forEach(m=>{ m.instanceMatrix.needsUpdate=true; scene.add(m); });
}

// ‚îÄ‚îÄ BUILDING SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Each building merges ALL its box geometry into 2 draw calls (opaque + glass).
// Trees use InstancedMesh. Total scene draw calls: ~60 instead of ~1500.

const FLOOR_H  = 3.2;
const WT       = 0.35;
const DOOR_W   = 3.2;
const DOOR_H   = 2.6;
const WIN_W    = 1.5;
const WIN_H    = 1.1;
const WIN_SILL = 0.9;
const STAIR_W  = 1.8;
const STAIR_D  = 2.6;

const wallColliders  = [];
const floorPlatforms = [];
const slopeZones     = [];
const buildingBounds = [];  // {x1,x2,z1,z2,h} ‚Äî for glass-proximity fade

const concreteColors = [0x4a5568,0x3d4a5c,0x525f72,0x3a4455,0x46556a];
// Shared Lambert materials ‚Äî one per colour (no per-instance allocation)
const _cMats  = concreteColors.map(c => new THREE.MeshLambertMaterial({color:c}));
const _glMat  = new THREE.MeshBasicMaterial({color:0x3a6080, transparent:true, opacity:0.06, side:THREE.DoubleSide});
const _flMat  = new THREE.MeshLambertMaterial({color:0x1c2a38});
const _stMat  = new THREE.MeshLambertMaterial({color:0x2a3d50});
const _roofC  = new THREE.MeshLambertMaterial({color:0x1c2c38});

// Push a translated BoxGeometry into a collector array (no Mesh, no scene.add)
function _gb(x,y,z, w,h,d, arr){
  const g = new THREE.BoxGeometry(w,h,d);
  g.translate(x,y,z);
  arr.push(g);
}

// Merge collector array into one Mesh and add to scene; dispose intermediates
function _merge(arr, mat){
  if(!arr.length) return;
  const m = new THREE.Mesh(THREE.BufferGeometryUtils.mergeBufferGeometries(arr), mat);
  scene.add(m);
  arr.forEach(g=>g.dispose());
}

// buildWallFace: pushes box geometries into op[]/gl[] arrays; no Mesh created here.
function buildWallFace(op, gl, cx, cz, span, floorY, axis, hasDoor){
  const yMin = floorY + GROUND_Y - 0.2;
  const yMax = floorY + FLOOR_H + GROUND_Y + 0.1;

  if(hasDoor){
    const sideW=(span-DOOR_W)/2, panH=DOOR_H, headH=FLOOR_H-DOOR_H;
    if(axis==='x'){
      if(sideW>0.02){
        _gb(cx-span/2+sideW/2, floorY+panH/2, cz, sideW, panH, WT, op);
        _gb(cx+span/2-sideW/2, floorY+panH/2, cz, sideW, panH, WT, op);
        wallColliders.push({x:cx-span/2+sideW/2,z:cz,hw:sideW/2+0.05,hd:WT/2+0.28,yMin,yMax});
        wallColliders.push({x:cx+span/2-sideW/2,z:cz,hw:sideW/2+0.05,hd:WT/2+0.28,yMin,yMax});
      }
      if(headH>0.02){
        _gb(cx, floorY+DOOR_H+headH/2, cz, span, headH, WT, op);
        wallColliders.push({x:cx,z:cz,hw:span/2+0.05,hd:WT/2+0.28,yMin:floorY+DOOR_H+GROUND_Y-0.1,yMax});
      }
    } else {
      if(sideW>0.02){
        _gb(cx, floorY+panH/2, cz-span/2+sideW/2, WT, panH, sideW, op);
        _gb(cx, floorY+panH/2, cz+span/2-sideW/2, WT, panH, sideW, op);
        wallColliders.push({x:cx,z:cz-span/2+sideW/2,hw:WT/2+0.28,hd:sideW/2+0.05,yMin,yMax});
        wallColliders.push({x:cx,z:cz+span/2-sideW/2,hw:WT/2+0.28,hd:sideW/2+0.05,yMin,yMax});
      }
      if(headH>0.02){
        _gb(cx, floorY+DOOR_H+headH/2, cz, WT, headH, span, op);
        wallColliders.push({x:cx,z:cz,hw:WT/2+0.28,hd:span/2+0.05,yMin:floorY+DOOR_H+GROUND_Y-0.1,yMax});
      }
    }
    return;
  }

  // Windowed wall
  const numW=Math.max(1,Math.floor(span/2.6)), wSpace=span/numW, pilW=wSpace-WIN_W;
  const winCy=floorY+WIN_SILL+WIN_H/2, headH=FLOOR_H-WIN_SILL-WIN_H;
  _gb(cx, floorY+WIN_SILL/2, cz, axis==='x'?span:WT, WIN_SILL, axis==='x'?WT:span, op);
  if(headH>0.01) _gb(cx, floorY+WIN_SILL+WIN_H+headH/2, cz, axis==='x'?span:WT, headH, axis==='x'?WT:span, op);
  // Windows (glass panes)
  for(let i=0;i<numW;i++){
    if(axis==='x'){
      const wx=cx-span/2+wSpace*(i+0.5);
      _gb(wx, winCy, cz, WIN_W*0.92, WIN_H*0.88, 0.05, gl);
    } else {
      const wz=cz-span/2+wSpace*(i+0.5);
      _gb(cx, winCy, wz, 0.05, WIN_H*0.88, WIN_W*0.92, gl);
    }
  }
  // Vertical pillars: p=0..numW (numW+1 total).
  // p=0 and p=numW are edge pillars: half-width, flush with wall face.
  // p=1..numW-1 are inter-window pillars: full pilW, centred on slot boundary.
  if(pilW>0.02){
    // startPos: origin for pillar positions along the span axis.
    // For axis='x' walls (N/S) the span runs in X ‚Üí start from cx.
    // For axis='z' walls (E/W) the span runs in Z ‚Üí start from cz.
    // Bug was using cx for both, placing E/W pillars at wrong Z coords.
    const startPos = axis==='x' ? cx-span/2 : cz-span/2;
    for(let p=0;p<=numW;p++){
      const edge = (p===0||p===numW);
      const pw   = edge ? pilW/2 : pilW;
      const bPos = startPos + wSpace*p;
      const cPos = edge ? (p===0 ? bPos+pw/2 : bPos-pw/2) : bPos;
      if(axis==='x') _gb(cPos, winCy, cz, pw, WIN_H, WT, op);
      else            _gb(cx, winCy, cPos, WT, WIN_H, pw, op);
    }
  }
  if(axis==='x') wallColliders.push({x:cx,z:cz,hw:span/2+0.05,hd:WT/2+0.28,yMin,yMax});
  else           wallColliders.push({x:cx,z:cz,hw:WT/2+0.28,hd:span/2+0.05,yMin,yMax});
}


// Gun range exclusion ‚Äî obstacles must not overlap the range footprint
function _notInRange(bx,bz,hw=0,hd=0){
  // Gun range exclusion
  const inRange = bx+hw>21&&bx-hw<39&&bz+hd>-71&&bz-hd<-49;
  // Arena exclusion (0¬±20, -130¬±18)
  const inArenaZone = bx+hw>-38&&bx-hw<38&&bz+hd>-165&&bz-hd<-105;
  return !inRange && !inArenaZone;
}
function addBuilding(bx, bz, bw, bd, floors){
  if(!_notInRange(bx,bz,bw/2+1,bd/2+1)) return;
  // Collect all geometry ‚Äî 2 arrays = 2 draw calls total for the whole building
  const op=[], gl=[];
  const mat = _cMats[Math.floor(rng()*_cMats.length)];
  const h   = floors * FLOOR_H;
  const stX1=bx+bw/2-WT-STAIR_W, stX2=bx+bw/2-WT;
  const stZ1=bz-bd/2+WT,          stZ2=stZ1+STAIR_D;
  const rampLen=Math.sqrt(STAIR_D*STAIR_D+FLOOR_H*FLOOR_H);
  const rampAngle=-Math.atan2(FLOOR_H,STAIR_D);

  for(let fl=0;fl<floors;fl++){
    const fy=fl*FLOOR_H;
    buildWallFace(op,gl, bx,       bz-bd/2+WT/2, bw, fy, 'x', false);
    buildWallFace(op,gl, bx,       bz+bd/2-WT/2, bw, fy, 'x', fl===0);
    buildWallFace(op,gl, bx+bw/2-WT/2, bz,       bd, fy, 'z', false);
    buildWallFace(op,gl, bx-bw/2+WT/2, bz,       bd, fy, 'z', false);
    if(fl>0){
      // Floor slab with stairwell cutout at NE corner
      const flX1=bx-bw/2+WT, flX2=bx+bw/2-WT;
      const flZ1=bz-bd/2+WT, flZ2=bz+bd/2-WT;
      const sy=fy+0.07, sh=0.15;
      // West section: full depth, from west inner wall to stairwell west edge
      const wW=stX1-flX1;
      if(wW>0.02) _gb((flX1+stX1)/2, sy, (flZ1+flZ2)/2, wW, sh, flZ2-flZ1, op);
      // South-east section: from stairwell east to east wall, south of stairwell
      const wE=flX2-stX1, dS=flZ2-stZ2;
      if(wE>0.02&&dS>0.02) _gb((stX1+flX2)/2, sy, (stZ2+flZ2)/2, wE, sh, dS, op);
      // Collision platform covers full interior (player landing uses this)
      floorPlatforms.push({y:fy, x1:flX1, x2:flX2, z1:flZ1, z2:flZ2});
    }
    // Stair ramp ‚Äî between ALL consecutive floors INCLUDING top floor ‚Üí roof
    if(fl<floors){
      const yTop_ramp = (fl===floors-1) ? h+0.20 : fy+FLOOR_H; // top of this ramp
      const rg=new THREE.BoxGeometry(STAIR_W-0.1,0.2,rampLen);
      rg.applyMatrix4(new THREE.Matrix4().makeRotationX(rampAngle));
      rg.translate((stX1+stX2)/2, fy+FLOOR_H/2, (stZ1+stZ2)/2);
      op.push(rg);
      slopeZones.push({x1:stX1,x2:stX2,zEntry:stZ2,zExit:stZ1,yBot:fy,yTop:yTop_ramp});
    }
  }
  _gb(bx, h+0.1, bz, bw+0.3, 0.2, bd+0.3, op);
  floorPlatforms.push({y:h+0.2, x1:bx-bw/2-0.1, x2:bx+bw/2+0.1, z1:bz-bd/2-0.1, z2:bz+bd/2+0.1});
  for(let i=0;i<Math.floor(rng()*3+1);i++){
    _gb(bx+(rng()-0.5)*(bw-1), h+0.55, bz+(rng()-0.5)*(bd-1), 0.8+rng()*0.5, 0.55, 0.7+rng()*0.5, op);
  }
  _merge(op, mat);    // 1 draw call: all opaque geometry
  _merge(gl, _glMat); // 1 draw call: all glass panes
  buildingBounds.push({x1:bx-bw/2, x2:bx+bw/2, z1:bz-bd/2, z2:bz+bd/2, h});
}

function addRuin(x, z, rot){
  if(!_notInRange(x,z,3.5,1.5)) return;
  const mat = _cMats[Math.floor(rng()*_cMats.length)];
  const h   = 2.5+rng()*2;
  const geos=[];
  const wg=new THREE.BoxGeometry(5,h,0.6);
  if(rot) wg.applyMatrix4(new THREE.Matrix4().makeRotationY(rot));
  wg.translate(x,h/2,z); geos.push(wg);
  for(let i=0;i<4;i++){
    const rx=x+(rng()-0.5)*3, rz=z+(rng()-0.5)*1.5, rs=0.3+rng()*0.4;
    const rg=new THREE.BoxGeometry(rs,rs*0.6,rs);
    rg.applyMatrix4(new THREE.Matrix4().makeRotationY(rng()*Math.PI));
    rg.translate(rx,rs*0.3,rz); geos.push(rg);
  }
  _merge(geos, mat);
  const hw=(rot&&Math.abs(Math.sin(rot))>0.5)?0.6:2.8;
  const hd=(rot&&Math.abs(Math.sin(rot))>0.5)?2.8:0.6;
  colliders.push({type:'box',x,z,hw:hw+0.4,hd:hd+0.4});
}

const _sbMat = new THREE.MeshLambertMaterial({color:0x7a6a44});
function addSandbags(x, z, len, rot){
  if(!_notInRange(x,z,len/2+1,1.5)) return;
  const g1=new THREE.BoxGeometry(len,0.45,0.72);    g1.translate(0,0.22,0);
  const g2=new THREE.BoxGeometry(len*0.92,0.38,0.62); g2.translate(0,0.64,0);
  const mg=THREE.BufferGeometryUtils.mergeBufferGeometries([g1,g2]);
  if(rot) mg.applyMatrix4(new THREE.Matrix4().makeRotationY(rot));
  mg.translate(x,0,z);
  scene.add(new THREE.Mesh(mg,_sbMat));
  g1.dispose(); g2.dispose();
  // wallCollider with yMax so player can jump over sandbags.
  // Sandbag top ~0.85 world units; camera at ground = GROUND_Y (1.65).
  // Once camera.position.y > 0.85+GROUND_Y the collider is skipped.
  const isRot=(rot&&Math.abs(Math.sin(rot))>0.5);
  wallColliders.push({x,z,
    hw:isRot?0.7:len/2+0.3,
    hd:isRot?len/2+0.3:0.7,
    yMin:0, yMax:0.85+GROUND_Y});
}


// ============================================================================
//  SHOP BUILDING + MERCHANT NPC
// ============================================================================
const SHOP_X = -5, SHOP_Z = -40; // world position ‚Äî clear of combat buildings
const SHOP_W = 9,  SHOP_D = 8;   // footprint
const SHOP_INTERACT_DIST = 2.8;   // units from NPC to open shop

// ‚îÄ‚îÄ Distinct material: warm sandstone / cream ‚îÄ‚îÄ
const _shopMat  = new THREE.MeshLambertMaterial({color:0xe8d8b0});
const _shopAccent = new THREE.MeshLambertMaterial({color:0xc8a850}); // gold trim
const _shopSign   = new THREE.MeshLambertMaterial({color:0x224400}); // dark green sign board
const _shopSignTxt= new THREE.MeshBasicMaterial({color:0x88ff44});   // bright green text glow
const _shopGlMat  = new THREE.MeshLambertMaterial({color:0x88ccff, transparent:true, opacity:0.3, side:THREE.DoubleSide});

function addShopBuilding(){
  const bx=SHOP_X, bz=SHOP_Z;
  const bw=SHOP_W, bd=SHOP_D;
  const fl=1; // single floor
  const h=FLOOR_H;
  const op=[], gl=[];

  // ‚îÄ‚îÄ Walls (no door helper needed ‚Äî we carve manually) ‚îÄ‚îÄ
  // South wall (front, facing +Z toward player spawn) ‚Äî has open doorway
  const doorW=2.2, doorH=2.4;
  const sideW=(bw-doorW)/2;
  // South wall left segment
  _gb(bx-bw/2+sideW/2,  h/2, bz-bd/2+WT/2, sideW, h, WT, op);
  // South wall right segment
  _gb(bx+sideW/2+doorW/2+0.1, h/2, bz-bd/2+WT/2, sideW, h, WT, op);
  // South wall header above door
  const headH=h-doorH;
  if(headH>0.02) _gb(bx, doorH+headH/2, bz-bd/2+WT/2, doorW, headH, WT, op);
  // Door frame gold trim (vertical strips)
  _gb(bx-doorW/2, h/2, bz-bd/2+WT/2, 0.12, h, 0.14, op); // set to accent below
  _gb(bx+doorW/2, h/2, bz-bd/2+WT/2, 0.12, h, 0.14, op);

  // North wall (back, solid)
  _gb(bx, h/2, bz+bd/2-WT/2, bw, h, WT, op);
  // East wall
  _gb(bx+bw/2-WT/2, h/2, bz, WT, h, bd, op);
  // West wall
  _gb(bx-bw/2+WT/2, h/2, bz, WT, h, bd, op);

  // Floor slab (raised slightly above ground)
  _gb(bx, 0.05, bz, bw, 0.10, bd, op);

  // Roof slab
  _gb(bx, h+0.10, bz, bw+0.3, 0.2, bd+0.3, op);

  // ‚îÄ‚îÄ Interior: counter along north wall ‚îÄ‚îÄ
  // Counter top
  _gb(bx, 0.9, bz+bd/2-1.2, bw-WT*2-0.4, 0.12, 0.8, op);
  // Counter front face
  _gb(bx, 0.45, bz+bd/2-1.65, bw-WT*2-0.4, 0.90, 0.12, op);
  // Counter legs (2)
  for(const sx of [-1,1]) _gb(bx+sx*(bw/2-WT-0.6), 0.45, bz+bd/2-1.65, 0.12, 0.90, 0.12, op);

  // ‚îÄ‚îÄ Shelving on east + west walls ‚îÄ‚îÄ
  for(const sx of [-1,1]){
    const wx=bx+sx*(bw/2-WT-0.06);
    _gb(wx, 0.6,  bz, 0.12, 0.08, bd*0.6, op); // shelf 1
    _gb(wx, 1.1,  bz, 0.12, 0.08, bd*0.6, op); // shelf 2
    _gb(wx, 1.55, bz, 0.12, 0.08, bd*0.6, op); // shelf 3
  }

  // ‚îÄ‚îÄ Windows (east + west, using glass) ‚îÄ‚îÄ
  for(const sx of [-1,1]){
    const wx=bx+sx*(bw/2-WT/2);
    _gb(wx, WIN_SILL+WIN_H/2, bz-0.5, WT, WIN_H, WIN_W, gl);
    _gb(wx, WIN_SILL+WIN_H/2, bz+0.9, WT, WIN_H, WIN_W, gl);
  }

  // ‚îÄ‚îÄ Exterior sign above door ‚îÄ‚îÄ
  // Sign board
  const sgW=3.2, sgH=0.55;
  _gb(bx, h-0.25, bz-bd/2-0.05, sgW, sgH, 0.12, op); // merged as opaque, will tint via accent mat below

  // ‚îÄ‚îÄ Merge geometry ‚îÄ‚îÄ
  if(op.length) _merge(op, _shopMat);
  if(gl.length) _merge(gl, _shopGlMat);

  // Sign board as separate mesh so we can use distinct material
  const signGeo=new THREE.BoxGeometry(3.2,0.55,0.14);
  const signMesh=new THREE.Mesh(signGeo,_shopSign);
  signMesh.position.set(bx, h-0.25, bz-bd/2-0.05);
  scene.add(signMesh);

  // "SUPPLY DEPOT" glow bar on sign face
  const glowBar=new THREE.Mesh(new THREE.BoxGeometry(2.8,0.18,0.02),_shopSignTxt);
  glowBar.position.set(bx, h-0.25, bz-bd/2-0.12);
  scene.add(glowBar);

  // Gold door frame accent meshes
  const dfG=new THREE.BoxGeometry(0.14,FLOOR_H,0.18);
  for(const dx of [-doorW/2, doorW/2]){
    const df=new THREE.Mesh(dfG,_shopAccent);
    df.position.set(bx+dx, h/2, bz-bd/2+WT/2);
    scene.add(df);
  }
  // Gold sign border
  const sbG=new THREE.BoxGeometry(3.4,0.65,0.10);
  const sb=new THREE.Mesh(sbG,_shopAccent);
  sb.position.set(bx, h-0.25, bz-bd/2-0.06);
  scene.add(sb);

  // ‚îÄ‚îÄ Colliders ‚Äî walls with door gap on south ‚îÄ‚îÄ
  // South wall halves (leave door gap)
  wallColliders.push({x:bx-bw/2+sideW/2, z:bz-bd/2, hw:sideW/2+0.1, hd:WT/2+0.28, yMin:0, yMax:h+1});
  wallColliders.push({x:bx+sideW/2+doorW/2+0.1, z:bz-bd/2, hw:sideW/2+0.1, hd:WT/2+0.28, yMin:0, yMax:h+1});
  wallColliders.push({x:bx, z:bz+bd/2, hw:bw/2+0.1, hd:WT/2+0.28, yMin:0, yMax:h+1});
  wallColliders.push({x:bx+bw/2, z:bz, hw:WT/2+0.28, hd:bd/2+0.1, yMin:0, yMax:h+1});
  wallColliders.push({x:bx-bw/2, z:bz, hw:WT/2+0.28, hd:bd/2+0.1, yMin:0, yMax:h+1});
  // Counter collision
  colliders.push({type:'box', x:bx, z:bz+bd/2-1.2, hw:bw/2-WT-0.1, hd:0.5});
  // Floor platform + roof for getFloorY
  floorPlatforms.push({y:0.15, x1:bx-bw/2+WT, x2:bx+bw/2-WT, z1:bz-bd/2+WT, z2:bz+bd/2-WT});
  floorPlatforms.push({y:h+0.20, x1:bx-bw/2, x2:bx+bw/2, z1:bz-bd/2, z2:bz+bd/2});
  buildingBounds.push({x1:bx-bw/2, x2:bx+bw/2, z1:bz-bd/2, z2:bz+bd/2, h});
}

// ‚îÄ‚îÄ Merchant NPC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _ncpG = {
  head:  new THREE.BoxGeometry(0.38,0.34,0.38),
  torso: new THREE.BoxGeometry(0.52,0.58,0.26),
  hips:  new THREE.BoxGeometry(0.46,0.24,0.24),
  uArm:  new THREE.BoxGeometry(0.19,0.44,0.19),
  lArm:  new THREE.BoxGeometry(0.16,0.38,0.16),
  uLeg:  new THREE.BoxGeometry(0.21,0.48,0.21),
  lLeg:  new THREE.BoxGeometry(0.19,0.42,0.19),
  foot:  new THREE.BoxGeometry(0.22,0.09,0.34),
};
const _ncpMat = {
  skin:  new THREE.MeshLambertMaterial({color:0xd4a882}),
  coat:  new THREE.MeshLambertMaterial({color:0xeeeedd}), // white shopkeeper coat
  apron: new THREE.MeshLambertMaterial({color:0x4466aa}), // blue apron
  leg:   new THREE.MeshLambertMaterial({color:0x334455}),
  boot:  new THREE.MeshLambertMaterial({color:0x221100}),
  hair:  new THREE.MeshLambertMaterial({color:0x332200}),
  eye:   new THREE.MeshBasicMaterial({color:0x224488}),
};

function makeMerchantModel(){
  const g=new THREE.Group();
  const add=(geo,mat,x,y,z,rx=0,ry=0,rz=0)=>{
    const m=new THREE.Mesh(geo,mat); m.position.set(x,y,z);
    m.rotation.set(rx,ry,rz); g.add(m);
  };
  // Head
  add(_ncpG.head, _ncpMat.skin, 0,0.78,0);
  // Hair (dark block on top)
  add(new THREE.BoxGeometry(0.40,0.12,0.38),_ncpMat.hair, 0,0.96,0);
  // Eyes
  const eyeG=new THREE.BoxGeometry(0.07,0.055,0.04);
  for(const ex of [-0.09,0.09]){
    const em=new THREE.Mesh(eyeG,_ncpMat.eye); em.position.set(ex,0.79,0.18); g.add(em);
  }
  // Torso ‚Äî white coat
  add(_ncpG.torso, _ncpMat.coat, 0,0.40,0);
  // Apron overlay (front of torso)
  add(new THREE.BoxGeometry(0.38,0.55,0.04),_ncpMat.apron, 0,0.38,0.14);
  // Hips
  add(_ncpG.hips, _ncpMat.leg, 0,0.03,0);
  // Arms ‚Äî resting slightly forward (like leaning on counter)
  add(_ncpG.uArm,_ncpMat.coat,-0.38, 0.36,0, -0.5,0,0);
  add(_ncpG.lArm,_ncpMat.skin,-0.38, -0.04,-0.18);
  add(_ncpG.uArm,_ncpMat.coat, 0.38, 0.36,0, -0.5,0,0);
  add(_ncpG.lArm,_ncpMat.skin, 0.38, -0.04,-0.18);
  // Legs
  for(const sx of [-1,1]){
    add(_ncpG.uLeg,_ncpMat.leg,  sx*0.12,-0.35,0);
    add(_ncpG.lLeg,_ncpMat.leg,  sx*0.12,-0.74,0);
    add(_ncpG.foot,_ncpMat.boot, sx*0.12,-0.99,0.05);
  }
  return g;
}

// NPC state
let merchantMesh = null;
let merchantInteractable = false; // true when player is close enough
const _promptEl = document.getElementById('interact-prompt');


// ‚îÄ‚îÄ Rebirth NPC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let rebirthNPCMesh = null;
let rebirthNPCInteractable = false;
// Position: far corner of shop building interior
const REBIRTH_X = SHOP_X + SHOP_W/2 - 1.2;
const REBIRTH_Z = SHOP_Z - SHOP_D/2 + 1.4;

function makeRebirthNPCModel(){
  // Reuse _ncpG geometries, give a purple/mystic look
  const _rb = {
    robe:  new THREE.MeshLambertMaterial({color:0x4a0080}), // deep purple robe
    skin:  new THREE.MeshLambertMaterial({color:0xd0b090}),
    hair:  new THREE.MeshLambertMaterial({color:0xffffff}), // white hair ‚Äî ancient
    eye:   new THREE.MeshBasicMaterial({color:0xcc44ff}),   // purple glowing eyes
    aura:  new THREE.MeshBasicMaterial({color:0x8800ff,transparent:true,opacity:0.18}),
  };
  const g = new THREE.Group();
  const add=(geo,mat,x,y,z,rx=0,ry=0,rz=0)=>{
    const m=new THREE.Mesh(geo,mat); m.position.set(x,y,z);
    m.rotation.set(rx,ry,rz); g.add(m);
  };
  add(_ncpG.head,  _rb.skin,  0,0.78,0);
  add(new THREE.BoxGeometry(0.42,0.14,0.40),_rb.hair, 0,0.97,0);
  // Flowing robe (wider torso)
  add(new THREE.BoxGeometry(0.62,0.70,0.32),_rb.robe, 0,0.38,0);
  add(_ncpG.hips, _rb.robe, 0,0.03,0);
  const eyeG=new THREE.BoxGeometry(0.07,0.055,0.04);
  for(const ex of[-0.09,0.09]){
    const em=new THREE.Mesh(eyeG,_rb.eye); em.position.set(ex,0.79,0.18); g.add(em);
  }
  // Long sleeves
  add(_ncpG.uArm,_rb.robe,-0.40,0.38,0,-0.3,0,0.2);
  add(_ncpG.lArm,_rb.robe,-0.40,-0.04,-0.1);
  add(_ncpG.uArm,_rb.robe, 0.40,0.38,0,-0.3,0,-0.2);
  add(_ncpG.lArm,_rb.robe, 0.40,-0.04,-0.1);
  for(const sx of[-1,1]){
    add(_ncpG.uLeg,_rb.robe,sx*0.12,-0.35,0);
    add(_ncpG.lLeg,_rb.robe,sx*0.12,-0.74,0);
    add(new THREE.BoxGeometry(0.24,0.12,0.34),_rb.robe,sx*0.12,-0.98,0.04);
  }
  // Aura orb floating above head
  const auraGeo = new THREE.SphereGeometry(0.28,8,6);
  add(auraGeo, _rb.aura, 0, 1.40, 0);
  g.userData.auraIdx = g.children.length-1; // track for animation
  return g;
}

function buildRebirthNPC(){
  rebirthNPCMesh = makeRebirthNPCModel();
  rebirthNPCMesh.position.set(REBIRTH_X, 0.10, REBIRTH_Z);
  rebirthNPCMesh.rotation.y = Math.PI + 0.4; // face slightly toward player entry
  rebirthNPCMesh.userData.bobT = 0;
  scene.add(rebirthNPCMesh);

  const label = makeNameSprite('REBIRTH');
  label.position.set(REBIRTH_X, 2.4, REBIRTH_Z);
  label.material.map; // already created
  // Tint label canvas purple
  scene.add(label);
}

function updateRebirthNPC(){
  if(!rebirthNPCMesh) return;
  const dx=camera.position.x-REBIRTH_X;
  const dz=camera.position.z-REBIRTH_Z;
  const near = dx*dx+dz*dz < SHOP_INTERACT_DIST*SHOP_INTERACT_DIST;
  if(near !== rebirthNPCInteractable){
    rebirthNPCInteractable = near;
    if(near && !rebirthNPCPromptShown){
      _promptEl.textContent = '[ E ] REBIRTH';
      _promptEl.style.display = 'block';
      _promptEl.style.borderColor = 'rgba(200,100,255,0.6)';
      _promptEl.style.color = '#cc88ff';
    } else if(!merchantInteractable){
      _promptEl.style.display = 'none';
      _promptEl.textContent = '[ E ] TRADE';
      _promptEl.style.borderColor = 'rgba(255,215,0,0.6)';
      _promptEl.style.color = '#ffd700';
    }
  }
  // Aura pulse
  rebirthNPCMesh.userData.bobT += 0.03;
  rebirthNPCMesh.position.y = 0.10 + Math.sin(rebirthNPCMesh.userData.bobT)*0.01;
  const aura = rebirthNPCMesh.children[rebirthNPCMesh.userData.auraIdx];
  if(aura){ aura.material.opacity = 0.12 + Math.sin(rebirthNPCMesh.userData.bobT*1.3)*0.10; }
}
let rebirthNPCPromptShown = false;


// ============================================================================
//  BOSS SYSTEM
// ============================================================================
const BOSS_DEFS = [
  { id:'grunt',   name:'GRUNT COMMANDER',  emoji:'ü™ñ', lvCost:2,  coinCost:100,   hp:2000,    dmg:30,  speed:0.038, scale:1.5, color:0x4a7a2a, eyeColor:0xff2200, coinReward:500,    xpReward:200   },
  { id:'chief',   name:'WAR CHIEF',        emoji:'‚öîÔ∏è', lvCost:5,  coinCost:250,   hp:5500,    dmg:55,  speed:0.044, scale:1.8, color:0x8a5a10, eyeColor:0xff6600, coinReward:1400,   xpReward:550   },
  { id:'plague',  name:'PLAGUE COLOSSUS',  emoji:'‚ò£Ô∏è', lvCost:10, coinCost:500,   hp:14000,   dmg:90,  speed:0.050, scale:2.1, color:0x8a3a18, eyeColor:0xff9900, coinReward:3500,   xpReward:1600,  special:'minions', minionRate:240 },
  { id:'knight',  name:'DEATH KNIGHT',     emoji:'üíÄ', lvCost:18, coinCost:900,   hp:32000,   dmg:145, speed:0.056, scale:2.5, color:0x5a0808, eyeColor:0xffcc00, coinReward:8500,   xpReward:4500  },
  { id:'titan',   name:'VOID TITAN',       emoji:'üëÅ', lvCost:30, coinCost:1500,  hp:75000,   dmg:240, speed:0.068, scale:3.0, color:0x0a0010, eyeColor:0xff00ff, coinReward:22000,  xpReward:12000, special:'rage', rageHp:0.4 },
  { id:'necro',   name:'NECROMANCER KING', emoji:'üßô', lvCost:42, coinCost:2500,  hp:120000,  dmg:180, speed:0.055, scale:2.8, color:0x200030, eyeColor:0xaa00ff, coinReward:55000,  xpReward:30000, special:'minions', minionRate:180 },
  { id:'colossus',name:'IRON COLOSSUS',    emoji:'ü§ñ', lvCost:60, coinCost:4000,  hp:350000,  dmg:280, speed:0.030, scale:4.0, color:0x334455, eyeColor:0x00ccff, coinReward:140000, xpReward:80000, special:'slam',   slamRange:6, slamDmg:300 },
  { id:'wraith',  name:'SHADOW WRAITH',    emoji:'üëª', lvCost:80, coinCost:6000,  hp:200000,  dmg:220, speed:0.130, scale:2.2, color:0x080818, eyeColor:0x8888ff, coinReward:200000, xpReward:120000,special:'blink',  blinkRate:300 },
  { id:'dragon',  name:'DRAGON GOD',       emoji:'üêâ', lvCost:100,coinCost:10000, hp:600000,  dmg:350, speed:0.058, scale:3.5, color:0x8a0000, eyeColor:0xff4400, coinReward:500000, xpReward:300000,special:'ranged', rangedDmg:120, rangedRate:90 },
  { id:'reaper',  name:'COSMIC REAPER',    emoji:'üí´', lvCost:130,coinCost:20000, hp:1500000, dmg:500, speed:0.080, scale:3.8, color:0x000010, eyeColor:0xffffff, coinReward:1500000,xpReward:800000,special:'all' },
];

let activeBoss      = null; // { mesh, hpSpr, hp, maxHp, dmg, speed, def, atkCd }
let bossArenaActive = false;
const BOSS_ARENA_X  = SHOP_X;
const BOSS_ARENA_Z  = SHOP_Z - 30; // in front of shop, safe zone
const BOSS_NPC_X    = SHOP_X - SHOP_W/2 + 1.2;
const BOSS_NPC_Z    = SHOP_Z - SHOP_D/2 + 1.4;
let bossNPCMesh     = null;
let bossNPCInteractable = false;

function makeBossModel(def){
  const mat = {
    body: new THREE.MeshLambertMaterial({color:def.color}),
    eye:  new THREE.MeshBasicMaterial({color:def.eyeColor}),
    arm:  new THREE.MeshLambertMaterial({color:def.color}),
  };
  const sc = def.scale;
  const g  = new THREE.Group();
  const add=(geo,m,x,y,z)=>{ const mesh=new THREE.Mesh(geo,m); mesh.position.set(x*sc,y*sc,z*sc); g.add(mesh); };
  // Body parts scaled up
  add(new THREE.BoxGeometry(0.5*sc,0.4*sc,0.5*sc), mat.body,  0, 1.0, 0); // head
  add(new THREE.BoxGeometry(0.7*sc,0.7*sc,0.35*sc),mat.body,  0, 0.5, 0); // torso
  add(new THREE.BoxGeometry(0.6*sc,0.3*sc,0.3*sc), mat.body,  0, 0.1, 0); // hips
  for(const ex of[-0.12,0.12]){
    const em=new THREE.Mesh(new THREE.BoxGeometry(0.1*sc,0.08*sc,0.06*sc),mat.eye);
    em.position.set(ex*sc,1.02*sc,0.22*sc); g.add(em);
  }
  for(const sx of[-1,1]){
    add(new THREE.BoxGeometry(0.25*sc,0.55*sc,0.25*sc),mat.arm,sx*0.52,0.52,0);
    add(new THREE.BoxGeometry(0.22*sc,0.50*sc,0.22*sc),mat.arm,sx*0.52,0.0, 0);
    add(new THREE.BoxGeometry(0.28*sc,0.55*sc,0.28*sc),mat.body,sx*0.17,-0.36,0);
    add(new THREE.BoxGeometry(0.25*sc,0.50*sc,0.25*sc),mat.body,sx*0.17,-0.82,0);
  }
  g.scale.setScalar(1); // already scaled per-part
  return g;
}

function spawnBoss(def){
  if(activeBoss) return; // one boss at a time
  const mesh = makeBossModel(def);
  const flY  = 0;
  mesh.position.set(BOSS_ARENA_X, flY, BOSS_ARENA_Z);
  scene.add(mesh);
  const hpSpr = makeHPSprite();
  hpSpr.scale.set(2.8, 0.56, 1); // wider bar for big boss
  hpSpr.position.set(BOSS_ARENA_X, flY + def.scale*2.2, BOSS_ARENA_Z);
  scene.add(hpSpr);
  drawHPBar(hpSpr, def.hp, def.hp);
  activeBoss = {mesh, hpSpr, hp:def.hp, maxHp:def.hp, dmg:def.dmg, speed:def.speed, def, atkCd:0, walkT:0};
  bossArenaActive = true;
  addChatMessage('','// ‚ö† '+def.name+' HAS APPEARED ‚Äî DEFEAT IT! //',false,true);
}

function updateBoss(){
  if(!activeBoss) return;
  const b = activeBoss;
  if(b.hp <= 0){
    const cr = Math.round(b.def.coinReward * getRebirthMult('coinmul'));
    const xr = Math.round(b.def.xpReward  * getRebirthMult('xpgain'));
    addCoins(cr); addXP(xr);
    showFloatPop('+'+cr+' ‚¨° BOSS KILL!','#ffd700');
    showFloatPop('+'+xr+' XP','#00ffff');
    showCoinPop('BOSS: +'+cr+' ‚¨°');
    addChatMessage('','// '+b.def.name+' SLAIN ‚Äî '+cr+' COINS & '+xr+' XP EARNED //',false,true);
    scene.remove(b.mesh); scene.remove(b.hpSpr);
    activeBoss = null; bossArenaActive = false;
    const _bh2=document.getElementById('boss-hud'); if(_bh2) _bh2.style.display='none';
    updateHUD(); return;
  }

  b._tick = (b._tick||0)+1;

  // ‚îÄ‚îÄ Rage phase ‚Äî speed boost at low HP ‚îÄ‚îÄ
  const sp = b.def.special;
  if((sp==='rage'||sp==='all') && b.def.rageHp && !b._raged && b.hp < b.maxHp*b.def.rageHp){
    b._raged = true;
    b.speed *= 2.2;
    addChatMessage('','// ‚ö† '+b.def.name+' ENRAGES! //',false,true);
    showFloatPop('‚ö† RAGE!','#ff0000');
  }

  // ‚îÄ‚îÄ Minion spawn ‚îÄ‚îÄ
  if((sp==='minions'||sp==='all') && b.def.minionRate){
    if(b._tick % b.def.minionRate === 0){
      for(let i=0;i<3;i++) spawnZombie();
      addChatMessage('','// '+b.def.name+' SUMMONS REINFORCEMENTS //',false,true);
    }
  }

  // ‚îÄ‚îÄ Blink (teleport) ‚îÄ‚îÄ
  if((sp==='blink'||sp==='all') && b.def.blinkRate){
    if(b._tick % b.def.blinkRate === 0){
      const angle=Math.random()*Math.PI*2, r=3+Math.random()*4;
      b.mesh.position.set(camera.position.x+Math.cos(angle)*r, 0, camera.position.z+Math.sin(angle)*r);
      showFloatPop('üëª BLINK!','#8888ff');
    }
  }

  // ‚îÄ‚îÄ Slam attack (ground AoE) ‚îÄ‚îÄ
  if((sp==='slam'||sp==='all') && b.def.slamRange){
    if(!b._slamCd) b._slamCd=0;
    b._slamCd--;
    if(b._slamCd<=0){
      b._slamCd=150;
      const px=camera.position.x, pz=camera.position.z;
      const dist2=Math.sqrt((px-b.mesh.position.x)**2+(pz-b.mesh.position.z)**2);
      if(dist2<b.def.slamRange && !dead){ takeDamage(b.def.slamDmg||200); showFloatPop('üí• SLAM!','#ff6600'); }
      // Visual shockwave
      for(let i=0;i<6;i++){
        const a=(i/6)*Math.PI*2;
        spawnExplosion(new THREE.Vector3(b.mesh.position.x+Math.cos(a)*4,0,b.mesh.position.z+Math.sin(a)*4));
      }
    }
  }

  // ‚îÄ‚îÄ Ranged fireball attack ‚îÄ‚îÄ
  if((sp==='ranged'||sp==='all') && b.def.rangedRate){
    if(!b._rangedCd) b._rangedCd=0;
    b._rangedCd--;
    if(b._rangedCd<=0){
      b._rangedCd = b.def.rangedRate||90;
      // Spawn a fireball projectile aimed at player
      const fbGeo=new THREE.SphereGeometry(0.28,8,8);
      const fbMat=new THREE.MeshBasicMaterial({color:0xff4400});
      const fb=new THREE.Mesh(fbGeo,fbMat);
      fb.position.copy(b.mesh.position); fb.position.y=1.2;
      scene.add(fb);
      const px=camera.position.x, py=camera.position.y, pz=camera.position.z;
      const fbDir=new THREE.Vector3(px-fb.position.x, py-fb.position.y, pz-fb.position.z).normalize().multiplyScalar(0.22);
      let fbLife=100;
      const rdmg=b.def.rangedDmg||80;
      function fbTick(){
        fbLife--;
        fb.position.add(fbDir);
        if(fbLife<=0||fb.position.distanceToSquared(camera.position)<1.5){
          scene.remove(fb);
          if(fb.position.distanceToSquared(camera.position)<4 && !dead){ takeDamage(rdmg); showFloatPop('üî• FIREBALL -'+rdmg,'#ff4400'); }
          return;
        }
        requestAnimationFrame(fbTick);
      }
      requestAnimationFrame(fbTick);
    }
  }

  // ‚îÄ‚îÄ Move toward player ‚îÄ‚îÄ
  const px=camera.position.x, pz=camera.position.z;
  const dx=px-b.mesh.position.x, dz=pz-b.mesh.position.z;
  const dist=Math.sqrt(dx*dx+dz*dz);
  b.mesh.rotation.y = Math.atan2(dx,dz);
  b.walkT += 0.1;
  if(dist > 2.0 && !dead){
    const nx=b.mesh.position.x+dx/dist*b.speed;
    const nz=b.mesh.position.z+dz/dist*b.speed;
    b.mesh.position.set(nx, 0, nz);
  }

  // ‚îÄ‚îÄ Melee attack ‚îÄ‚îÄ
  if(!dead && dist < 2.2){
    b.atkCd--;
    if(b.atkCd <= 0){
      takeDamage(b.dmg);
      b.atkCd = 60;
    }
  }

  b.hpSpr.position.set(b.mesh.position.x, b.mesh.position.y + b.def.scale*2.2, b.mesh.position.z);
  const _bh=document.getElementById('boss-hud'); const _bb=document.getElementById('boss-hud-bar'); const _bn=document.getElementById('boss-hud-name');
  if(_bh){ _bh.style.display='block'; if(_bb) _bb.style.width=Math.max(0,b.hp/b.maxHp*100)+'%'; if(_bn) _bn.textContent=b.def.name+' ‚Äî '+b.hp.toLocaleString()+'/'+b.maxHp.toLocaleString(); }

  for(let bi=bullets.length-1;bi>=0;bi--){
    const bl=bullets[bi]; if(bl.userData.isRemote) continue;
    if(bl.position.distanceToSquared(b.mesh.position)<(b.def.scale*1.8)**2){
      const dmg=Math.round((bl.userData.damage||25)*damageMultiplier*getRebirthDmgMult());
      b.hp=Math.max(0,b.hp-dmg);
      drawHPBar(b.hpSpr,b.hp,b.maxHp);
      showFloatPop('-'+dmg,'#ff4444');
      showHitMarker();
      scene.remove(bl); bullets.splice(bi,1);
      break;
    }
  }
}

async function startBossFight(defId){
  const def = BOSS_DEFS.find(b=>b.id===defId);
  if(!def) return;
  if(activeBoss){ addChatMessage('','// A BOSS IS ALREADY ACTIVE //',false,true); closeBossScreen(); return; }
  if(playerLevel < def.lvCost){ addChatMessage('','// INSUFFICIENT LEVEL //',false,true); return; }
  if(coins < def.coinCost){ addChatMessage('','// INSUFFICIENT COINS //',false,true); return; }

  // ‚îÄ‚îÄ Server-side economy validation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const _res = await callEdgeFn('validate-action', {
    action: 'boss_fight', username: accountUsername, bossId: defId, coinCost: def.coinCost
  });
  if(!_res || !_res.success){
    if(_res && typeof _res.coins === 'number') coins = _res.coins;
    updateHUD(); return;
  }
  coins = _res.coins;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // Spend levels by reducing XP to the threshold of (currentLevel - lvCost)
  const targetLevel = Math.max(0, playerLevel - def.lvCost);
  playerXP = levelToXP(targetLevel);
  playerLevel = targetLevel;
  // coins already deducted server-side above
  updateHUD(); updateXPHUD();
  spawnBoss(def);
  closeBossScreen();
  // Teleport player near arena
  camera.position.set(BOSS_ARENA_X, GROUND_Y, BOSS_ARENA_Z + 8);
}

// ‚îÄ‚îÄ Boss NPC model ‚Äî armoured soldier look ‚îÄ‚îÄ
function makeBossNPCModel(){
  const mat = {
    armor: new THREE.MeshLambertMaterial({color:0x223344}), // dark steel blue
    skin:  new THREE.MeshLambertMaterial({color:0xc08060}),
    badge: new THREE.MeshLambertMaterial({color:0xdd9900}),
    eye:   new THREE.MeshBasicMaterial({color:0x00ccff}),
  };
  const g = new THREE.Group();
  const add=(geo,m,x,y,z,rx=0,ry=0,rz=0)=>{
    const mesh=new THREE.Mesh(geo,m); mesh.position.set(x,y,z); mesh.rotation.set(rx,ry,rz); g.add(mesh);
  };
  add(_ncpG.head,  mat.skin,  0,0.78,0);
  add(new THREE.BoxGeometry(0.44,0.20,0.44),mat.armor,0,0.96,0); // helmet
  add(new THREE.BoxGeometry(0.48,0.06,0.48),mat.armor,0,0.87,0); // helmet brim
  const eyeG=new THREE.BoxGeometry(0.07,0.055,0.04);
  for(const ex of[-0.09,0.09]){const em=new THREE.Mesh(eyeG,mat.eye);em.position.set(ex,0.79,0.18);g.add(em);}
  add(new THREE.BoxGeometry(0.60,0.65,0.32),mat.armor,0,0.40,0); // chest plate
  add(new THREE.BoxGeometry(0.12,0.38,0.34),mat.badge,0,0.42,0); // badge stripe
  add(_ncpG.hips,  mat.armor, 0,0.03,0);
  add(_ncpG.uArm,  mat.armor,-0.40,0.38,0,-0.3,0,0.15);
  add(_ncpG.lArm,  mat.skin, -0.38,-0.04,-0.1);
  add(_ncpG.uArm,  mat.armor, 0.40,0.38,0,-0.3,0,-0.15);
  add(_ncpG.lArm,  mat.skin,  0.38,-0.04,-0.1);
  for(const sx of[-1,1]){
    add(_ncpG.uLeg,mat.armor,sx*0.12,-0.35,0);
    add(_ncpG.lLeg,mat.armor,sx*0.12,-0.74,0);
    add(_ncpG.foot,mat.armor,sx*0.12,-0.99,0.05);
  }
  return g;
}

function buildBossNPC(){
  bossNPCMesh = makeBossNPCModel();
  bossNPCMesh.position.set(BOSS_NPC_X, 0.10, BOSS_NPC_Z);
  bossNPCMesh.rotation.y = Math.PI - 0.4;
  bossNPCMesh.userData.bobT = 0;
  scene.add(bossNPCMesh);
  const label = makeNameSprite('BOSS HANDLER');
  label.position.set(BOSS_NPC_X, 2.4, BOSS_NPC_Z);
  scene.add(label);
}

function updateBossNPC(){
  if(!bossNPCMesh) return;
  const dx=camera.position.x-BOSS_NPC_X, dz=camera.position.z-BOSS_NPC_Z;
  const near = dx*dx+dz*dz < SHOP_INTERACT_DIST*SHOP_INTERACT_DIST;
  if(near !== bossNPCInteractable){
    bossNPCInteractable = near;
    if(near && !merchantInteractable && !rebirthNPCInteractable){
      _promptEl.textContent='[ E ] BOSS ARENA'; _promptEl.style.display='block';
      _promptEl.style.borderColor='rgba(0,150,255,0.6)'; _promptEl.style.color='#00aaff';
    } else if(!merchantInteractable && !rebirthNPCInteractable){
      _promptEl.style.display='none';
      _promptEl.textContent='[ E ] TRADE';
      _promptEl.style.borderColor='rgba(255,215,0,0.6)'; _promptEl.style.color='#ffd700';
    }
  }
  bossNPCMesh.userData.bobT += 0.025;
  bossNPCMesh.position.y = 0.10 + Math.sin(bossNPCMesh.userData.bobT)*0.007;
}

function openBossScreen(){
  if(dead||!bossNPCInteractable) return;
  const grid=document.getElementById('boss-fight-grid');
  grid.innerHTML='';
  BOSS_DEFS.forEach(def=>{
    const canLv = playerLevel >= def.lvCost;
    const canCo = coins >= def.coinCost;
    const canFight = canLv && canCo && !activeBoss;
    const div=document.createElement('div');
    div.className='boss-item'+(canFight?'':' cant-afford');
    const specialTag = def.special ? ` <span style="color:#ffaa00;font-size:9px">‚ú¶ ${
      def.special==='minions'?'SUMMONS':def.special==='rage'?'ENRAGES':def.special==='slam'?'GROUND SLAM':
      def.special==='blink'?'TELEPORTS':def.special==='ranged'?'FIREBALLS':def.special==='all'?'ALL ABILITIES':''
    }</span>` : '';
    div.innerHTML=`<div class="boss-item-name">${def.emoji||'‚ò†'} ${def.name}${specialTag}</div>
<div class="boss-item-stats">HP: ${def.hp.toLocaleString()} | DMG: ${def.dmg}/hit | SPD: ${(def.speed*1000).toFixed(0)}</div>
<div class="boss-item-cost">‚¨° ${def.coinCost.toLocaleString()} COINS &nbsp;+&nbsp; ${def.lvCost} LEVELS</div>
<div class="boss-item-reward">Reward: ${def.coinReward.toLocaleString()} ‚¨° &nbsp;+&nbsp; ${def.xpReward.toLocaleString()} XP</div>`;
    div.onclick=()=>{ if(canFight) startBossFight(def.id); };
    grid.appendChild(div);
  });
  document.getElementById('boss-player-info').textContent =
    'LVL '+playerLevel+' ‚Äî '+playerXP+' XP | ‚¨° '+coins+' COINS'+(activeBoss?' [BOSS ACTIVE]':'');
  document.exitPointerLock();
  document.getElementById('boss-screen').classList.add('active');
}
function closeBossScreen(){
  document.getElementById('boss-screen').classList.remove('active');
}

function buildShopNPC(){
  merchantMesh = makeMerchantModel();
  // Stand behind counter, facing south (toward door, toward player)
  merchantMesh.position.set(SHOP_X, 0.10, SHOP_Z + SHOP_D/2 - 1.8);
  merchantMesh.rotation.y = Math.PI; // face toward door
  scene.add(merchantMesh);

  // Name sprite above head
  const label = makeNameSprite('UPGRADES');
  label.position.set(SHOP_X, 2.2, SHOP_Z + SHOP_D/2 - 1.8);
  scene.add(label);

  // Subtle idle: stored on mesh for animate
  merchantMesh.userData.bobT = 0;
  buildRebirthNPC();
  buildBossNPC();
  buildBountyHandlerNPC();
  buildCarDealerNPC();
  buildWeaponsmithNPC();
}


function updateShopBearing(){
  const el=document.getElementById('shop-bearing'); if(!el) return;
  // Update zone indicator
  const zoneEl=document.getElementById('zone-indicator');
  const inZombieZone = camera.position.z > 2;
  const inArenaZone = _inArena(camera.position.x, camera.position.z);
  if(zoneEl){
    if(inArenaZone){ zoneEl.textContent='‚öî ARENA'; zoneEl.style.color='#ff4444'; zoneEl.style.textShadow='0 0 8px #ff4444'; }
    else if(inZombieZone){ zoneEl.textContent='‚ò£ DANGER'; zoneEl.style.color='#f44'; zoneEl.style.textShadow='0 0 8px #f44'; }
    else{ zoneEl.textContent='‚úì SAFE'; zoneEl.style.color='#0f0'; zoneEl.style.textShadow='0 0 8px #0f0'; }
  }
  // Update tier indicator
  const tierEl=document.getElementById('tier-indicator');
  if(tierEl && inZombieZone){
    const t=getZombieTier(Math.max(5,camera.position.z));
    const tierColors=['#88ff44','#ffcc00','#ff8800','#ff3300','#ff00ff'];
    const ti=ZOMBIE_TIERS.indexOf(t);
    tierEl.textContent='T'+(ti+1)+' ‚Äî '+t.name;
    tierEl.style.color=tierColors[ti]||'#fff';
    tierEl.style.textShadow='0 0 8px '+tierColors[ti];
  } else if(tierEl){ tierEl.textContent='‚Äî'; tierEl.style.color='#0f0'; tierEl.style.textShadow='none'; }
  // Rebirth buffs HUD
  const rbHud=document.getElementById('rebirth-hud');
  if(rbHud){
    const active=REBIRTH_BUFFS.filter(b=>(rebirthBuffs[b.id]||0)>0);
    if(active.length){ rbHud.style.display='block'; rbHud.innerHTML='BUFFS: '+active.map(b=>b.icon+'√ó'+(rebirthBuffs[b.id])).join(' '); }
    else rbHud.style.display='none';
  }
  const dx=SHOP_X-camera.position.x, dz=SHOP_Z-camera.position.z;
  const dist=Math.round(Math.sqrt(dx*dx+dz*dz));
  // World angle to shop relative to player facing (yaw)
  const worldAngle=Math.atan2(dx,dz); // angle in world space (Z+ forward)
  const relAngle=worldAngle-yaw;      // relative to camera heading
  // Pick arrow glyph
  const dirs=['‚Üë','‚Üó','‚Üí','‚Üò','‚Üì','‚Üô','‚Üê','‚Üñ'];
  const idx=Math.round(((relAngle%(Math.PI*2)+(Math.PI*2))%(Math.PI*2))/(Math.PI/4))%8;
  el.textContent=dist+'m '+dirs[idx];
}

function updateMerchantProximity(){
  if(!merchantMesh) return;
  updateRebirthNPC();
  updateBossNPC();
  updateBountyHandlerNPC();
  updateCarDealerNPC();
  updateParkedCarProximity();
  updateWeaponsmithNPC();
  const dx=camera.position.x-merchantMesh.position.x;
  const dz=camera.position.z-merchantMesh.position.z;
  const nearNPC = dx*dx+dz*dz < SHOP_INTERACT_DIST*SHOP_INTERACT_DIST;
  if(nearNPC !== merchantInteractable){ merchantInteractable = nearNPC; }
  if(merchantInteractable && !carDealerInteractable && !inCar){
    _promptEl.textContent='[ E ] UPGRADES'; _promptEl.style.display='block';
  } else if(weaponsmithInteractable && !carDealerInteractable && !inCar){
    _promptEl.textContent='[ E ] WEAPONSMITH'; _promptEl.style.display='block';
  } else if(!merchantInteractable && !weaponsmithInteractable && !carDealerInteractable && !inCar){
    _promptEl.style.display='none';
  }
  // Subtle breathing bob
  merchantMesh.userData.bobT += 0.02;
  merchantMesh.position.y = 0.10 + Math.sin(merchantMesh.userData.bobT)*0.008;
}

// ============================================================================
//  WORLD LAYOUT ‚Äî TWO DISTRICTS
//  SAFE ZONE: Z < 0  (north)  ‚Äî civilian buildings, shop, no zombies
//  ZOMBIE ZONE: Z > 0 (south) ‚Äî ruins, dense buildings, zombie spawns
//  Border wall at Z=0
// ============================================================================

// ‚îÄ‚îÄ SAFE ZONE buildings (Z < 0) ‚îÄ‚îÄ
addBuilding(-18, -12,  7,  8, 3);   // apartment block
addBuilding( 14, -16,  6,  7, 2);   // barracks
addBuilding(-8,  -28,  8,  6, 2);   // warehouse
addBuilding( 28, -20,  5,  6, 3);   // watchtower district
addBuilding(-32, -18,  6,  5, 2);   // command post
addBuilding(  6, -48,  7,  9, 4);   // tall residential
addBuilding(-22, -50,  8, 10, 4);   // HQ block
addBuilding( 36, -44,  5,  5, 2);   // outpost east
addBuilding(-44, -36,  6,  7, 3);   // outpost west
addBuilding(  0, -70,  6,  6, 3);   // deep safe settlement
addBuilding( 24, -72,  5,  8, 2);
addBuilding(-28, -68,  7,  6, 2);
addBuilding( 52, -30,  4,  5, 2);
addBuilding(-54, -22,  5,  6, 3);

// ‚îÄ‚îÄ ZOMBIE ZONE buildings (Z > 0) ‚Äî more beat-up density ‚îÄ‚îÄ
addBuilding(  8,  16,  8, 10, 4);   // overrun city block
addBuilding(-14,  14,  6,  8, 3);
addBuilding( 28,  12,  5,  7, 2);
addBuilding(-26,  24,  7,  6, 3);
addBuilding( 14,  36,  5,  5, 5);   // tall zombie tower
addBuilding(-10,  44,  8,  9, 3);
addBuilding( 34,  38,  6,  6, 2);
addBuilding(-36,  42,  5,  7, 4);
addBuilding(  2,  64,  7,  8, 3);
addBuilding(-22,  60,  6,  5, 2);
addBuilding( 26,  62,  5,  6, 3);
addBuilding( 50,  18,  4,  6, 2);
addBuilding(-50,  28,  6,  5, 3);
addBuilding( 44,  54,  5,  5, 2);
addBuilding(-46,  58,  7,  6, 3);
addBuilding( 10,  90,  6,  8, 4);
addBuilding(-16,  86,  8,  6, 3);
addBuilding( 36,  88,  5,  7, 2);
addBuilding(-38,  82,  6,  5, 4);

// ‚îÄ‚îÄ Ruins ‚Äî mostly in zombie zone, a few in safe zone ‚îÄ‚îÄ
addRuin(-40, -8,  Math.PI/3);
addRuin( 50, -40, 0);
addRuin(-56, -50, Math.PI/4);
// Zombie zone ruins (dense)
addRuin( 20,  8,  Math.PI/4);
addRuin(-18,  10, Math.PI/6);
addRuin( 42,  24, 0);
addRuin(-42,  18, Math.PI/3);
addRuin(  0,  32, Math.PI/2);
addRuin( 22,  50, 0);
addRuin(-28,  52, Math.PI/5);
addRuin( 48,  70, Math.PI/4);
addRuin(-50,  72, 0);
addRuin( 12,  76, Math.PI/3);
addRuin(-14,  94, 0);
addRuin( 60,  40, Math.PI/6);
addRuin(-62,  48, Math.PI/4);
addRuin( 30,  100, 0);

// ‚îÄ‚îÄ Sandbags ‚Äî both zones ‚îÄ‚îÄ
// Safe zone defensive line near border
addSandbags(-30,  -4, 6, 0);
addSandbags(  0,  -4, 5, 0);
addSandbags( 30,  -4, 6, 0);
addSandbags(-50, -12, 4, Math.PI/4);
addSandbags( 48, -10, 4, Math.PI/3);
// Safe zone interior
addSandbags(-12, -20, 5, Math.PI/2);
addSandbags( 20, -32, 4, 0);
addSandbags(-40, -56, 5, Math.PI/6);
// Zombie zone
addSandbags( 16,  18, 5, Math.PI/6);
addSandbags(-20,  30, 4, 0);
addSandbags( 38,  16, 4, Math.PI/3);
addSandbags(  0,  54, 6, Math.PI/2);
addSandbags( 28,  78, 5, 0);
addSandbags(-30,  80, 4, Math.PI/4);


// ‚îÄ‚îÄ Extended safe zone (deeper north, wider east/west) ‚îÄ‚îÄ
addBuilding( 72, -30,  5,  6, 2);   // far east outpost
addBuilding(-74, -28,  6,  5, 3);   // far west outpost
addBuilding( 60, -60,  5,  7, 2);   // east residential
addBuilding(-62, -58,  6,  6, 3);   // west residential
addBuilding(  8, -100, 7, 10, 4);   // deep north HQ
addBuilding(-30, -100, 8,  8, 3);
addBuilding( 44, -100, 5,  6, 2);
addBuilding(-70, -80,  6,  7, 3);
addBuilding( 72, -85,  5,  5, 2);
addBuilding(  0, -130, 6,  8, 4);   // far north settlement
addBuilding( 40, -140, 5,  6, 2);
addBuilding(-42, -135, 7,  6, 3);
addBuilding( 90, -50,  5,  5, 2);   // extreme east
addBuilding(-92, -45,  6,  6, 2);   // extreme west
addBuilding( 90, -110, 4,  5, 2);
addBuilding(-88, -100, 5,  6, 3);

// ‚îÄ‚îÄ Extended safe zone (around racetrack area, north of colosseum) ‚îÄ‚îÄ
addBuilding( 100, -170, 5,  6, 2);  // east side of track area
addBuilding(-100, -165, 6,  5, 3);  // west side
addBuilding( 115, -220, 4,  5, 2);  // far east track side
addBuilding(-115, -215, 5,  6, 3);  // far west track side
addBuilding(  85, -290, 5,  7, 2);  // north-east settlement
addBuilding( -88, -285, 6,  6, 3);  // north-west settlement
addBuilding(   0, -300, 7,  9, 4);  // extreme north HQ
addBuilding(  40, -305, 5,  6, 2);
addBuilding( -44, -300, 6,  5, 2);
addBuilding( 115, -160, 4,  4, 2);  // grandstands area east
addBuilding(-115, -155, 5,  4, 2);  // grandstands area west

// ‚îÄ‚îÄ Extended zombie zone (deeper south, wider east/west) ‚îÄ‚îÄ
addBuilding( 72,  30,  5,  6, 3);
addBuilding(-74,  28,  6,  5, 2);
addBuilding( 60,  70,  5,  7, 3);
addBuilding(-62,  68,  6,  6, 2);
addBuilding( 16, 115,  7,  8, 4);
addBuilding(-20, 120,  6,  6, 3);
addBuilding( 50, 115,  5,  6, 2);
addBuilding(-54, 110,  7,  7, 3);
addBuilding(  0, 150,  8, 10, 5);   // deep south stronghold
addBuilding( 36, 155,  5,  7, 3);
addBuilding(-40, 148,  6,  6, 4);
addBuilding( 80,  60,  5,  5, 2);
addBuilding(-82,  55,  6,  6, 3);
addBuilding( 85,  95,  5,  6, 2);
addBuilding(-86,  90,  6,  5, 3);
addBuilding( 90, 140,  4,  5, 2);
addBuilding(-88, 135,  5,  6, 3);

// ‚îÄ‚îÄ Extra ruins in expanded areas ‚îÄ‚îÄ
addRuin( 78, -60, Math.PI/4);
addRuin(-80, -55, 0);
addRuin( 70, -120, Math.PI/3);
addRuin(-72, -115, Math.PI/6);
addRuin( 95, -80, 0);
addRuin(-96, -75, Math.PI/4);
addRuin( 78,  65, 0);
addRuin(-80,  58, Math.PI/3);
addRuin( 68, 100, Math.PI/4);
addRuin(-70,  96, 0);
addRuin( 55, 135, Math.PI/5);
addRuin(-56, 130, Math.PI/3);
addRuin( 90, 115, 0);
addRuin(-92, 110, Math.PI/4);

// ‚îÄ‚îÄ Extra sandbags in expanded areas ‚îÄ‚îÄ
addSandbags( 65, -40, 5, Math.PI/4);
addSandbags(-66, -38, 4, Math.PI/3);
addSandbags( 80, -90, 5, 0);
addSandbags(-82, -85, 4, Math.PI/6);
addSandbags( 20,-115, 5, Math.PI/2);
addSandbags(-22,-118, 4, 0);
addSandbags( 65,  45, 5, 0);
addSandbags(-66,  42, 4, Math.PI/4);
addSandbags( 60, 130, 5, Math.PI/3);
addSandbags(-62, 125, 4, 0);

// ‚îÄ‚îÄ Deep zone content ‚Äî obstacles gradually thin out ‚îÄ‚îÄ

// Tier 2 sparse buildings (Z 160‚Äì220): isolated outposts
addBuilding(  4, 170,  5,  6, 2);
addBuilding(-30, 178,  6,  5, 2);
addBuilding( 48, 165,  4,  5, 2);
addBuilding(-58, 172,  5,  5, 2);
addBuilding( 22, 200,  5,  6, 2);
addBuilding(-18, 208,  4,  5, 2);
addBuilding( 70, 185,  4,  4, 2);
addBuilding(-72, 190,  5,  4, 2);
addBuilding(  0, 218,  6,  7, 3);
addBuilding( 40, 215,  4,  5, 2);
addBuilding(-44, 212,  5,  5, 2);

// Tier 3 very sparse buildings (Z 230‚Äì280): half-dozen isolated structures
addBuilding( 14, 242,  5,  6, 2);
addBuilding(-20, 255,  4,  5, 2);
addBuilding( 55, 238,  4,  4, 2);
addBuilding(-60, 248,  5,  4, 2);
addBuilding(  0, 268,  5,  6, 2);
addBuilding( 38, 272,  4,  5, 2);

// Ruins trailing from Z~155 to Z~310
addRuin( 18, 175, Math.PI/5);
addRuin(-24, 185, 0);
addRuin( 50, 195, Math.PI/3);
addRuin(-52, 210, Math.PI/6);
addRuin(  8, 225, Math.PI/4);
addRuin(-10, 220, 0);
addRuin( 35, 235, Math.PI/2);
addRuin( 62, 245, Math.PI/3);
addRuin(-64, 252, 0);
addRuin( 20, 268, Math.PI/4);
addRuin(-22, 275, Math.PI/6);
addRuin(  5, 290, 0);
addRuin( 45, 298, Math.PI/5);
addRuin(-48, 305, Math.PI/3);
addRuin( 15, 310, Math.PI/2);

// Sandbags trailing from Z~160 to Z~285
addSandbags( 22, 170, 4, Math.PI/4);
addSandbags(-26, 178, 4, 0);
addSandbags( 58, 190, 3, Math.PI/3);
addSandbags(-60, 198, 3, 0);
addSandbags( 28, 215, 4, Math.PI/6);
addSandbags(-32, 222, 3, Math.PI/4);
addSandbags(  8, 240, 4, 0);
addSandbags( 50, 250, 3, Math.PI/3);
addSandbags(-52, 258, 3, 0);
addSandbags( 18, 270, 4, Math.PI/2);
addSandbags(-20, 278, 3, Math.PI/4);
addSandbags(  0, 285, 3, 0);

// Z>310: completely open plains ‚Äî no obstacles

// ============================================================================
//  GUN RANGE
// ============================================================================
const GR_X=30, GR_Z=-60;   // centre of range
const GR_W=18, GR_D=22;    // width √ó depth (Z runs north)
const GR_TARGET_Z=GR_Z-GR_D/2+1.5; // target line at back wall
const GR_FIRE_Z=GR_Z+GR_D/2-2;     // firing line at front

const _grMat   = new THREE.MeshLambertMaterial({color:0x8B7355}); // wood/planks
const _grMat2  = new THREE.MeshLambertMaterial({color:0x4a3828}); // dark wood post
const _grSign  = new THREE.MeshLambertMaterial({color:0x223322});
const _grSignT = new THREE.MeshBasicMaterial({color:0x88ff44});
const _grWall  = new THREE.MeshLambertMaterial({color:0x999988}); // concrete side walls
const _grLaneMat=new THREE.MeshLambertMaterial({color:0xd4b896});

// ‚îÄ‚îÄ Floor lane ‚îÄ‚îÄ
{
  const g=new THREE.BoxGeometry(GR_W,0.08,GR_D); g.translate(GR_X,0.04,GR_Z);
  scene.add(new THREE.Mesh(g,_grLaneMat));
}
// ‚îÄ‚îÄ Back wall (target wall) ‚îÄ‚îÄ
{
  const g=new THREE.BoxGeometry(GR_W,3.0,0.4); g.translate(GR_X,1.5,GR_TARGET_Z-0.6);
  scene.add(new THREE.Mesh(g,_grWall));
  colliders.push({type:'box',x:GR_X,z:GR_TARGET_Z-0.6,hw:GR_W/2,hd:0.4});
}
// ‚îÄ‚îÄ Side walls ‚îÄ‚îÄ
for(const sx of[-1,1]){
  const g=new THREE.BoxGeometry(0.35,2.5,GR_D); g.translate(GR_X+sx*GR_W/2,1.25,GR_Z);
  scene.add(new THREE.Mesh(g,_grWall));
  colliders.push({type:'box',x:GR_X+sx*GR_W/2,z:GR_Z,hw:0.35,hd:GR_D/2});
}
// ‚îÄ‚îÄ Lane divider lines (visual boards on floor) ‚îÄ‚îÄ
for(let li=-2;li<=2;li++){
  const lx=GR_X+li*3.2;
  const g=new THREE.BoxGeometry(0.08,0.06,GR_D-1); g.translate(lx,0.09,GR_Z);
  scene.add(new THREE.Mesh(g,_grMat2));
}
// ‚îÄ‚îÄ Firing line barrier (low sandbag-height wall at front) ‚îÄ‚îÄ
{
  const g=new THREE.BoxGeometry(GR_W,0.55,0.3); g.translate(GR_X,0.28,GR_FIRE_Z);
  scene.add(new THREE.Mesh(g,_grMat));
}
// ‚îÄ‚îÄ Range sign ‚îÄ‚îÄ
{
  const g=new THREE.BoxGeometry(5,0.7,0.12); g.translate(GR_X,2.8,GR_Z+GR_D/2-0.1);
  scene.add(new THREE.Mesh(g,_grSign));
  const gt=new THREE.BoxGeometry(4.8,0.5,0.14); gt.translate(GR_X,2.8,GR_Z+GR_D/2-0.04);
  scene.add(new THREE.Mesh(gt,_grSignT));
  // Text sprite
  const sc=document.createElement('canvas'); sc.width=256; sc.height=48;
  const sctx=sc.getContext('2d');
  sctx.fillStyle='rgba(0,0,0,0)'; sctx.fillRect(0,0,256,48);
  sctx.font='bold 18px monospace'; sctx.fillStyle='#000'; sctx.textAlign='center';
  sctx.fillText('‚¨° GUN RANGE ‚¨°',128,30);
  const stx=new THREE.CanvasTexture(sc);
  const ssp=new THREE.Sprite(new THREE.SpriteMaterial({map:stx,depthTest:false}));
  ssp.scale.set(3.5,0.65,1); ssp.position.set(GR_X,2.82,GR_Z+GR_D/2+0.1);
  scene.add(ssp);
}

// ‚îÄ‚îÄ Dummy targets ‚îÄ‚îÄ
const DUMMY_HP=300;
const dummies=[]; // { mesh, hpBar, hp, postX, resetTimer }

const _dummyMats={
  body:  new THREE.MeshLambertMaterial({color:0xd4a882}),
  head:  new THREE.MeshLambertMaterial({color:0xd4a882}),
  shirt: new THREE.MeshLambertMaterial({color:0x8B0000}), // dark red ‚Äî distinct
  hit:   new THREE.MeshLambertMaterial({color:0xff6600}), // flash orange on hit
};

function makeDummyModel(){
  const g=new THREE.Group();
  const add=(geo,mat,x,y,z)=>{const m=new THREE.Mesh(geo,mat);m.position.set(x,y,z);g.add(m);return m;};
  add(new THREE.BoxGeometry(0.38,0.34,0.38),_dummyMats.head, 0,1.72,0);
  add(new THREE.BoxGeometry(0.52,0.58,0.26),_dummyMats.shirt,0,1.26,0);
  add(new THREE.BoxGeometry(0.46,0.24,0.24),_dummyMats.shirt,0,0.94,0);
  for(const sx of[-1,1]){
    add(new THREE.BoxGeometry(0.18,0.44,0.18),_dummyMats.body,sx*0.38,1.26,0);
    add(new THREE.BoxGeometry(0.20,0.48,0.20),_dummyMats.shirt,sx*0.12,0.56,0);
    add(new THREE.BoxGeometry(0.18,0.44,0.18),_dummyMats.body,sx*0.12,0.10,0);
  }
  return g;
}

function spawnDummy(px, pz){
  // Post
  const postG=new THREE.BoxGeometry(0.12,1.1,0.12); postG.translate(px,0.55,pz);
  scene.add(new THREE.Mesh(postG,_grMat2));
  // Model
  const mesh=makeDummyModel();
  mesh.position.set(px,0.9,pz);
  mesh.rotation.y=Math.PI; // face the player (south)
  scene.add(mesh);
  // HP bar
  const hpBar=makeHPSprite();
  hpBar.position.set(px,2.5,pz);
  scene.add(hpBar);
  drawHPBar(hpBar,DUMMY_HP,DUMMY_HP);
  dummies.push({mesh,hpBar,hp:DUMMY_HP,postX:px,postZ:pz,resetTimer:0,alive:true});
}

// Place 5 dummies across the range
const _dxPositions=[-6,-3,0,3,6];
_dxPositions.forEach(dx=>spawnDummy(GR_X+dx, GR_TARGET_Z));

// Dummy flash state
const _dummyFlash=new WeakMap();

function updateDummies(){
  for(const d of dummies){
    // Flash off
    if(_dummyFlash.get(d)>0){
      _dummyFlash.set(d,_dummyFlash.get(d)-1);
      if(_dummyFlash.get(d)===0){
        // Restore original colours
        d.mesh.children.forEach((c,i)=>{
          c.material=i<=2?_dummyMats.shirt:(i<3?_dummyMats.head:_dummyMats.body);
        });
        d.mesh.children[0].material=_dummyMats.head;
        d.mesh.children[1].material=_dummyMats.shirt;
        d.mesh.children[2].material=_dummyMats.shirt;
        for(let ci=3;ci<d.mesh.children.length;ci++) d.mesh.children[ci].material=_dummyMats.body;
      }
    }
    // Auto-reset 3 seconds after death
    if(!d.alive){
      d.resetTimer--;
      if(d.resetTimer<=0){
        d.hp=DUMMY_HP; d.alive=true;
        d.mesh.visible=true; d.hpBar.visible=true;
        drawHPBar(d.hpBar,DUMMY_HP,DUMMY_HP);
      }
    }
  }
}

function hitDummy(d, dmg){
  d.hp=Math.max(0,d.hp-dmg);
  drawHPBar(d.hpBar,d.hp,DUMMY_HP);
  showFloatPop('-'+dmg,'#ff8844');
  showHitMarker();
  // Flash orange
  d.mesh.children.forEach(c=>{ c.material=_dummyMats.hit; });
  _dummyFlash.set(d,5);
  if(d.hp<=0 && d.alive){
    d.alive=false;
    d.resetTimer=180; // 3 seconds
    d.mesh.visible=false; d.hpBar.visible=false;
    showFloatPop('TARGET DOWN','#ff4400');
  }
}

// ============================================================================
//  BATTLE ARENA
// ============================================================================
const ARENA_X=0, ARENA_Z=-135;
const ARENA_OW=70, ARENA_OD=54;   // outer wall footprint
const ARENA_IW=50, ARENA_ID=36;   // inner sand floor
const ARENA_WH=9.0;               // outer wall height
const ARENA_GATE=7.0;             // gate width (south)
const ARENA_WT=2.0;               // outer wall thickness

function _inArena(x,z){
  return Math.abs(x-ARENA_X)<ARENA_OW/2 && z>ARENA_Z-ARENA_OD/2 && z<ARENA_Z+ARENA_OD/2;
}

(function buildArena(){
  const cx=ARENA_X, cz=ARENA_Z;
  const ohw=ARENA_OW/2, ohd=ARENA_OD/2;   // 35, 27
  const ihw=ARENA_IW/2, ihd=ARENA_ID/2;   // 25, 18
  const wh=ARENA_WH, wt=ARENA_WT, gate=ARENA_GATE;

  const mTravert=new THREE.MeshLambertMaterial({color:0xd4c4a0});
  const mInner  =new THREE.MeshLambertMaterial({color:0xb8a880});
  const mSand   =new THREE.MeshLambertMaterial({color:0xc8b060});
  const mSeat   =new THREE.MeshLambertMaterial({color:0xa89060});
  const mAccent =new THREE.MeshLambertMaterial({color:0x885522});
  const mPillar =new THREE.MeshLambertMaterial({color:0x998866});
  const mGate   =new THREE.MeshLambertMaterial({color:0x443322});

  function box(x,y,z,w,h,d,mat){
    const g=new THREE.BoxGeometry(w,h,d); g.translate(x,y+h/2,z);
    scene.add(new THREE.Mesh(g,mat||mTravert));
  }
  function wc(x,z,hw,hd){ colliders.push({type:'box',x,z,hw,hd}); }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // OUTER WALLS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const sw=(ARENA_OW-gate)/2;
  // South ‚Äî two halves with gate gap
  box(cx-(gate/2+sw/2),0,cz+ohd,sw,wh,wt,mTravert);
  box(cx+(gate/2+sw/2),0,cz+ohd,sw,wh,wt,mTravert);
  wc(cx-(gate/2+sw/2),cz+ohd,sw/2,wt/2);
  wc(cx+(gate/2+sw/2),cz+ohd,sw/2,wt/2);
  // North
  box(cx,0,cz-ohd,ARENA_OW,wh,wt,mTravert);
  wc(cx,cz-ohd,ohw,wt/2);
  // East
  box(cx+ohw,0,cz,wt,wh,ARENA_OD,mTravert);
  wc(cx+ohw,cz,wt/2,ohd);
  // West
  box(cx-ohw,0,cz,wt,wh,ARENA_OD,mTravert);
  wc(cx-ohw,cz,wt/2,ohd);

  // ‚îÄ‚îÄ Gate columns + arch ‚îÄ‚îÄ
  for(const sx of[-1,1]){
    box(cx+sx*(gate/2+0.5),0,cz+ohd,1.4,wh+2.2,wt+1.0,mPillar);
    box(cx+sx*(gate/2+0.5),wh+2.2,cz+ohd,1.8,0.5,wt+1.4,mAccent);
  }
  box(cx,wh+0.9,cz+ohd,gate+1.2,1.8,wt+0.8,mInner);  // lintel

  // ‚îÄ‚îÄ Pilasters on outer faces ‚îÄ‚îÄ
  // South RIGHT side only (x > gate/2+2) to avoid LB area on left
  for(let px=gate/2+5; px<ohw-3; px+=7){
    box(cx+px,0,cz+ohd+0.12,0.7,wh+0.2,0.55,mPillar);
  }
  // South LEFT: only far-left section (x < -25), LBs occupy -8 to -24
  for(let px=27; px<ohw-2; px+=7){
    box(cx-px,0,cz+ohd+0.12,0.7,wh+0.2,0.55,mPillar);
  }
  // North
  for(let px=-ohw+4; px<=ohw-4; px+=8){
    box(cx+px,0,cz-ohd-0.12,0.7,wh+0.2,0.55,mPillar);
  }
  // East + West
  for(let pz=-ohd+4; pz<=ohd-4; pz+=8){
    box(cx+ohw+0.12,0,cz+pz,0.55,wh+0.2,0.7,mPillar);
    box(cx-ohw-0.12,0,cz+pz,0.55,wh+0.2,0.7,mPillar);
  }

  // ‚îÄ‚îÄ String courses (decorative bands) ‚Äî skip LB zone on south left ‚îÄ‚îÄ
  for(const bh of[wh*0.33,wh*0.66]){
    // South RIGHT (x > gate/2)
    box(cx+(gate/2+sw/2),bh,cz+ohd,sw,0.28,wt+0.2,mAccent);
    // South FAR LEFT only (x < -24)
    const flW=ohw-24;
    if(flW>0) box(cx-(ohw-flW/2),bh,cz+ohd,flW,0.28,wt+0.2,mAccent);
    // North + East + West full
    box(cx,bh,cz-ohd,ARENA_OW,0.28,wt+0.2,mAccent);
    box(cx+ohw,bh,cz,wt+0.2,0.28,ARENA_OD,mAccent);
    box(cx-ohw,bh,cz,wt+0.2,0.28,ARENA_OD,mAccent);
  }

  // ‚îÄ‚îÄ Crenellations ‚îÄ‚îÄ
  const mW=1.8,mH=1.2,mGap=2.4;
  for(let px=-ohw+1; px<ohw; px+=mW+mGap){
    if(Math.abs(px)>gate/2+1) box(cx+px,wh,cz+ohd,mW,mH,wt+0.2,mTravert);
    box(cx+px,wh,cz-ohd,mW,mH,wt+0.2,mTravert);
  }
  for(let pz=-ohd+1; pz<ohd; pz+=mW+mGap){
    box(cx+ohw,wh,cz+pz,wt+0.2,mH,mW,mTravert);
    box(cx-ohw,wh,cz+pz,wt+0.2,mH,mW,mTravert);
  }

  // ‚îÄ‚îÄ Colosseum sign ‚îÄ‚îÄ
  {
    const sc=document.createElement('canvas'); sc.width=512; sc.height=80;
    const c2=sc.getContext('2d');
    c2.fillStyle='#1a0800'; c2.fillRect(0,0,512,80);
    c2.strokeStyle='#cc6622'; c2.lineWidth=4; c2.strokeRect(4,4,504,72);
    c2.font='bold 34px serif'; c2.fillStyle='#f0d080'; c2.textAlign='center';
    c2.fillText('\u2694  COLOSSEUM  \u2694',256,52);
    const tx=new THREE.CanvasTexture(sc);
    const sp=new THREE.Mesh(new THREE.PlaneGeometry(10,1.6),
      new THREE.MeshBasicMaterial({map:tx,depthTest:true,transparent:true}));
    sp.position.set(cx,wh+2.1,cz+ohd+wt/2+0.06);
    scene.add(sp);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ENTRANCE TUNNEL
  // The passage goes from south outer wall (cz+ohd) inward to the
  // podium wall (cz+ihd), gate-width wide.
  // tunnel depth = ohd - ihd = 9
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const tD=ohd-ihd; // 9
  // Tunnel floor
  box(cx,-0.06,cz+ihd+tD/2,gate+0.1,0.12,tD,mInner);
  // Tunnel side walls (fill area beside the passage)
  const tfW=(ARENA_IW-gate)/2;
  box(cx-(gate/2+tfW/2),0,cz+ihd+tD/2,tfW,2.5,tD,mInner);
  box(cx+(gate/2+tfW/2),0,cz+ihd+tD/2,tfW,2.5,tD,mInner);
  wc(cx-(gate/2+tfW/2),cz+ihd+tD/2,tfW/2,tD/2);
  wc(cx+(gate/2+tfW/2),cz+ihd+tD/2,tfW/2,tD/2);
  // Tunnel ceiling
  box(cx,wh*0.7,cz+ihd+tD/2,gate+0.1,0.3,tD,mInner);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // INNER PODIUM WALL (arena perimeter)
  // South: gap for tunnel entrance
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const pw=(ARENA_IW-gate)/2;
  box(cx-(gate/2+pw/2),0,cz+ihd,pw,2.5,0.6,mInner);
  box(cx+(gate/2+pw/2),0,cz+ihd,pw,2.5,0.6,mInner);
  wc(cx-(gate/2+pw/2),cz+ihd,pw/2,0.5);
  wc(cx+(gate/2+pw/2),cz+ihd,pw/2,0.5);
  box(cx,0,cz-ihd,ARENA_IW,2.5,0.6,mInner); wc(cx,cz-ihd,ihw,0.5);
  box(cx+ihw,0,cz,0.6,2.5,ARENA_ID,mInner); wc(cx+ihw,cz,0.5,ihd);
  box(cx-ihw,0,cz,0.6,2.5,ARENA_ID,mInner); wc(cx-ihw,cz,0.5,ihd);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // SEATING TIERS ‚Äî north, east, west only
  // 4 solid stepped rows rising outward.
  // Each row is a full-height-to-floor block so there are no gaps underneath.
  // floorPlatform added on top of each row so player can stand/jump on them.
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const rD=2.5, rH=1.8; // row depth and height-per-step
  // NORTH seating
  for(let r=0;r<4;r++){
    const rz=cz-ihd-(r+0.5)*rD;
    const h=(r+1)*rH;
    box(cx,0,rz,ARENA_IW,h,rD,mSeat);
    floorPlatforms.push({y:h,x1:cx-ARENA_IW/2,x2:cx+ARENA_IW/2,z1:rz-rD/2,z2:rz+rD/2});
  }
  wc(cx,cz-ihd-0.5,ihw,0.4); // block walking INTO north seats
  box(cx,0,cz-ihd-4*rD-0.3,ARENA_IW,4*rH,0.5,mInner); // back wall
  // EAST seating
  for(let r=0;r<4;r++){
    const rx=cx+ihw+(r+0.5)*rD;
    const h=(r+1)*rH;
    box(rx,0,cz,rD,h,ARENA_ID,mSeat);
    floorPlatforms.push({y:h,x1:rx-rD/2,x2:rx+rD/2,z1:cz-ARENA_ID/2,z2:cz+ARENA_ID/2});
  }
  wc(cx+ihw+0.5,cz,0.4,ihd);
  box(cx+ihw+4*rD+0.3,0,cz,0.5,4*rH,ARENA_ID,mInner);
  // WEST seating
  for(let r=0;r<4;r++){
    const rx=cx-ihw-(r+0.5)*rD;
    const h=(r+1)*rH;
    box(rx,0,cz,rD,h,ARENA_ID,mSeat);
    floorPlatforms.push({y:h,x1:rx-rD/2,x2:rx+rD/2,z1:cz-ARENA_ID/2,z2:cz+ARENA_ID/2});
  }
  wc(cx-ihw-0.5,cz,0.4,ihd);
  box(cx-ihw-4*rD-0.3,0,cz,0.5,4*rH,ARENA_ID,mInner);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ARENA SAND FLOOR
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  box(cx,-0.06,cz,ARENA_IW,0.12,ARENA_ID,mSand);
  box(cx,0.07,cz,ARENA_IW,0.04,0.28,mAccent);
  box(cx,0.07,cz,0.28,0.04,ARENA_ID,mAccent);

  // ‚îÄ‚îÄ Interior cover pillars ‚îÄ‚îÄ
  for(const [bx,bz] of[[-12,0],[12,0],[0,-10],[0,10]]){
    box(cx+bx,0,cz+bz,1.8,2.2,1.8,mInner);
    box(cx+bx,2.2,cz+bz,2.1,0.3,2.1,mAccent);
    wc(cx+bx,cz+bz,1.1,1.1);
  }
  for(const [bx,bz,bw,bd] of[[-6,0,10,0.5],[6,0,10,0.5],[0,-5,0.5,8],[0,5,0.5,8]]){
    box(cx+bx,0,cz+bz,bw,1.5,bd,mInner);
    wc(cx+bx,cz+bz,bw/2,bd/2+0.5);
  }
})();

// ‚îÄ‚îÄ Leaderboard boards ‚Äî all 3 on the LEFT of the gate (outside south wall) ‚îÄ‚îÄ
// depthTest:true Plane meshes so walls occlude them from inside
let _lbSprites = {};

function _makeLBBoard(label,accentColor){
  const c=document.createElement('canvas'); c.width=256; c.height=384;
  const ctx=c.getContext('2d');
  ctx.fillStyle='#080608'; ctx.fillRect(0,0,256,384);
  ctx.strokeStyle=accentColor; ctx.lineWidth=4; ctx.strokeRect(4,4,248,376);
  ctx.strokeStyle=accentColor+'55'; ctx.lineWidth=1; ctx.strokeRect(10,10,236,364);
  ctx.font='bold 14px monospace'; ctx.fillStyle=accentColor; ctx.textAlign='center';
  ctx.fillText(label,128,34);
  ctx.strokeStyle=accentColor; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(16,44); ctx.lineTo(240,44); ctx.stroke();
  const tx=new THREE.CanvasTexture(c);
  const mat=new THREE.MeshBasicMaterial({map:tx,depthTest:true,depthWrite:true,transparent:false,side:THREE.FrontSide});
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(3.4,5.0),mat);
  mesh.userData={canvas:c,ctx,tex:tx,label,accent:accentColor};
  scene.add(mesh);
  return mesh;
}

function _updateLBSprite(sp,rows){
  const {ctx,canvas:c,tex,label:lbl,accent}=sp.userData;
  ctx.fillStyle='#080608'; ctx.fillRect(0,0,256,384);
  ctx.strokeStyle=accent; ctx.lineWidth=4; ctx.strokeRect(4,4,248,376);
  ctx.strokeStyle=accent+'55'; ctx.lineWidth=1; ctx.strokeRect(10,10,236,364);
  ctx.font='bold 14px monospace'; ctx.fillStyle=accent; ctx.textAlign='center';
  ctx.fillText(lbl,128,34);
  ctx.strokeStyle=accent; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(16,44); ctx.lineTo(240,44); ctx.stroke();
  rows.forEach((row,i)=>{
    const y=70+i*58;
    ctx.fillStyle=i===0?accent:i===1?'#bbbbbb':i===2?'#cc8844':'#555566';
    ctx.fillRect(16,y-16,26,22);
    ctx.font='bold 11px monospace'; ctx.fillStyle='#000'; ctx.textAlign='center';
    ctx.fillText('#'+(i+1),29,y-1);
    ctx.font='bold 12px monospace'; ctx.fillStyle=i===0?accent:'#ccccdd'; ctx.textAlign='left';
    ctx.fillText(row.name.substring(0,11),48,y);
    ctx.font='11px monospace'; ctx.fillStyle='#aaaacc'; ctx.textAlign='right';
    ctx.fillText(row.val,240,y);
    if(i<4){ctx.strokeStyle='#181018';ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(16,y+10);ctx.lineTo(240,y+10);ctx.stroke();}
  });
  tex.needsUpdate=true;
}

(function placeLBBoards(){
  const cx=ARENA_X,cz=ARENA_Z,ohd=ARENA_OD/2,wt=ARENA_WT,gate=ARENA_GATE;
  // Outer south wall face ‚Äî boards left of gate at eye-level
  const faceZ=cz+ohd+wt/2+0.1;
  const boards=[
    {key:'coins', label:'\u2b21 TOP COINS',  color:'#ffd700', x:cx-(gate/2+4.5)},
    {key:'kills', label:'\u2620 TOP KILLS',  color:'#ff4444', x:cx-(gate/2+9.5)},
    {key:'deaths',label:'\ud83d\udca5 TOP DEATHS',color:'#aa44ff', x:cx-(gate/2+14.5)},
  ];
  boards.forEach(b=>{
    // Dark stone backing slab ‚Äî sits proud of wall face
    const bg=new THREE.BoxGeometry(3.6,5.2,0.18);
    bg.translate(b.x,3.0,faceZ+0.09);
    scene.add(new THREE.Mesh(bg,new THREE.MeshLambertMaterial({color:0x100808})));
    // Board face mesh
    const sp=_makeLBBoard(b.label,b.color);
    sp.position.set(b.x,3.0,faceZ+0.2);
    // PlaneGeometry faces +Z by default = south (outward) ‚Äî no rotation needed
    _lbSprites[b.key]=sp;
  });

  // ‚îÄ‚îÄ BOUNTY LEADERBOARD ‚Äî RIGHT side of gate ‚îÄ‚îÄ
  // Wider canvas (256√ó480) to fit more players; taller board in the world
  const bountyBoardX = cx + (gate/2 + 4.5);

  // Backing slab ‚Äî slightly taller than the others to signal importance
  const bgB = new THREE.BoxGeometry(3.6, 6.8, 0.18);
  bgB.translate(bountyBoardX, 3.8, faceZ + 0.09);
  scene.add(new THREE.Mesh(bgB, new THREE.MeshLambertMaterial({color:0x0a0800})));

  // Board canvas ‚Äî same _makeLBBoard helper, then we override with our wider one
  const bountyCanvas = document.createElement('canvas');
  bountyCanvas.width  = 256;
  bountyCanvas.height = 480;
  const bCtx = bountyCanvas.getContext('2d');
  // Initial blank draw
  bCtx.fillStyle = '#080608'; bCtx.fillRect(0,0,256,480);
  bCtx.strokeStyle = '#ff8800'; bCtx.lineWidth = 4; bCtx.strokeRect(4,4,248,472);
  bCtx.strokeStyle = '#ff880055'; bCtx.lineWidth = 1; bCtx.strokeRect(10,10,236,460);
  bCtx.font = 'bold 13px monospace'; bCtx.fillStyle = '#ff8800'; bCtx.textAlign = 'center';
  bCtx.fillText('\u2b21 BOUNTY BOARD', 128, 34);
  bCtx.strokeStyle = '#ff8800'; bCtx.lineWidth = 1;
  bCtx.beginPath(); bCtx.moveTo(16,44); bCtx.lineTo(240,44); bCtx.stroke();

  const bountyTex  = new THREE.CanvasTexture(bountyCanvas);
  const bountyMat  = new THREE.MeshBasicMaterial({map:bountyTex, depthTest:true, depthWrite:true, transparent:false, side:THREE.FrontSide});
  const bountyMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.6, 6.8), bountyMat);
  bountyMesh.position.set(bountyBoardX, 3.8, faceZ + 0.2);
  scene.add(bountyMesh);

  // Store references for updates
  _lbSprites.bounty = { canvas:bountyCanvas, ctx:bCtx, tex:bountyTex };
})();

async function refreshLeaderboards(){
  if(!db) return;
  try{
    const {data}=await db.from('accounts').select('soldier_name,coins,kills,deaths').neq('username','Admin56').order('coins',{ascending:false}).limit(20);
    if(!data||!data.length) return;
    // Coins board
    const byCoins=[...data].sort((a,b)=>b.coins-a.coins).slice(0,5)
      .map(r=>({name:r.soldier_name||'???',val:'‚¨°'+r.coins}));
    _updateLBSprite(_lbSprites.coins, byCoins);
    // Kills board
    const byKills=[...data].sort((a,b)=>b.kills-a.kills).slice(0,5)
      .map(r=>({name:r.soldier_name||'???',val:r.kills+' kills'}));
    _updateLBSprite(_lbSprites.kills, byKills);
    // Deaths board
    const byDeaths=[...data].sort((a,b)=>b.deaths-a.deaths).slice(0,5)
      .map(r=>({name:r.soldier_name||'???',val:r.deaths+' deaths'}));
    _updateLBSprite(_lbSprites.deaths, byDeaths);
  } catch(e){ console.warn('LB fetch failed',e); }
}

// Refresh bounty leaderboard from live `players` table ‚Äî shows every online soldier
async function refreshBountyLeaderboard(){
  if(!db || !_lbSprites.bounty) return;
  try{
    const cutoff = new Date(Date.now() - 10000).toISOString(); // active in last 10s
    const {data} = await db.from('players').select('name,bounty,level').gte('updated_at',cutoff).neq('name','ADMIN').order('bounty',{ascending:false}).limit(20);
    const {canvas, ctx, tex} = _lbSprites.bounty;
    const W=canvas.width, H=canvas.height;

    ctx.clearRect(0,0,W,H);

    // Background + border
    ctx.fillStyle='#080608'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#ff8800'; ctx.lineWidth=4; ctx.strokeRect(4,4,W-8,H-8);
    ctx.strokeStyle='#ff880044'; ctx.lineWidth=1; ctx.strokeRect(10,10,W-20,H-20);

    // Title
    ctx.font='bold 13px monospace'; ctx.fillStyle='#ff8800'; ctx.textAlign='center';
    ctx.fillText('\u2b21 BOUNTY BOARD', 128, 34);
    // Subtitle ‚Äî live player count
    const playerCount = data ? data.length : 0;
    ctx.font='10px monospace'; ctx.fillStyle='#886644';
    ctx.fillText('ONLINE: '+ playerCount +' SOLDIER'+(playerCount!==1?'S':''), 128, 50);
    ctx.strokeStyle='#ff8800'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(16,58); ctx.lineTo(W-16,58); ctx.stroke();

    if(!data || !data.length){
      ctx.font='11px monospace'; ctx.fillStyle='#554433'; ctx.textAlign='center';
      ctx.fillText('NO PLAYERS ONLINE', 128, 100);
      tex.needsUpdate=true;
      return;
    }

    // Row accent colours by rank
    const rankColors=['#ffd700','#cccccc','#cc8844','#ff8800','#ff6600',
                      '#ff4400','#ff2200','#ee1100','#dd0000','#cc0000'];

    // Show up to 8 players so all fit on the board
    const rows = data.slice(0,8);
    rows.forEach((r,i)=>{
      const rowY  = 72 + i * 50;
      const accent= rankColors[i] || '#883300';
      const bounty= r.bounty ?? 5;
      const name  = (r.name || '???').substring(0,10);
      const lvl   = r.level != null ? 'LVL'+r.level : '';

      // Rank badge
      ctx.fillStyle = accent;
      ctx.fillRect(14, rowY, 28, 22);
      ctx.font='bold 11px monospace'; ctx.fillStyle='#000'; ctx.textAlign='center';
      ctx.fillText('#'+(i+1), 28, rowY+15);

      // Name
      ctx.font='bold 12px monospace';
      ctx.fillStyle = i===0 ? accent : '#ddccbb';
      ctx.textAlign='left';
      ctx.fillText(name, 50, rowY+9);

      // Level (small, muted)
      if(lvl){
        ctx.font='9px monospace'; ctx.fillStyle='#886644';
        ctx.fillText(lvl, 50, rowY+22);
      }

      // Bounty value ‚Äî right-aligned, colour by size
      const bc = bounty < 50 ? '#88ff44' : bounty < 150 ? '#ff8800' : '#ff3344';
      ctx.font='bold 13px monospace'; ctx.fillStyle=bc; ctx.textAlign='right';
      ctx.fillText('\u2b21'+bounty, W-16, rowY+15);

      // Divider between rows
      if(i < rows.length-1){
        ctx.strokeStyle='#221810'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(14, rowY+28); ctx.lineTo(W-14, rowY+28); ctx.stroke();
      }
    });

    // Footer ‚Äî local player's own position
    if(myName && data.length){
      const myIdx = data.findIndex(r=>r.name===myName);
      if(myIdx >= 8){
        ctx.strokeStyle='#ff8800'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(14,H-38); ctx.lineTo(W-14,H-38); ctx.stroke();
        ctx.font='10px monospace'; ctx.fillStyle='#ff8800'; ctx.textAlign='center';
        ctx.fillText('YOU: #'+(myIdx+1)+' ‚Äî \u2b21'+calcBounty(), 128, H-20);
      }
    }

    tex.needsUpdate=true;
  } catch(e){ console.warn('Bounty LB fetch failed',e); }
}
// Refresh leaderboards every 30s and on game start
setTimeout(refreshLeaderboards, 4000);
setInterval(refreshLeaderboards, 30000);
// Bounty board refreshes more frequently ‚Äî live bounties change as players gear up
setTimeout(refreshBountyLeaderboard, 5000);
setInterval(refreshBountyLeaderboard, 8000);

addShopBuilding();

// ‚îÄ‚îÄ Border wall at Z=0 ‚Äî concrete barrier with gaps for crossing ‚îÄ‚îÄ
(function buildBorderWall(){
  const wallMat=new THREE.MeshLambertMaterial({color:0x888880});
  const warnMat=new THREE.MeshLambertMaterial({color:0xdd6600});
  const segments=[
    [-185,-60],[ -50,-20],[  10, 50],[  60,185]  // [x1,x2] with gaps at [-20,10] and [50,60]
  ];
  segments.forEach(([x1,x2])=>{
    const w=x2-x1, cx=(x1+x2)/2;
    const g=new THREE.BoxGeometry(w,2.4,0.5);
    g.translate(cx,1.2,0);
    scene.add(new THREE.Mesh(g,wallMat));
    colliders.push({type:'box',x:cx,z:0,hw:w/2,hd:0.5});
    // Warning stripe on top
    const s2=new THREE.BoxGeometry(w,0.15,0.55);
    s2.translate(cx,2.45,0);
    scene.add(new THREE.Mesh(s2,warnMat));
  });
  // Warning signs at gaps
  for(const sx of [-5,55]){
    const sg=new THREE.BoxGeometry(1.2,1.5,0.1);
    sg.translate(sx,2.2,0);
    scene.add(new THREE.Mesh(sg,warnMat));
  }
})();

// Trees across both districts
const treePositions=[
  // Safe zone perimeter + interior
  [-60,-60],[-56,-65],[-65,-55],[-60,-45],[-50,-58],
  [58,-58],[54,-63],[63,-52],[58,-42],[50,-60],
  [-30,-60],[-35,-65],[-25,-55],[-40,-50],
  [32,-62],[36,-68],[28,-56],[42,-52],
  [-60,-30],[-64,-22],[-55,-38],
  [62,-28],[66,-20],[57,-36],
  // Safe zone trees near border
  [-70,-8],[-75,-14],[70,-6],[75,-14],
  [-55,-3],[55,-3],[-44,0],[44,0],
  // Zombie zone dense trees
  [48,48],[44,52],[52,44],[46,40],[40,46],
  [-48,48],[-44,52],[-52,44],[-46,40],[-40,46],
  [20,70],[24,75],[16,78],[28,72],
  [-20,70],[-24,75],[-16,78],[-28,72],
  [58,80],[62,85],[55,90],
  [-58,80],[-62,85],[-55,90],
  [0,110],[8,115],[-8,115],[14,108],
  [38,105],[42,112],[-38,105],[-42,112],
  // Deep zombie zone
  [70,35],[74,42],[66,48],[72,55],
  [-70,35],[-74,42],[-66,48],[-72,55],
];
treePositions.forEach(([tx,tz])=>addTree(tx,tz, 0.8+rng()*0.5));
// Expanded perimeter trees
[
  [80,-70],[85,-80],[90,-65],[78,-95],[92,-100],
  [-80,-70],[-85,-80],[-90,-65],[-78,-95],[-92,-100],
  [80,-130],[86,-140],[75,-148],[-80,-130],[-86,-140],[-75,-148],
  [110,-40],[115,-55],[108,-70],[-110,-40],[-115,-55],[-108,-70],
  [80,80],[85,90],[90,75],[78,110],[92,120],
  [-80,80],[-85,90],[-90,75],[-78,110],[-92,120],
  [60,145],[70,158],[55,165],[-60,145],[-70,158],[-55,165],
  [100,50],[110,65],[105,80],[-100,50],[-110,65],[-105,80],
].forEach(([tx,tz])=>addTree(tx,tz, 0.9+rng()*0.5));
// Extended perimeter + deep zone flanking trees
[
  [90,230],[95,250],[88,270],[-90,230],[-95,250],[-88,270],
  [85,300],[92,320],[88,345],[-85,300],[-92,320],[-88,345],
  [70,365],[80,370],[-70,365],[-80,370],
  [50,375],[60,378],[-50,375],[-60,378],
].forEach(([tx,tz])=>addTree(tx,tz, 1.0+rng()*0.4));
for(let i=0;i<30;i++){
  const a=rng()*Math.PI*2, d=145+rng()*40;
  addTree(Math.cos(a)*d, Math.sin(a)*d, 0.9+rng()*0.7);
}
_buildTrees(); // materialise all trees as 4 InstancedMesh draw calls

// ============================================================================
//  HP BAR & NAME SPRITES
// ============================================================================
function makeHPSprite(){
  const c=document.createElement('canvas'); c.width=64; c.height=14;
  const tx=new THREE.CanvasTexture(c);
  const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:tx,depthTest:false}));
  sp.scale.set(1.4,0.28,1);
  sp.userData={canvas:c,ctx:c.getContext('2d'),tex:tx};
  return sp;
}
function drawHPBar(sp,cur,max){
  const {canvas:cv,ctx,tex}=sp.userData;
  const W=cv.width,H=cv.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='#1a0000'; ctx.fillRect(0,0,W,H);
  const pct=Math.max(0,cur/max);
  ctx.fillStyle=pct>0.5?`rgb(${Math.round((1-pct)*2*255)},200,0)`:`rgb(220,${Math.round(pct*2*180)},0)`;
  ctx.fillRect(1,1,Math.round((W-2)*pct),H-2);
  ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.strokeRect(.5,.5,W-1,H-1);
  tex.needsUpdate=true;
}
function makeNameSprite(label, bounty){
  const hasBounty = bounty != null && bounty > 0;
  const c=document.createElement('canvas'); c.width=200; c.height= hasBounty ? 52 : 34;
  const ctx=c.getContext('2d');
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,c.width,c.height);
  ctx.font='bold 14px monospace'; ctx.fillStyle='#ffff00'; ctx.textAlign='center';
  ctx.fillText(label, 100, 20);
  if(hasBounty){
    const bc = bounty < 50 ? '#88ff44' : bounty < 150 ? '#ff8800' : '#ff3344';
    ctx.font='bold 11px monospace'; ctx.fillStyle=bc;
    ctx.fillText('\u2b21 BOUNTY: '+bounty, 100, 40);
  }
  const tx=new THREE.CanvasTexture(c);
  const sp=new THREE.Sprite(new THREE.SpriteMaterial({map:tx,depthTest:false}));
  sp.scale.set(2.8, hasBounty ? 0.65 : 0.42, 1);
  sp.userData = { canvas:c, ctx, tex:tx, label, bounty:bounty||0 };
  return sp;
}

function updateNameSpriteData(sp, label, bounty){
  const hasBounty = bounty != null && bounty > 0;
  const c = sp.userData.canvas;
  const ctx = sp.userData.ctx;
  if(!c || !ctx) return;
  c.height = hasBounty ? 52 : 34;
  ctx.clearRect(0,0,c.width,c.height);
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,c.width,c.height);
  ctx.font='bold 14px monospace'; ctx.fillStyle='#ffff00'; ctx.textAlign='center';
  ctx.fillText(label, 100, 20);
  if(hasBounty){
    const bc = bounty < 50 ? '#88ff44' : bounty < 150 ? '#ff8800' : '#ff3344';
    ctx.font='bold 11px monospace'; ctx.fillStyle=bc;
    ctx.fillText('\u2b21 BOUNTY: '+bounty, 100, 40);
  }
  sp.userData.tex.needsUpdate = true;
  sp.userData.label  = label;
  sp.userData.bounty = bounty || 0;
  sp.scale.set(2.8, hasBounty ? 0.65 : 0.42, 1);
}


// ============================================================================
//  XP & LEVEL SYSTEM
// ============================================================================
let playerXP    = 0;
let playerLevel = 0;
const XP_PER_TIER = [25, 60, 130, 280, 600]; // index matches ZOMBIE_TIERS

function xpToLevel(xp){ return Math.floor(Math.sqrt(xp/50)); }
function levelToXP(lv){ return lv*lv*50; }

function addXP(amount){
  amount = Number(amount);
  if(!isFinite(amount) || amount <= 0) return;
  if(amount > _SEC_MAX_XP_CALL) amount = _SEC_MAX_XP_CALL;
  playerXP += amount;
  const newLevel = xpToLevel(playerXP);
  if(newLevel > playerLevel){
    playerLevel = newLevel;
    showFloatPop('LEVEL UP! ‚Üí '+playerLevel,'#00ffff');
    showCoinPop('LVL '+playerLevel);
  }
  updateXPHUD();
  const _ld=document.getElementById('lvl-display'); if(_ld) _ld.textContent=playerLevel;
}

function updateXPHUD(){
  const el=document.getElementById('xp-bar-fill');
  const lbl=document.getElementById('xp-label');
  if(!el||!lbl) return;
  const thisLvXP=levelToXP(playerLevel);
  const nextLvXP=levelToXP(playerLevel+1);
  const pct=Math.min(1,(playerXP-thisLvXP)/Math.max(1,nextLvXP-thisLvXP));
  el.style.width=(pct*100)+'%';
  lbl.textContent='LVL '+playerLevel+' ‚Äî '+(playerXP-thisLvXP)+'/'+(nextLvXP-thisLvXP)+' XP';
}

// ============================================================================
//  BOUNTY SYSTEM
// ============================================================================
// Calculates the local player's current bounty based on all their stats.
// A fresh player = 5 ‚¨°. Max-gear veteran with rebirths can reach 500+.
function calcBounty(){
  const rebirthBonus = rebirthCount * 50;
  const levelBonus   = playerLevel  * 3;
  const hpLevels     = Math.round(maxHpBonus / 25);
  const dmgLevels    = Math.round((damageMultiplier - 1.0) / 0.25);
  const totalMagLvl  = (magLevel.rifle||0)+(magLevel.shotgun||0)+(magLevel.laser||0)
                      +(magLevel.sniper||0)+(magLevel.grenade||0)+(magLevel.c4||0);
  return Math.max(5, 5 + rebirthBonus + levelBonus + hpLevels*5 + dmgLevels*5 + totalMagLvl*2);
}

function updateBountyHUD(){
  const el = document.getElementById('bounty-val');
  if(!el) return;
  const b = calcBounty();
  el.textContent = '‚¨° ' + b;
  // Colour scales from green ‚Üí orange ‚Üí red as bounty grows
  const colour = b < 50 ? '#88ff44' : b < 150 ? '#ff8800' : '#ff3344';
  el.style.color = colour;
  el.style.textShadow = '0 0 8px ' + colour;

  // Mini contract progress ‚Äî only visible after first contract claimed
  const cpl = document.getElementById('contract-progress-lbl');
  if(cpl){
    if(bountyContractTier === 0){
      cpl.style.display = 'none';
    } else {
      cpl.style.display = 'block';
      const def = getBountyTierDef(bountyContractTier);
      const ready = pvpBountiesClaimed >= def.kills;
      cpl.textContent = ready
        ? '‚òÖ CONTRACT '+(bountyContractTier+1)+' READY!'
        : 'CONTRACT '+(bountyContractTier+1)+': '+pvpBountiesClaimed+'/'+def.kills;
      cpl.style.color = ready ? '#ff8800' : '#664422';
    }
  }
}

// Show a dramatic on-screen bounty-claim notification
let _bnTimer = 0;
function showBountyNotify(amount, victimName){
  const el  = document.getElementById('bounty-notify');
  const amt = document.getElementById('bn-amount');
  if(!el || !amt) return;
  amt.textContent = '+' + amount + ' ‚¨°  (' + victimName + ')';
  el.style.display = 'block';
  el.style.opacity  = '1';
  _bnTimer = 220; // ~3.6 s at 60 fps
}

// Called each animate() frame to fade the notification
function tickBountyNotify(){
  if(_bnTimer <= 0) return;
  _bnTimer--;
  if(_bnTimer <= 60){
    // fade out last second
    const el = document.getElementById('bounty-notify');
    if(el){ el.style.opacity = (_bnTimer / 60).toFixed(2); }
  }
  if(_bnTimer === 0){
    const el = document.getElementById('bounty-notify');
    if(el){ el.style.display = 'none'; el.style.opacity = '1'; }
  }
}

// Award bounty to the killer
function claimBounty(amount, victimName){
  const earned = Math.round(amount * getRebirthMult('coinmul'));
  coins += earned;
  pvpBountiesClaimed++;          // track toward contracts
  checkBountyContractNotify();   // ping player if a tier just became claimable
  updateHUD();
  updateBountyHUD();
  showBountyNotify(earned, victimName);
  showFloatPop('‚¨° BOUNTY +' + earned, '#ffd700');
  // Chat kill-feed
  addChatMessage('', '// ‚ò† YOU CLAIMED ' + victimName + '\'S BOUNTY ‚Äî +' + earned + ' ‚¨° //', false, true);
  // Refresh bounty board ‚Äî rankings may have shifted
  setTimeout(refreshBountyLeaderboard, 2000);
}

// ============================================================================
//  BOUNTY HANDLER NPC + CONTRACT SYSTEM
// ============================================================================
let pvpBountiesClaimed  = 0;   // total PvP bounties collected (persistent)
let bountyContractTier  = 0;   // highest tier reward already claimed (persistent)
let bountyHandlerMesh   = null;
let bountyHandlerInteractable = false;

// Position ‚Äî right next to the bounty board, outside the Colosseum south wall
const BH_X = ARENA_X + ARENA_GATE/2 + 9.5;
const BH_Z = ARENA_Z + ARENA_OD/2 + ARENA_WT/2 + 3.2; // a few units in front of the wall

// ‚îÄ‚îÄ Contract tiers ‚Äî cumulative bounty kill thresholds ‚îÄ‚îÄ
// { kills: required total pvpBountiesClaimed, coins, xp }
const BOUNTY_CONTRACT_TIERS = [
  { kills:3,    coins:300,    xp:150   },
  { kills:8,    coins:800,    xp:400   },
  { kills:18,   coins:2000,   xp:1000  },
  { kills:35,   coins:5000,   xp:2800  },
  { kills:65,   coins:13000,  xp:7000  },
  { kills:120,  coins:32000,  xp:18000 },
  { kills:200,  coins:80000,  xp:50000 },
];

// Returns the tier definition for tier index t (0-based).
// Beyond predefined list, scale geometrically.
function getBountyTierDef(t){
  if(t < BOUNTY_CONTRACT_TIERS.length) return BOUNTY_CONTRACT_TIERS[t];
  const last = BOUNTY_CONTRACT_TIERS[BOUNTY_CONTRACT_TIERS.length-1];
  const extra = t - (BOUNTY_CONTRACT_TIERS.length - 1);
  return {
    kills:  Math.round(last.kills  * Math.pow(1.65, extra)),
    coins:  Math.round(last.coins  * Math.pow(1.80, extra) / 1000) * 1000,
    xp:     Math.round(last.xp    * Math.pow(1.80, extra) / 500)  * 500,
  };
}

// Grizzled military commander ‚Äî dark plate armour, orange visor eyes
function makeBountyHandlerModel(){
  const mat = {
    armor:  new THREE.MeshLambertMaterial({color:0x222018}), // dark charcoal plate
    trim:   new THREE.MeshLambertMaterial({color:0xff6600}), // orange accent
    skin:   new THREE.MeshLambertMaterial({color:0xb07840}),
    visor:  new THREE.MeshBasicMaterial({color:0xff8800, transparent:true, opacity:0.9}),
    cloak:  new THREE.MeshLambertMaterial({color:0x1a1200}), // dark brown cloak panels
  };
  const g = new THREE.Group();
  const add=(geo,m,x,y,z,rx=0,ry=0,rz=0)=>{
    const mesh=new THREE.Mesh(geo,m);
    mesh.position.set(x,y,z); mesh.rotation.set(rx,ry,rz); g.add(mesh);
  };
  // Head ‚Äî angular armoured helmet
  add(_ncpG.head,   mat.armor,  0,  0.78, 0);
  add(new THREE.BoxGeometry(0.46,0.22,0.46), mat.armor, 0, 0.97, 0); // helm top
  add(new THREE.BoxGeometry(0.50,0.07,0.50), mat.trim,  0, 0.87, 0); // orange brim
  // Visor slit
  add(new THREE.BoxGeometry(0.32,0.06,0.04), mat.visor, 0, 0.78, 0.18);
  // Heavy pauldron chest
  add(new THREE.BoxGeometry(0.66,0.68,0.34), mat.armor, 0, 0.40, 0);
  // Orange chest stripe / rank insignia
  add(new THREE.BoxGeometry(0.10,0.44,0.36), mat.trim,  0, 0.42, 0);
  // Hips ‚Äî armoured
  add(_ncpG.hips,   mat.armor,  0,  0.03, 0);
  // Cloak back panels (wide, low)
  add(new THREE.BoxGeometry(0.60,0.80,0.06), mat.cloak, 0, 0.22,-0.18);
  // Left pauldron + arm
  add(new THREE.BoxGeometry(0.24,0.14,0.24), mat.trim, -0.40, 0.56,  0); // shoulder pad
  add(_ncpG.uArm,   mat.armor, -0.42, 0.36,  0, -0.2, 0, 0.1);
  add(_ncpG.lArm,   mat.skin,  -0.40,-0.04, -0.08);
  // Right pauldron + arm
  add(new THREE.BoxGeometry(0.24,0.14,0.24), mat.trim,  0.40, 0.56,  0);
  add(_ncpG.uArm,   mat.armor,  0.42, 0.36,  0, -0.2, 0,-0.1);
  add(_ncpG.lArm,   mat.skin,   0.40,-0.04, -0.08);
  // Legs ‚Äî armoured greaves
  for(const sx of [-1,1]){
    add(_ncpG.uLeg, mat.armor, sx*0.13,-0.35, 0);
    add(_ncpG.lLeg, mat.armor, sx*0.13,-0.74, 0);
    add(_ncpG.foot, mat.armor, sx*0.13,-0.99, 0.05);
    // Orange knee pad
    add(new THREE.BoxGeometry(0.22,0.10,0.22), mat.trim, sx*0.13,-0.50, 0.05);
  }
  // Visor glow orb stored for animation
  g.userData.visorIdx = g.children.findIndex(c=>c.material===mat.visor);
  g.userData.bobT = 0;
  return g;
}

function buildBountyHandlerNPC(){
  bountyHandlerMesh = makeBountyHandlerModel();
  bountyHandlerMesh.position.set(BH_X, 0.10, BH_Z);
  bountyHandlerMesh.rotation.y = Math.PI; // face south toward approaching players
  scene.add(bountyHandlerMesh);

  // Floating name label
  const lbl = makeNameSprite('BOUNTY HANDLER');
  lbl.position.set(BH_X, 2.5, BH_Z);
  scene.add(lbl);

  // Small orange point light for atmosphere
  const pt = new THREE.PointLight(0xff6600, 1.2, 5.0);
  pt.position.set(BH_X, 2.0, BH_Z);
  scene.add(pt);
  bountyHandlerMesh.userData.light = pt;
}

function updateBountyHandlerNPC(){
  if(!bountyHandlerMesh) return;
  const dx = camera.position.x - BH_X;
  const dz = camera.position.z - BH_Z;
  const near = dx*dx + dz*dz < SHOP_INTERACT_DIST * SHOP_INTERACT_DIST;
  if(near !== bountyHandlerInteractable){
    bountyHandlerInteractable = near;
    if(near && !merchantInteractable && !rebirthNPCInteractable && !bossNPCInteractable){
      _promptEl.textContent = '[ E ] BOUNTY CONTRACTS';
      _promptEl.style.display = 'block';
      _promptEl.style.borderColor = 'rgba(255,136,0,0.7)';
      _promptEl.style.color = '#ff8800';
    } else if(!merchantInteractable && !rebirthNPCInteractable && !bossNPCInteractable){
      _promptEl.style.display = 'none';
      _promptEl.textContent = '[ E ] TRADE';
      _promptEl.style.borderColor = 'rgba(255,215,0,0.6)';
      _promptEl.style.color = '#ffd700';
    }
  }
  // Idle bob + visor pulse
  bountyHandlerMesh.userData.bobT += 0.022;
  const t = bountyHandlerMesh.userData.bobT;
  bountyHandlerMesh.position.y = 0.10 + Math.sin(t) * 0.008;
  // Pulse the point light intensity
  if(bountyHandlerMesh.userData.light){
    bountyHandlerMesh.userData.light.intensity = 0.9 + Math.sin(t * 1.5) * 0.4;
  }
}

// ‚îÄ‚îÄ Open / close the contracts screen ‚îÄ‚îÄ
function openBountyHandlerScreen(){
  if(dead || !bountyHandlerInteractable) return;
  document.exitPointerLock();
  _refreshBHScreen();
  document.getElementById('bounty-handler-screen').classList.add('active');
}
function closeBountyHandlerScreen(){
  document.getElementById('bounty-handler-screen').classList.remove('active');
}

function _refreshBHScreen(){
  const grid = document.getElementById('bh-tier-grid');
  grid.innerHTML = '';

  // Work out how many tiers to show ‚Äî at least 7, or up to 3 beyond the claimed tier
  const showCount = Math.max(BOUNTY_CONTRACT_TIERS.length, bountyContractTier + 4);

  for(let t = 0; t < showCount; t++){
    const def = getBountyTierDef(t);
    const claimed   = t < bountyContractTier;
    const claimable = !claimed && pvpBountiesClaimed >= def.kills;
    const locked    = !claimed && !claimable;

    const div = document.createElement('div');
    div.className = 'bh-tier ' + (claimable ? 'claimable' : claimed ? 'claimed' : 'locked');

    const progressPct = claimed ? 100
      : Math.min(100, Math.round(pvpBountiesClaimed / def.kills * 100));

    div.innerHTML = `
      <div class="bh-tier-rank">CONTRACT ${t+1}</div>
      <div class="bh-tier-kills">${def.kills}<span>BOUNTIES REQUIRED</span></div>
      <div class="bh-tier-reward">
        ‚¨° ${def.coins.toLocaleString()} COINS<br>
        ‚òÖ ${def.xp.toLocaleString()} XP
      </div>
      <div class="bh-tier-status">
        ${claimed ? '‚úì COLLECTED' : claimable ? '‚ñ∂ CLAIM REWARD' : progressPct+'% ‚Äî '+pvpBountiesClaimed+'/'+def.kills}
      </div>`;

    if(claimable) div.onclick = () => claimContractReward(t);
    grid.appendChild(div);
  }

  // Progress bar toward next unclaimed tier
  const nextDef = getBountyTierDef(bountyContractTier);
  const pct = Math.min(100, Math.round(pvpBountiesClaimed / nextDef.kills * 100));
  document.getElementById('bh-progress-bar').style.width = pct + '%';
  document.getElementById('bh-progress-label').textContent =
    'BOUNTIES CLAIMED: ' + pvpBountiesClaimed +
    ' &nbsp;|&nbsp; NEXT CONTRACT: ' + nextDef.kills + ' REQUIRED';
}

function claimContractReward(tierIdx){
  const def = getBountyTierDef(tierIdx);
  if(pvpBountiesClaimed < def.kills) return;
  if(tierIdx !== bountyContractTier) return; // must claim in order

  coins += def.coins;
  addXP(def.xp);
  bountyContractTier++;
  updateHUD();
  showFloatPop('CONTRACT '+( tierIdx+1 )+' COMPLETE!', '#ff8800');
  showFloatPop('‚¨° +' + def.coins, '#ffd700');
  addChatMessage('', '// ‚òÖ BOUNTY CONTRACT '+(tierIdx+1)+' COMPLETE ‚Äî +'+def.coins+' ‚¨° +'+def.xp+' XP //', false, true);
  savePlayerState();
  _refreshBHScreen();
}

// Notify player (via chat) when a new contract tier becomes claimable
let _lastNotifiedTier = -1;
function checkBountyContractNotify(){
  const def = getBountyTierDef(bountyContractTier);
  if(pvpBountiesClaimed >= def.kills && bountyContractTier > _lastNotifiedTier){
    _lastNotifiedTier = bountyContractTier;
    addChatMessage('', '// ‚òÖ CONTRACT '+(bountyContractTier+1)+' READY ‚Äî VISIT THE BOUNTY HANDLER! //', false, true);
    showFloatPop('CONTRACT READY!', '#ff8800');
  }
}

// ============================================================================
//  RACETRACK + CAR SYSTEM
// ============================================================================

// ‚îÄ‚îÄ Car definitions ‚îÄ‚îÄ
const CAR_DEFS = {
  standard: { name:'STANDARD', color:0x2266ff, roofColor:0x1144bb, cost:500,   maxSpeed:0.28, accel:0.009, turnRate:0.038, friction:0.96,  icon:'üöó', camDist:7.0,  camH:3.0 },
  muscle:   { name:'MUSCLE',   color:0xdd2200, roofColor:0x881100, cost:2000,  maxSpeed:0.44, accel:0.011, turnRate:0.030, friction:0.97,  icon:'üöô', camDist:7.5,  camH:3.2 },
  sport:    { name:'SPORT',    color:0xffcc00, roofColor:0xcc9900, cost:5000,  maxSpeed:0.60, accel:0.014, turnRate:0.034, friction:0.975, icon:'üèé', camDist:7.0,  camH:3.0 },
  humvee:   { name:'HUMVEE',   color:0x6b7c3a, roofColor:0x4a5828, cost:18000, maxSpeed:0.36, accel:0.010, turnRate:0.032, friction:0.965, icon:'üöê', camDist:9.0,  camH:4.0, military:true, armor:true  },
  apc:      { name:'APC',      color:0x3d4f20, roofColor:0x2a3815, cost:45000, maxSpeed:0.26, accel:0.009, turnRate:0.026, friction:0.96,  icon:'üõ°', camDist:11.0, camH:5.0, military:true, armor:true, damageReduction:0.7 },
  tank:     { name:'M1 TANK',  color:0x5a6a2a, roofColor:0x3c4820, cost:120000,maxSpeed:0.20, accel:0.007, turnRate:0.022, friction:0.955, icon:'üéñ', camDist:13.0, camH:5.5, military:true, armor:true, cannon:true, damageReduction:0.85 },
};

// Track constants
const TRACK_CX = 0, TRACK_CZ = -245;
const TRACK_A  = 58;   // x semi-axis
const TRACK_B  = 42;   // z semi-axis
const TRACK_W  = 13;   // road width
const TRACK_N  = 32;   // oval segments

// ‚îÄ‚îÄ Build the oval racetrack ‚îÄ‚îÄ
(function buildRacetrack(){
  const asphalt = new THREE.MeshLambertMaterial({color:0x1a1a1a});
  const line     = new THREE.MeshLambertMaterial({color:0xeeeeee});
  const barrierR = new THREE.MeshLambertMaterial({color:0xdd1100});
  const barrierW = new THREE.MeshLambertMaterial({color:0xeeeeee});
  const grass    = new THREE.MeshLambertMaterial({color:0x336622});

  function seg(x,y,z,w,h,d,rot,mat){
    const g=new THREE.BoxGeometry(w,h,d);
    if(rot) g.applyMatrix4(new THREE.Matrix4().makeRotationY(rot));
    g.translate(x,y,z);
    scene.add(new THREE.Mesh(g,mat||asphalt));
  }

  // Grass infield + outfield ovals (larger, green fill under/around track)
  for(let i=0;i<TRACK_N;i++){
    const t0=(i/TRACK_N)*Math.PI*2, t1=((i+1)/TRACK_N)*Math.PI*2, tm=(t0+t1)/2;
    const cx=TRACK_CX+TRACK_A*Math.cos(tm), cz=TRACK_CZ+TRACK_B*Math.sin(tm);
    const tangX=-TRACK_A*Math.sin(tm), tangZ=TRACK_B*Math.cos(tm);
    const rot=Math.atan2(tangX,tangZ);
    const x0=TRACK_CX+TRACK_A*Math.cos(t0),z0=TRACK_CZ+TRACK_B*Math.sin(t0);
    const x1=TRACK_CX+TRACK_A*Math.cos(t1),z1=TRACK_CZ+TRACK_B*Math.sin(t1);
    const sLen=Math.sqrt((x1-x0)**2+(z1-z0)**2)+0.8;
    // Road surface
    seg(cx,0.05,cz, TRACK_W,0.12,sLen, rot, asphalt);
    // Radial unit vector (outward from oval center)
    const rLen=Math.sqrt(cx*cx+(cz-TRACK_CZ)*(cz-TRACK_CZ));
    const rn_x=cx/Math.max(rLen,0.01), rn_z=(cz-TRACK_CZ)/Math.max(rLen,0.01);
    const hw=TRACK_W/2;
    // Inner barrier (alternating red/white)
    const bMat=i%2===0?barrierR:barrierW;
    seg(cx-rn_x*hw*0.85, 0.30, cz-rn_z*hw*0.85, 0.35,0.60,sLen+0.5, rot, bMat);
    // Outer barrier
    seg(cx+rn_x*hw*0.85, 0.30, cz+rn_z*hw*0.85, 0.35,0.60,sLen+0.5, rot, bMat);
    // White line - inner edge
    seg(cx-rn_x*(hw-1.2),0.12,cz-rn_z*(hw-1.2), 0.18,0.04,sLen+0.5, rot, line);
    // White line - outer edge
    seg(cx+rn_x*(hw-1.2),0.12,cz+rn_z*(hw-1.2), 0.18,0.04,sLen+0.5, rot, line);
  }

  // Grass infield (large oval, flat)
  for(let i=0;i<TRACK_N;i++){
    const t0=(i/TRACK_N)*Math.PI*2, t1=((i+1)/TRACK_N)*Math.PI*2, tm=(t0+t1)/2;
    const IA=TRACK_A-TRACK_W/2-1.5, IB=TRACK_B-TRACK_W/2-1.5;
    const cx=TRACK_CX+IA*Math.cos(tm), cz=TRACK_CZ+IB*Math.sin(tm);
    const tangX=-IA*Math.sin(tm), tangZ=IB*Math.cos(tm);
    const rot=Math.atan2(tangX,tangZ);
    const x0=TRACK_CX+IA*Math.cos(t0),z0=TRACK_CZ+IB*Math.sin(t0);
    const x1=TRACK_CX+IA*Math.cos(t1),z1=TRACK_CZ+IB*Math.sin(t1);
    const sLen=Math.sqrt((x1-x0)**2+(z1-z0)**2)*1.6;
    seg(cx,0.02,cz, sLen*0.65,0.04,sLen, rot, grass);
  }

  // Start/finish line
  const sfMat=new THREE.MeshLambertMaterial({color:0xffffff});
  for(let i=0;i<6;i++){
    const stripMat=i%2===0?sfMat:asphalt;
    seg(TRACK_CX+TRACK_A-TRACK_W/2+i*(TRACK_W/6)+TRACK_W/12, 0.12, TRACK_CZ, TRACK_W/6-0.05, 0.05, 2.8, 0, stripMat);
  }

  // Track sign over start/finish
  {
    const sc=document.createElement('canvas'); sc.width=512; sc.height=80;
    const c2=sc.getContext('2d');
    c2.fillStyle='#0a0a00'; c2.fillRect(0,0,512,80);
    c2.strokeStyle='#ff8800'; c2.lineWidth=4; c2.strokeRect(4,4,504,72);
    c2.font='bold 30px serif'; c2.fillStyle='#ffcc00'; c2.textAlign='center';
    c2.fillText('üèÅ  RACE CIRCUIT  üèÅ',256,50);
    const tx=new THREE.CanvasTexture(sc);
    const sp=new THREE.Mesh(new THREE.PlaneGeometry(10,1.6), new THREE.MeshBasicMaterial({map:tx,transparent:true,depthTest:true}));
    sp.position.set(TRACK_CX+TRACK_A+2, 4, TRACK_CZ);
    sp.rotation.y=-Math.PI/2;
    scene.add(sp);
  }
})();

// ‚îÄ‚îÄ Car dealer NPC ‚îÄ‚îÄ
const CD_X = TRACK_CX + TRACK_A + 6;
const CD_Z = TRACK_CZ + 8;
let carDealerMesh = null;
let carDealerInteractable = false;
let carDealerOpen = false;

function makeCarDealerModel(){
  const g = new THREE.Group();
  const add=(geo,mat,x,y,z)=>{ const m=new THREE.Mesh(geo,mat); m.position.set(x,y,z); g.add(m); return m; };
  const mBody   = new THREE.MeshLambertMaterial({color:0x334411}); // overalls (dark green)
  const mSkin   = new THREE.MeshLambertMaterial({color:0xd4a070});
  const mHair   = new THREE.MeshLambertMaterial({color:0x221100});
  const mCap    = new THREE.MeshLambertMaterial({color:0xff8800}); // orange cap
  const mAccent = new THREE.MeshLambertMaterial({color:0xffaa00}); // accent
  const mWrench = new THREE.MeshLambertMaterial({color:0x888888});
  // Body
  add(new THREE.BoxGeometry(0.50,0.60,0.32), mBody,  0, 0.80, 0);
  add(new THREE.BoxGeometry(0.52,0.06,0.34), mAccent,0, 1.07, 0); // collar stripe
  // Hips
  add(new THREE.BoxGeometry(0.48,0.26,0.30), mBody,  0, 0.43, 0);
  // Legs
  for(const sx of[-1,1]){
    add(new THREE.BoxGeometry(0.22,0.50,0.26), mBody,  sx*0.13,0.08, 0);
    add(new THREE.BoxGeometry(0.20,0.26,0.24), mBody,  sx*0.13,-0.36,0);
    add(new THREE.BoxGeometry(0.21,0.10,0.28), mHair,  sx*0.13,-0.55,0.02); // boots
  }
  // Arms
  for(const sx of[-1,1]){
    add(new THREE.BoxGeometry(0.22,0.48,0.22), mBody,  sx*0.36,0.78,0);
    add(new THREE.BoxGeometry(0.20,0.30,0.20), mSkin,  sx*0.36,0.42,0);
  }
  // Pocket straps (overalls bib)
  add(new THREE.BoxGeometry(0.18,0.22,0.04), mAccent,0, 0.88, 0.17);
  // Head
  add(new THREE.BoxGeometry(0.42,0.40,0.38), mSkin,  0, 1.42, 0);
  // Cap brim
  add(new THREE.BoxGeometry(0.48,0.08,0.42), mCap,   0, 1.62, 0);
  add(new THREE.BoxGeometry(0.42,0.06,0.22), mCap,   0, 1.62,-0.28); // brim extension
  // Wrench in hand
  add(new THREE.BoxGeometry(0.06,0.40,0.06), mWrench,0.36,0.38,0.06);
  add(new THREE.BoxGeometry(0.16,0.06,0.06), mWrench,0.36,0.56,0.06);
  add(new THREE.BoxGeometry(0.16,0.06,0.06), mWrench,0.36,0.22,0.06);
  // Point light
  const pl=new THREE.PointLight(0xff8800,0.8,6);
  pl.position.set(0,2.2,0); g.add(pl);
  g.userData.bobT=0; g.userData.light=pl;
  return g;
}

function buildCarDealerNPC(){
  carDealerMesh = makeCarDealerModel();
  carDealerMesh.position.set(CD_X, 0, CD_Z);
  carDealerMesh.rotation.y = -Math.PI/2; // face west toward track
  scene.add(carDealerMesh);
  const lbl = makeNameSprite('CAR DEALER');
  lbl.position.set(CD_X, 2.8, CD_Z);
  scene.add(lbl);
}

function updateCarDealerNPC(){
  if(!carDealerMesh) return;
  carDealerMesh.userData.bobT += 0.022;
  carDealerMesh.position.y = 0.0 + Math.sin(carDealerMesh.userData.bobT)*0.009;
  carDealerMesh.userData.light.intensity = 0.7 + Math.sin(carDealerMesh.userData.bobT*2)*0.2;
  const dx=camera.position.x-CD_X, dz=camera.position.z-CD_Z;
  const near = dx*dx+dz*dz < SHOP_INTERACT_DIST*SHOP_INTERACT_DIST*1.8;
  if(near !== carDealerInteractable){
    carDealerInteractable = near;
    if(near && !inCar) _promptEl.textContent='[ E ] CAR DEALER';
  }
}

function openCarDealer(){
  if(carDealerOpen) return;
  carDealerOpen = true;
  document.exitPointerLock();
  document.getElementById('car-dealer-screen').classList.add('active');
  refreshCarDealerUI();
}
function closeCarDealer(){
  carDealerOpen = false;
  document.getElementById('car-dealer-screen').classList.remove('active');
  renderer.domElement.requestPointerLock();
}
function refreshCarDealerUI(){
  document.getElementById('car-dealer-coins').textContent = coins;
  document.querySelectorAll('.car-card').forEach(el => {
    const key = el.dataset.car;
    if(!key || !CAR_DEFS[key]) return;
    const def = CAR_DEFS[key];
    const owned = ownedCars[key];
    el.classList.remove('owned','cant-afford');
    const costEl = el.querySelector('.car-card-cost');
    if(owned){
      el.classList.add('owned');
      if(costEl) costEl.textContent='‚úì OWNED ‚Äî ENTER AT TRACK';
    } else {
      if(costEl) costEl.textContent='‚¨° '+def.cost+' COINS';
      if(coins < def.cost) el.classList.add('cant-afford');
    }
  });
}
document.addEventListener('DOMContentLoaded',()=>{
  const cg = document.getElementById('car-grid');
  if(cg) cg.addEventListener('click', e => {
    const card = e.target.closest('.car-card');
    if(!card) return;
    const key = card.dataset.car;
    if(!key || !CAR_DEFS[key]) return;
    buyCarType(key);
  });
});
async function buyCarType(key){
  const def = CAR_DEFS[key];
  if(!def || ownedCars[key]) return;
  if(coins < def.cost){ return; }

  // ‚îÄ‚îÄ Server-side economy validation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const _res = await callEdgeFn('validate-action', {
    action: 'buy_car', username: accountUsername, item: key
  });
  if(!_res || !_res.success){
    if(_res && typeof _res.coins === 'number') coins = _res.coins;
    updateHUD(); refreshCarDealerUI(); return;
  }
  coins = _res.coins;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  ownedCars[key] = true;
  updateHUD();
  spawnParkedCar(key);
  savePlayerState();
  refreshCarDealerUI();
  addChatMessage('','// üèé '+def.name+' PURCHASED ‚Äî FIND IT AT THE TRACK ENTRANCE! //',false,true);
}

// ‚îÄ‚îÄ Parked cars on track ‚îÄ‚îÄ
const ownedCars = { standard:false, muscle:false, sport:false, humvee:false, apc:false, tank:false };
const parkedCars = []; // { mesh, key, interactRadius }

const CAR_PARK_SPOTS = {
  standard: { x: TRACK_CX + TRACK_A - 2,  z: TRACK_CZ - 16 },
  muscle:   { x: TRACK_CX + TRACK_A - 2,  z: TRACK_CZ - 8  },
  sport:    { x: TRACK_CX + TRACK_A - 2,  z: TRACK_CZ      },
  humvee:   { x: TRACK_CX + TRACK_A - 2,  z: TRACK_CZ + 10 },
  apc:      { x: TRACK_CX + TRACK_A - 2,  z: TRACK_CZ + 20 },
  tank:     { x: TRACK_CX + TRACK_A - 2,  z: TRACK_CZ + 32 },
};

function makeCarMesh(def){
  if(def.military) return _makeMilitaryMesh(def);
  const g = new THREE.Group();
  const add=(geo,mat,x,y,z,ry)=>{ const m=new THREE.Mesh(geo,mat); m.position.set(x,y,z); if(ry) m.rotation.y=ry; g.add(m); };
  const mBody  = new THREE.MeshLambertMaterial({color:def.color});
  const mRoof  = new THREE.MeshLambertMaterial({color:def.roofColor});
  const mWheel = new THREE.MeshLambertMaterial({color:0x111111});
  const mHub   = new THREE.MeshLambertMaterial({color:0xaaaaaa});
  const mGlass = new THREE.MeshLambertMaterial({color:0x88ccff, transparent:true, opacity:0.5});
  const mLight = new THREE.MeshBasicMaterial({color:0xffffff});
  const mBLight= new THREE.MeshBasicMaterial({color:0xff2200});
  add(new THREE.BoxGeometry(1.80,0.52,3.80), mBody,  0, 0.52, 0);
  add(new THREE.BoxGeometry(1.70,0.32,0.22), mBody,  0, 0.36,-2.01);
  add(new THREE.BoxGeometry(1.70,0.32,0.22), mBody,  0, 0.36, 2.01);
  add(new THREE.BoxGeometry(1.40,0.46,2.00), mRoof,  0, 0.98, 0.0);
  add(new THREE.BoxGeometry(1.36,0.44,0.06), mGlass, 0, 0.98,-1.03);
  add(new THREE.BoxGeometry(1.36,0.44,0.06), mGlass, 0, 0.98, 1.03);
  add(new THREE.BoxGeometry(1.78,0.12,0.80), mBody,  0, 0.76,-1.40);
  add(new THREE.BoxGeometry(1.78,0.12,0.80), mBody,  0, 0.76, 1.40);
  const _wRot = new THREE.Matrix4().makeRotationZ(Math.PI/2);
  const wGeo = new THREE.CylinderGeometry(0.34,0.34,0.22,14); wGeo.applyMatrix4(_wRot);
  const hGeo = new THREE.CylinderGeometry(0.18,0.18,0.26,8);  hGeo.applyMatrix4(_wRot);
  for(const [wx,wz] of [[-1.02,-1.35],[1.02,-1.35],[-1.02,1.35],[1.02,1.35]]){
    add(wGeo.clone(), mWheel, wx, 0.34, wz);
    add(hGeo.clone(), mHub,   wx, 0.34, wz);
  }
  add(new THREE.BoxGeometry(0.28,0.16,0.06), mLight, -0.58,0.52,-1.94);
  add(new THREE.BoxGeometry(0.28,0.16,0.06), mLight,  0.58,0.52,-1.94);
  add(new THREE.BoxGeometry(0.28,0.14,0.06), mBLight,-0.58,0.52, 1.94);
  add(new THREE.BoxGeometry(0.28,0.14,0.06), mBLight, 0.58,0.52, 1.94);
  _attachCarSprite(g, def);
  return g;
}

function _makeMilitaryMesh(def){
  const g = new THREE.Group();
  const add=(geo,mat,x,y,z)=>{ const m=new THREE.Mesh(geo,mat); m.position.set(x,y,z); g.add(m); return m; };
  const mBody  = new THREE.MeshLambertMaterial({color:def.color});
  const mRoof  = new THREE.MeshLambertMaterial({color:def.roofColor});
  const mDark  = new THREE.MeshLambertMaterial({color:0x1a1a0a});
  const mMetal = new THREE.MeshLambertMaterial({color:0x555544});
  const mGlass = new THREE.MeshLambertMaterial({color:0x334422, transparent:true, opacity:0.6});
  const mLight = new THREE.MeshBasicMaterial({color:0xffffaa});
  const mBLight= new THREE.MeshBasicMaterial({color:0xff2200});

  if(def.name==='HUMVEE'){
    // Wide blocky military jeep
    add(new THREE.BoxGeometry(2.10,0.60,4.40), mBody, 0, 0.55, 0);       // hull
    add(new THREE.BoxGeometry(1.80,0.52,2.20), mRoof, 0, 1.08, 0.2);     // cab
    add(new THREE.BoxGeometry(1.76,0.42,0.08), mGlass, 0, 1.08,-0.92);   // windshield
    add(new THREE.BoxGeometry(0.30,0.44,2.20), mMetal,-1.06,1.08,0.2);   // side plate L
    add(new THREE.BoxGeometry(0.30,0.44,2.20), mMetal, 1.06,1.08,0.2);   // side plate R
    add(new THREE.BoxGeometry(2.12,0.26,0.30), mBody, 0, 0.38,-2.22);    // front bumper
    add(new THREE.BoxGeometry(2.12,0.26,0.30), mBody, 0, 0.38, 2.22);    // rear bumper
    add(new THREE.BoxGeometry(2.14,0.14,4.44), mBody, 0, 0.84, 0);       // running boards
    // Gun ring on roof
    add(new THREE.CylinderGeometry(0.32,0.32,0.14,12), mMetal, 0, 1.38, -0.3);
    add(new THREE.BoxGeometry(0.12,0.12,0.90), mDark, 0, 1.52,-0.3);     // gun barrel
    // Wheels (6 large)
    const _wR=new THREE.Matrix4().makeRotationZ(Math.PI/2);
    const wG=new THREE.CylinderGeometry(0.44,0.44,0.28,14); wG.applyMatrix4(_wR);
    const hG=new THREE.CylinderGeometry(0.22,0.22,0.32,8);  hG.applyMatrix4(_wR);
    for(const [wx,wz] of [[-1.18,-1.5],[1.18,-1.5],[-1.18,0],[1.18,0],[-1.18,1.5],[1.18,1.5]]){
      add(wG.clone(), mDark, wx, 0.44, wz);
      add(hG.clone(), mMetal,wx, 0.44, wz);
    }
    add(new THREE.BoxGeometry(0.30,0.18,0.06), mLight,-0.72,0.60,-2.24);
    add(new THREE.BoxGeometry(0.30,0.18,0.06), mLight, 0.72,0.60,-2.24);
    add(new THREE.BoxGeometry(0.30,0.16,0.06), mBLight,-0.72,0.60,2.24);
    add(new THREE.BoxGeometry(0.30,0.16,0.06), mBLight, 0.72,0.60,2.24);

  } else if(def.name==='APC'){
    // Large boxy armored troop carrier
    add(new THREE.BoxGeometry(2.60,0.90,5.50), mBody, 0, 0.65, 0);       // main hull
    add(new THREE.BoxGeometry(2.64,0.16,5.54), mRoof, 0, 1.11, 0);       // roof slab
    add(new THREE.BoxGeometry(2.60,0.20,0.20), mMetal, 0, 0.76,-2.76);   // front slope
    add(new THREE.BoxGeometry(2.50,0.44,0.08), mGlass, 0, 0.90,-2.64);   // armored glass
    add(new THREE.BoxGeometry(0.50,0.90,5.50), mMetal,-1.56,0.65,0);     // side armour L
    add(new THREE.BoxGeometry(0.50,0.90,5.50), mMetal, 1.56,0.65,0);     // side armour R
    // Hatches on top
    add(new THREE.BoxGeometry(0.70,0.08,0.70), mMetal, -0.5,1.20, 0);
    add(new THREE.BoxGeometry(0.70,0.08,0.70), mMetal,  0.5,1.20, 0);
    // MG mount
    add(new THREE.CylinderGeometry(0.20,0.20,0.16,10), mMetal, 0,1.30,-0.8);
    add(new THREE.BoxGeometry(0.08,0.08,0.70), mDark, 0,1.38,-0.5);
    // Tracks (flat box each side, dark)
    add(new THREE.BoxGeometry(0.36,0.70,5.60), mDark, -1.44,0.38,0);
    add(new THREE.BoxGeometry(0.36,0.70,5.60), mDark,  1.44,0.38,0);
    // Roadwheels
    const _wR2=new THREE.Matrix4().makeRotationZ(Math.PI/2);
    const wG2=new THREE.CylinderGeometry(0.34,0.34,0.40,10); wG2.applyMatrix4(_wR2);
    for(const wz of[-2.0,-0.7,0.7,2.0]){
      add(wG2.clone(), mMetal,-1.44,0.34,wz);
      add(wG2.clone(), mMetal, 1.44,0.34,wz);
    }
    add(new THREE.BoxGeometry(0.36,0.20,0.08), mLight,-1.0,0.72,-2.80);
    add(new THREE.BoxGeometry(0.36,0.20,0.08), mLight, 1.0,0.72,-2.80);
    add(new THREE.BoxGeometry(0.36,0.16,0.08), mBLight,-1.0,0.72,2.80);
    add(new THREE.BoxGeometry(0.36,0.16,0.08), mBLight, 1.0,0.72,2.80);

  } else {
    // TANK ‚Äî M1 Abrams style
    // Lower hull
    add(new THREE.BoxGeometry(3.20,0.70,6.00), mBody, 0, 0.42, 0);
    // Upper hull slopes
    add(new THREE.BoxGeometry(2.80,0.40,4.20), mBody, 0, 0.90, -0.3);
    // Turret
    const turret=add(new THREE.BoxGeometry(2.00,0.70,2.20), mRoof, 0,1.28, -0.4);
    add(new THREE.BoxGeometry(1.80,0.20,2.00), mBody, 0, 1.63,-0.4);     // turret top slope
    add(new THREE.BoxGeometry(0.30,0.30,0.16,8), mMetal, -0.6,1.55,-0.4); // commander hatch
    add(new THREE.BoxGeometry(0.30,0.30,0.16,8), mMetal,  0.4,1.55,-0.4); // loader hatch
    // Cannon barrel ‚Äî long and prominent
    const barrel=add(new THREE.CylinderGeometry(0.12,0.14,3.80,10), mDark, 0,1.38,-2.70);
    barrel.rotation.x=Math.PI/2;
    // Coaxial MG
    add(new THREE.BoxGeometry(0.06,0.06,0.80), mDark, 0.28,1.28,-1.55);
    // Reactive armour panels on sides
    for(let i=0;i<4;i++){
      add(new THREE.BoxGeometry(0.08,0.30,1.10), mMetal,-1.68,0.60,-1.8+i*1.2);
      add(new THREE.BoxGeometry(0.08,0.30,1.10), mMetal, 1.68,0.60,-1.8+i*1.2);
    }
    // Tracks
    add(new THREE.BoxGeometry(0.42,0.72,6.10), mDark, -1.70,0.38,0);
    add(new THREE.BoxGeometry(0.42,0.72,6.10), mDark,  1.70,0.38,0);
    // Drive sprockets + roadwheels
    const _wR3=new THREE.Matrix4().makeRotationZ(Math.PI/2);
    const wG3=new THREE.CylinderGeometry(0.38,0.38,0.46,10); wG3.applyMatrix4(_wR3);
    for(const wz of[-2.4,-1.2,0,1.2,2.4]){
      add(wG3.clone(), mMetal,-1.72,0.38,wz);
      add(wG3.clone(), mMetal, 1.72,0.38,wz);
    }
    // Headlights
    add(new THREE.BoxGeometry(0.32,0.22,0.08), mLight,-1.20,0.60,-3.02);
    add(new THREE.BoxGeometry(0.32,0.22,0.08), mLight, 1.20,0.60,-3.02);
    add(new THREE.BoxGeometry(0.32,0.18,0.08), mBLight,-1.20,0.60,3.02);
    add(new THREE.BoxGeometry(0.32,0.18,0.08), mBLight, 1.20,0.60,3.02);
    // Star decal
    add(new THREE.BoxGeometry(0.20,0.04,0.20), new THREE.MeshBasicMaterial({color:0xffffff}), 0,1.00,0);
    // Cannon fire hint
    g.userData.isTank = true;
    g.userData.cannonCd = 0;
  }
  _attachCarSprite(g, def);
  return g;
}

function _attachCarSprite(g, def){
  const sc=document.createElement('canvas'); sc.width=320; sc.height=48;
  const c2=sc.getContext('2d');
  c2.fillStyle='rgba(0,0,0,0)'; c2.fillRect(0,0,320,48);
  c2.font='bold 14px monospace';
  c2.fillStyle=def.military?'#88ff44':'#ffd700';
  c2.textAlign='center';
  const hint = def.cannon ? '[ E ] ENTER ‚Äî '+def.name+' | SPACE=CANNON' : '[ E ] ENTER ‚Äî '+def.name;
  c2.fillText(hint,160,30);
  const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(sc),depthTest:false}));
  spr.scale.set(4,0.6,1); spr.position.set(0,2.4,0);
  g.add(spr); g.userData.enterSprite=spr;
}

function spawnParkedCar(key){
  // Remove existing parked car of this type if any
  const old = parkedCars.find(c=>c.key===key);
  if(old){ scene.remove(old.mesh); parkedCars.splice(parkedCars.indexOf(old),1); }
  const def = CAR_DEFS[key];
  const spot = CAR_PARK_SPOTS[key];
  const mesh = makeCarMesh(def);
  mesh.position.set(spot.x, 0, spot.z);
  mesh.rotation.y = Math.PI/2; // face toward track
  scene.add(mesh);
  parkedCars.push({ mesh, key, def, spot });
}

// ‚îÄ‚îÄ Active car state ‚îÄ‚îÄ
let inCar = false;
let activeCar = null; // { mesh, def, key }
let carPos = new THREE.Vector3();
let carAngle = 0;
let carSpeed = 0;
const _carUp = new THREE.Vector3(0,1,0);
let _carLookTarget = new THREE.Vector3();

function enterCar(parked){
  inCar = true;
  activeCar = parked;
  carPos.copy(parked.mesh.position);
  carAngle = parked.mesh.rotation.y;
  carSpeed = 0;
  // Remove from parked list (it's now driven)
  parkedCars.splice(parkedCars.indexOf(parked),1);
  // Hide enter sprite
  if(parked.mesh.userData.enterSprite) parked.mesh.userData.enterSprite.visible=false;
  // Hide gun HUD
  // gun hidden via render skip (inCar=true)
  document.getElementById('car-hud').style.display='block';
  document.getElementById('car-exit-hint').style.display='block';
  document.getElementById('car-hud-name').textContent=parked.def.name;
  // Release pointer lock ‚Äî camera moves freely in 3rd person
  document.exitPointerLock();
  document.getElementById('click-hint').style.display='none';
}
function exitCar(){
  if(!inCar || !activeCar) return;
  inCar = false;
  // Park the car where we left off
  activeCar.mesh.position.copy(carPos);
  activeCar.mesh.position.y = 0;
  activeCar.mesh.rotation.y = carAngle;
  if(activeCar.mesh.userData.enterSprite) activeCar.mesh.userData.enterSprite.visible=true;
  parkedCars.push(activeCar);
  activeCar = null;
  carSpeed = 0;
  // Restore player position just outside car door
  camera.position.set(carPos.x + Math.sin(carAngle+Math.PI/2)*2.5, GROUND_Y, carPos.z + Math.cos(carAngle+Math.PI/2)*2.5);
  camera.rotation.set(0,0,0); pitch=0; yaw=carAngle;
  // Restore HUD
  // gun restored via render (inCar=false)
  document.getElementById('car-hud').style.display='none';
  document.getElementById('car-exit-hint').style.display='none';
  renderer.domElement.requestPointerLock();
}

function updateCar(){
  if(!inCar || !activeCar) return;
  const def = activeCar.def;

  // Throttle / brake
  if(keys['KeyW']||keys['ArrowUp']){
    carSpeed += def.accel;
    if(carSpeed > def.maxSpeed) carSpeed = def.maxSpeed;
  } else if(keys['KeyS']||keys['ArrowDown']){
    carSpeed -= def.accel*1.4;
    if(carSpeed < -def.maxSpeed*0.45) carSpeed = -def.maxSpeed*0.45;
  }

  // Friction
  carSpeed *= def.friction;
  if(Math.abs(carSpeed) < 0.0005) carSpeed = 0;

  // Steering (only when moving)
  if(Math.abs(carSpeed) > 0.005){
    const steerDir = carSpeed > 0 ? 1 : -1;
    if(keys['KeyA']||keys['ArrowLeft'])  carAngle += def.turnRate * steerDir;
    if(keys['KeyD']||keys['ArrowRight']) carAngle -= def.turnRate * steerDir;
  }

  // Tank cannon ‚Äî SPACE fires a heavy shell
  if(def.cannon && activeCar.mesh.userData.isTank){
    if(activeCar.mesh.userData.cannonCd > 0) activeCar.mesh.userData.cannonCd--;
    if(keys['Space'] && activeCar.mesh.userData.cannonCd === 0){
      activeCar.mesh.userData.cannonCd = 120; // 2s cooldown
      _fireTankCannon();
    }
  }

  // Move car
  carPos.x -= Math.sin(carAngle) * carSpeed;
  carPos.z -= Math.cos(carAngle) * carSpeed;
  carPos.x = Math.max(-240, Math.min(240, carPos.x));
  carPos.z = Math.max(-310, Math.min(200, carPos.z));

  // Update mesh
  activeCar.mesh.position.set(carPos.x, 0, carPos.z);
  activeCar.mesh.rotation.y = carAngle;

  // 3rd person camera ‚Äî behind and above car
  const camDist = def.camDist||7.0, camH = def.camH||3.0;
  const behindX = carPos.x + Math.sin(carAngle) * camDist;
  const behindZ = carPos.z + Math.cos(carAngle) * camDist;
  camera.position.set(behindX, camH, behindZ);
  _carLookTarget.set(
    carPos.x - Math.sin(carAngle)*1.5,
    0.8,
    carPos.z - Math.cos(carAngle)*1.5
  );
  camera.lookAt(_carLookTarget);

  // Speed display (km/h style)
  const kmh = Math.round(Math.abs(carSpeed) / def.maxSpeed * 200);
  document.getElementById('car-hud-speed').textContent = kmh + ' KM/H';

  // Check if near any NPC (to show correct prompt)
  _promptEl.style.display='none';
}

function _fireTankCannon(){
  // Fire a massive shell forward from the tank
  const dir = new THREE.Vector3(-Math.sin(carAngle), 0.04, -Math.cos(carAngle)).normalize();
  const origin = new THREE.Vector3(carPos.x, 1.4, carPos.z);
  // Visual shell
  const shellGeo = new THREE.CylinderGeometry(0.10,0.10,0.8,8);
  const shellMat = new THREE.MeshLambertMaterial({color:0xffaa00});
  const shellMesh = new THREE.Mesh(shellGeo, shellMat);
  shellMesh.position.copy(origin);
  shellMesh.rotation.x = Math.PI/2;
  scene.add(shellMesh);
  addChatMessage('','// üí• TANK CANNON FIRED //',false,true);
  const vel = dir.clone().multiplyScalar(0.8);
  let life = 80;
  const SHELL_R = 12, SHELL_RSQ = SHELL_R*SHELL_R;
  function shellTick(){
    life--;
    shellMesh.position.add(vel);
    vel.y -= 0.004; // slight gravity drop
    // Check hits
    const sp = shellMesh.position;
    let hit = false;
    // Zombies
    for(let i=zombies.length-1;i>=0;i--){
      if(sp.distanceToSquared(zombies[i].mesh.position)<SHELL_RSQ){ zombies[i].hp=0; hit=true; }
    }
    // Boss
    if(activeBoss && sp.distanceToSquared(activeBoss.mesh.position)<(SHELL_R*activeBoss.def.scale)**2){
      const dmg=Math.round(15000*damageMultiplier); activeBoss.hp=Math.max(0,activeBoss.hp-dmg);
      drawHPBar(activeBoss.hpSpr,activeBoss.hp,activeBoss.maxHp); showFloatPop('-'+dmg+' BOSS','#ff4444'); hit=true;
    }
    // Remote players
    for(const id in remotePlayers){
      const rp=remotePlayers[id];
      if(sp.distanceToSquared(rp.mesh.position)<SHELL_RSQ){
        _chanSend({type:'broadcast',event:'hit',payload:{target:id,damage:150,sender:playerId}}); hit=true;
      }
    }
    if(hit || life<=0 || sp.y < -1){
      scene.remove(shellMesh);
      if(hit){ spawnExplosion(sp.clone()); explosionDamageZombies(sp,SHELL_R,500); }
      return;
    }
    requestAnimationFrame(shellTick);
  }
  requestAnimationFrame(shellTick);
}

function updateParkedCarProximity(){
  if(inCar||onHorse||inTrain) return;
  let nearCar = null;
  for(const c of parkedCars){
    const dx=camera.position.x-c.mesh.position.x, dz=camera.position.z-c.mesh.position.z;
    if(dx*dx+dz*dz < 9) { nearCar=c; break; }
  }
  if(nearCar){
    _promptEl.style.display='block';
    _promptEl.textContent='[ E ] ENTER '+nearCar.def.name;
  }
}


// ============================================================================
//  TRAIN SYSTEM ‚Äî auto-runs on a fixed oval route in the north map
// ============================================================================
const TRAIN_ROUTE = (function(){
  const pts=[];
  const CX=0,CZ=160,RX=110,RZ=100,N=60;
  for(let i=0;i<N;i++){
    const t=(i/N)*Math.PI*2;
    pts.push({x:CX+Math.cos(t)*RX, z:CZ+Math.sin(t)*RZ});
  }
  return pts;
})();

let trainProgress=0;
const TRAIN_SPEED=0.12;
const TRAIN_CARS=4;
let trainMeshes=[];
let inTrain=false;
let trainCarIdx=0;

function _makeTrainLocomotive(){
  const g=new THREE.Group();
  const add=(geo,mat,x,y,z)=>{const m=new THREE.Mesh(geo,mat);m.position.set(x,y,z);g.add(m);};
  const mBody=new THREE.MeshLambertMaterial({color:0x222222});
  const mMetal=new THREE.MeshLambertMaterial({color:0x555555});
  const mLight=new THREE.MeshBasicMaterial({color:0xffffaa});
  const mGold=new THREE.MeshLambertMaterial({color:0xcc8800});
  const mRed=new THREE.MeshLambertMaterial({color:0xcc2200});
  add(new THREE.BoxGeometry(2.0,1.4,5.0),mBody,0,0.9,0);
  add(new THREE.BoxGeometry(1.8,1.0,2.0),mBody,0,1.9,-1.0);
  add(new THREE.BoxGeometry(1.6,0.8,0.08),new THREE.MeshLambertMaterial({color:0x88aacc,transparent:true,opacity:0.5}),0,1.9,-2.04);
  const cylRot=new THREE.Matrix4().makeRotationX(Math.PI/2);
  const boilerGeo=new THREE.CylinderGeometry(0.7,0.7,3.2,12);boilerGeo.applyMatrix4(cylRot);
  add(boilerGeo,mBody,0,0.9,1.0);
  add(new THREE.CylinderGeometry(0.18,0.28,1.0,10),mMetal,0,2.2,1.8);
  add(new THREE.CylinderGeometry(0.30,0.22,0.3,10),mGold,0,2.75,1.8);
  add(new THREE.BoxGeometry(1.8,0.3,0.5),mRed,0,0.22,2.65);
  for(let i=0,bz=-0.2;i<5;i++,bz-=0.55)
    add(new THREE.CylinderGeometry(0.72,0.72,0.12,12),mMetal,0,0.9,bz);
  add(new THREE.CylinderGeometry(0.18,0.18,0.12,10),mLight,0,1.45,2.46);
  const wR=new THREE.Matrix4().makeRotationZ(Math.PI/2);
  const dwG=new THREE.CylinderGeometry(0.50,0.50,0.25,14);dwG.applyMatrix4(wR);
  const swG=new THREE.CylinderGeometry(0.28,0.28,0.25,12);swG.applyMatrix4(wR);
  for(const[wx,wz]of[[-1.1,-0.8],[1.1,-0.8],[-1.1,0.4],[1.1,0.4]]) add(dwG.clone(),mMetal,wx,0.50,wz);
  for(const[wx,wz]of[[-1.05,1.6],[1.05,1.6],[-1.05,-1.9],[1.05,-1.9]]) add(swG.clone(),mMetal,wx,0.30,wz);
  _attachTrainSprite(g,'[E] BOARD LOCOMOTIVE');
  return g;
}

function _makeTrainCarriage(){
  const g=new THREE.Group();
  const add=(geo,mat,x,y,z)=>{const m=new THREE.Mesh(geo,mat);m.position.set(x,y,z);g.add(m);};
  const mBody=new THREE.MeshLambertMaterial({color:0x8b2500});
  const mRoof=new THREE.MeshLambertMaterial({color:0x4a1200});
  const mMetal=new THREE.MeshLambertMaterial({color:0x555555});
  const mGlass=new THREE.MeshLambertMaterial({color:0x88ccff,transparent:true,opacity:0.4});
  add(new THREE.BoxGeometry(2.0,1.5,4.6),mBody,0,1.0,0);
  add(new THREE.BoxGeometry(2.1,0.25,4.7),mRoof,0,1.78,0);
  for(const wz of[-1.2,0,1.2]){
    add(new THREE.BoxGeometry(0.08,0.55,0.8),mGlass,-1.02,1.1,wz);
    add(new THREE.BoxGeometry(0.08,0.55,0.8),mGlass,1.02,1.1,wz);
  }
  add(new THREE.BoxGeometry(0.08,1.2,0.9),mGlass,-1.02,0.85,-1.8);
  add(new THREE.BoxGeometry(0.08,1.2,0.9),mGlass,1.02,0.85,-1.8);
  const wR=new THREE.Matrix4().makeRotationZ(Math.PI/2);
  const wG=new THREE.CylinderGeometry(0.28,0.28,0.22,12);wG.applyMatrix4(wR);
  for(const[wx,wz]of[[-1.05,-1.4],[1.05,-1.4],[-1.05,1.4],[1.05,1.4]]) add(wG.clone(),mMetal,wx,0.28,wz);
  add(new THREE.BoxGeometry(0.3,0.3,0.4),mMetal,0,0.6,-2.5);
  add(new THREE.BoxGeometry(0.3,0.3,0.4),mMetal,0,0.6,2.5);
  _attachTrainSprite(g,'[E] BOARD CARRIAGE');
  return g;
}

function _attachTrainSprite(g,text){
  const sc=document.createElement('canvas');sc.width=320;sc.height=48;
  const c2=sc.getContext('2d');c2.fillStyle='rgba(0,0,0,0)';c2.fillRect(0,0,320,48);
  c2.font='bold 13px monospace';c2.fillStyle='#ffd700';c2.textAlign='center';c2.fillText(text,160,30);
  const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(sc),depthTest:false}));
  spr.scale.set(4,0.6,1);spr.position.set(0,3.0,0);g.add(spr);g.userData.trainSprite=spr;
}

function buildTrain(){
  for(let i=0;i<TRAIN_CARS;i++){
    const mesh=i===0?_makeTrainLocomotive():_makeTrainCarriage();
    const startOff=i*2.5;
    const t=(trainProgress-startOff%TRAIN_ROUTE.length+TRAIN_ROUTE.length)%TRAIN_ROUTE.length;
    const pt=_trainRoutePoint(t);
    mesh.position.set(pt.x,0,pt.z);
    scene.add(mesh);
    trainMeshes.push({mesh,offset:startOff});
  }
}

function _trainRoutePoint(t){
  const N=TRAIN_ROUTE.length;
  const i=Math.floor(t)%N;
  const f=t-Math.floor(t);
  const a=TRAIN_ROUTE[i],b=TRAIN_ROUTE[(i+1)%N];
  return{x:a.x+(b.x-a.x)*f,z:a.z+(b.z-a.z)*f};
}

function updateTrain(){
  trainProgress=(trainProgress+TRAIN_SPEED)%TRAIN_ROUTE.length;
  const N=TRAIN_ROUTE.length;
  for(let i=0;i<trainMeshes.length;i++){
    const tm=trainMeshes[i];
    const t=((trainProgress-tm.offset)%N+N)%N;
    const pt=_trainRoutePoint(t);
    const pt2=_trainRoutePoint((t+0.5)%N);
    tm.mesh.position.set(pt.x,0,pt.z);
    tm.mesh.rotation.y=Math.atan2(pt.x-pt2.x,pt.z-pt2.z);
    const dx=camera.position.x-pt.x,dz=camera.position.z-pt.z;
    if(tm.mesh.userData.trainSprite) tm.mesh.userData.trainSprite.visible=(dx*dx+dz*dz<100);
  }
  if(inTrain){
    const tm=trainMeshes[trainCarIdx];
    const ang=tm.mesh.rotation.y;
    camera.position.set(tm.mesh.position.x+Math.sin(ang+0.4)*1.2,2.4,tm.mesh.position.z+Math.cos(ang+0.4)*1.2);
    camera.lookAt(tm.mesh.position.x-Math.sin(ang)*3,1.5,tm.mesh.position.z-Math.cos(ang)*3);
    document.getElementById('car-hud-name').textContent=trainCarIdx===0?'LOCOMOTIVE':'CARRIAGE';
    document.getElementById('car-hud-speed').textContent=Math.round(TRAIN_SPEED*600)+' KM/H';
    _promptEl.style.display='none';
  }
}

function checkAndBoardTrain(){
  if(inTrain||inCar||onHorse) return;
  for(let i=0;i<trainMeshes.length;i++){
    const tm=trainMeshes[i];
    const dx=camera.position.x-tm.mesh.position.x,dz=camera.position.z-tm.mesh.position.z;
    if(dx*dx+dz*dz<9){
      _promptEl.style.display='block';
      _promptEl.textContent='[ E ] BOARD TRAIN';
      window._nearTrainIdx=i;
      return;
    }
  }
  window._nearTrainIdx=-1;
}

function boardTrain(carIdx){
  inTrain=true;trainCarIdx=carIdx;
  document.getElementById('car-hud').style.display='block';
  document.getElementById('car-exit-hint').style.display='block';
  document.exitPointerLock();
  document.getElementById('click-hint').style.display='none';
  addChatMessage('','// üöÇ BOARDED TRAIN ‚Äî [F] TO EXIT //',false,true);
}

function exitTrain(){
  if(!inTrain) return;
  inTrain=false;
  const tm=trainMeshes[trainCarIdx];
  const ang=tm.mesh.rotation.y;
  camera.position.set(tm.mesh.position.x+Math.sin(ang+Math.PI/2)*3,GROUND_Y,tm.mesh.position.z+Math.cos(ang+Math.PI/2)*3);
  pitch=0;yaw=ang;
  document.getElementById('car-hud').style.display='none';
  document.getElementById('car-exit-hint').style.display='none';
  renderer.domElement.requestPointerLock();
}

// ============================================================================
//  HORSE SYSTEM
// ============================================================================
const HORSE_DEFS={
  mare:    {name:'MARE',    color:0x8b4513,maneColor:0x3d1c00,cost:3000, maxSpeed:0.50,accel:0.015,turnRate:0.055,friction:0.92,icon:'üê¥'},
  stallion:{name:'STALLION',color:0x1a1a1a,maneColor:0x111111,cost:8000, maxSpeed:0.65,accel:0.018,turnRate:0.048,friction:0.93,icon:'üêé'},
  warhorse:{name:'WARHORSE',color:0xc0c0c0,maneColor:0x888888,cost:25000,maxSpeed:0.80,accel:0.022,turnRate:0.052,friction:0.94,icon:'üèá'},
};
const ownedHorses={mare:false,stallion:false,warhorse:false};
const parkedHorses=[];
const HORSE_STABLE_X=TRACK_CX-TRACK_A-10;
const HORSE_STABLE_Z=TRACK_CZ;
const HORSE_SPOTS={
  mare:    {x:HORSE_STABLE_X,z:HORSE_STABLE_Z-8},
  stallion:{x:HORSE_STABLE_X,z:HORSE_STABLE_Z},
  warhorse:{x:HORSE_STABLE_X,z:HORSE_STABLE_Z+8},
};
let onHorse=false,activeHorse=null;
let horsePos=new THREE.Vector3(),horseAngle=0,horseSpeed=0,horseBobT=0;
let horseDealerOpen=false,horseDealerInteractable=false,horseDealerMesh=null;
const HORSE_DEALER_NPC_X=HORSE_STABLE_X;
const HORSE_DEALER_NPC_Z=HORSE_STABLE_Z+16;

function makeHorseMesh(def){
  const g=new THREE.Group();
  const add=(geo,mat,x,y,z)=>{const m=new THREE.Mesh(geo,mat);m.position.set(x,y,z);g.add(m);return m;};
  const mBody=new THREE.MeshLambertMaterial({color:def.color});
  const mMane=new THREE.MeshLambertMaterial({color:def.maneColor});
  const mEye=new THREE.MeshBasicMaterial({color:0x111111});
  const mHoof=new THREE.MeshLambertMaterial({color:0x222222});
  const mSadd=new THREE.MeshLambertMaterial({color:0x8b3a00});
  add(new THREE.BoxGeometry(0.80,0.75,1.90),mBody,0,1.10,0);
  add(new THREE.BoxGeometry(0.38,0.72,0.36),mBody,0,1.68,-0.72);
  add(new THREE.BoxGeometry(0.30,0.44,0.70),mBody,0,2.0,-1.0);
  add(new THREE.BoxGeometry(0.22,0.28,0.30),mBody,0,1.84,-1.34);
  add(new THREE.BoxGeometry(0.08,0.18,0.08),mMane,-0.12,2.26,-0.95);
  add(new THREE.BoxGeometry(0.08,0.18,0.08),mMane,0.12,2.26,-0.95);
  add(new THREE.BoxGeometry(0.06,0.06,0.04),mEye,-0.16,2.04,-1.26);
  add(new THREE.BoxGeometry(0.06,0.06,0.04),mEye,0.16,2.04,-1.26);
  add(new THREE.BoxGeometry(0.18,0.40,0.60),mMane,0,2.12,-0.78);
  add(new THREE.BoxGeometry(0.18,0.50,0.22),mMane,0,1.22,1.02);
  add(new THREE.BoxGeometry(0.14,0.40,0.18),mMane,0.05,0.82,1.16);
  add(new THREE.BoxGeometry(0.70,0.18,0.80),mSadd,0,1.52,-0.05);
  add(new THREE.BoxGeometry(0.14,0.28,0.08),mSadd,-0.36,1.38,0.00);
  add(new THREE.BoxGeometry(0.14,0.28,0.08),mSadd,0.36,1.38,0.00);
  // Legs ‚Äî stored so we can animate them
  const legGeo=new THREE.BoxGeometry(0.18,0.70,0.18);
  const lowerGeo=new THREE.BoxGeometry(0.15,0.60,0.15);
  const hoofGeo=new THREE.BoxGeometry(0.20,0.12,0.26);
  g.userData.legs=[];
  for(const[lx,lz]of[[-0.27,-0.55],[0.27,-0.55],[-0.27,0.55],[0.27,0.55]]){
    const upper=add(legGeo.clone(),mBody,lx,0.65,lz);
    add(lowerGeo.clone(),mBody,lx,0.08,lz);
    add(hoofGeo.clone(),mHoof,lx,-0.22,lz+0.04);
    g.userData.legs.push(upper);
  }
  // Prompt sprite
  const sc=document.createElement('canvas');sc.width=300;sc.height=48;
  const c2=sc.getContext('2d');c2.fillStyle='rgba(0,0,0,0)';c2.fillRect(0,0,300,48);
  c2.font='bold 13px monospace';c2.fillStyle='#ffd700';c2.textAlign='center';
  c2.fillText('[E] RIDE ‚Äî '+def.name,150,30);
  const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(sc),depthTest:false}));
  spr.scale.set(3.5,0.55,1);spr.position.set(0,2.6,0);g.add(spr);g.userData.enterSprite=spr;
  return g;
}

function spawnParkedHorse(key){
  const old=parkedHorses.find(h=>h.key===key);
  if(old){scene.remove(old.mesh);parkedHorses.splice(parkedHorses.indexOf(old),1);}
  const def=HORSE_DEFS[key];
  const spot=HORSE_SPOTS[key];
  const mesh=makeHorseMesh(def);
  mesh.position.set(spot.x,0,spot.z);
  mesh.rotation.y=Math.PI/2;
  scene.add(mesh);
  parkedHorses.push({mesh,key,def,spot});
}

async function buyHorse(key){
  const def=HORSE_DEFS[key];
  if(!def||ownedHorses[key]) return;
  if(coins<def.cost) return;

  // ‚îÄ‚îÄ Server-side economy validation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const _res = await callEdgeFn('validate-action', {
    action: 'buy_horse', username: accountUsername, item: key
  });
  if(!_res || !_res.success){
    if(_res && typeof _res.coins === 'number') coins = _res.coins;
    updateHUD(); refreshHorseDealerUI(); return;
  }
  coins = _res.coins;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  ownedHorses[key]=true;
  updateHUD();spawnParkedHorse(key);savePlayerState();
  addChatMessage('','// üêé '+def.name+' PURCHASED ‚Äî FIND IT AT THE STABLE! //',false,true);
  refreshHorseDealerUI();
}

function mountHorse(parked){
  onHorse=true;activeHorse=parked;
  horsePos.copy(parked.mesh.position);
  horseAngle=parked.mesh.rotation.y;horseSpeed=0;horseBobT=0;
  parkedHorses.splice(parkedHorses.indexOf(parked),1);
  if(parked.mesh.userData.enterSprite) parked.mesh.userData.enterSprite.visible=false;
  document.getElementById('car-hud').style.display='block';
  document.getElementById('car-exit-hint').style.display='block';
  document.getElementById('car-hud-name').textContent=parked.def.name;
  document.exitPointerLock();
  document.getElementById('click-hint').style.display='none';
}

function dismountHorse(){
  if(!onHorse||!activeHorse) return;
  onHorse=false;
  activeHorse.mesh.position.copy(horsePos);activeHorse.mesh.position.y=0;
  activeHorse.mesh.rotation.y=horseAngle;
  if(activeHorse.mesh.userData.enterSprite) activeHorse.mesh.userData.enterSprite.visible=true;
  parkedHorses.push(activeHorse);activeHorse=null;horseSpeed=0;
  camera.position.set(horsePos.x+Math.sin(horseAngle+Math.PI/2)*2.5,GROUND_Y,horsePos.z+Math.cos(horseAngle+Math.PI/2)*2.5);
  pitch=0;yaw=horseAngle;
  document.getElementById('car-hud').style.display='none';
  document.getElementById('car-exit-hint').style.display='none';
  renderer.domElement.requestPointerLock();
}

function updateHorse(){
  if(!onHorse||!activeHorse) return;
  const def=activeHorse.def;
  if(keys['KeyW']||keys['ArrowUp']){horseSpeed+=def.accel;if(horseSpeed>def.maxSpeed)horseSpeed=def.maxSpeed;}
  else if(keys['KeyS']||keys['ArrowDown']){horseSpeed-=def.accel*1.2;if(horseSpeed<-def.maxSpeed*0.3)horseSpeed=-def.maxSpeed*0.3;}
  horseSpeed*=def.friction;
  if(Math.abs(horseSpeed)<0.0005)horseSpeed=0;
  if(Math.abs(horseSpeed)>0.005){
    const sd=horseSpeed>0?1:-1;
    if(keys['KeyA']||keys['ArrowLeft'])  horseAngle+=def.turnRate*sd;
    if(keys['KeyD']||keys['ArrowRight']) horseAngle-=def.turnRate*sd;
  }
  horsePos.x-=Math.sin(horseAngle)*horseSpeed;
  horsePos.z-=Math.cos(horseAngle)*horseSpeed;
  horsePos.x=Math.max(-240,Math.min(240,horsePos.x));
  horsePos.z=Math.max(-310,Math.min(200,horsePos.z));
  horseBobT+=Math.abs(horseSpeed)*30;
  const bobY=Math.abs(horseSpeed)>0.01?Math.abs(Math.sin(horseBobT))*0.18:0;
  activeHorse.mesh.position.set(horsePos.x,bobY,horsePos.z);
  activeHorse.mesh.rotation.y=horseAngle;
  // Animate legs
  if(activeHorse.mesh.userData.legs&&Math.abs(horseSpeed)>0.01){
    const legs=activeHorse.mesh.userData.legs;
    legs[0].rotation.x=Math.sin(horseBobT)*0.6;
    legs[1].rotation.x=-Math.sin(horseBobT)*0.6;
    legs[2].rotation.x=-Math.sin(horseBobT)*0.5;
    legs[3].rotation.x=Math.sin(horseBobT)*0.5;
  }
  const camDist=5.5,camH=2.8;
  camera.position.set(horsePos.x+Math.sin(horseAngle)*camDist,camH,horsePos.z+Math.cos(horseAngle)*camDist);
  _carLookTarget.set(horsePos.x-Math.sin(horseAngle)*2,1.2,horsePos.z-Math.cos(horseAngle)*2);
  camera.lookAt(_carLookTarget);
  const kmh=Math.round(Math.abs(horseSpeed)/def.maxSpeed*60);
  document.getElementById('car-hud-speed').textContent=kmh+' KM/H';
  _promptEl.style.display='none';
}

function updateHorseProximity(){
  if(onHorse||inCar||inTrain) return;
  for(const h of parkedHorses){
    const dx=camera.position.x-h.mesh.position.x,dz=camera.position.z-h.mesh.position.z;
    if(dx*dx+dz*dz<9){_promptEl.style.display='block';_promptEl.textContent='[ E ] RIDE '+h.def.name;window._nearHorse=h;return;}
  }
  window._nearHorse=null;
}

function buildHorseStable(){
  const bx=HORSE_STABLE_X,bz=HORSE_STABLE_Z;
  const mat=new THREE.MeshLambertMaterial({color:0x8b5a2b});
  const roofM=new THREE.MeshLambertMaterial({color:0x5a2d00});
  const stall=new THREE.MeshLambertMaterial({color:0x6b3a1a});
  const addM=(geo,m,x,y,z)=>{const mesh=new THREE.Mesh(geo,m);mesh.position.set(x,y,z);scene.add(mesh);};
  addM(new THREE.BoxGeometry(5,2.8,0.25),mat,bx,1.4,bz-14);
  addM(new THREE.BoxGeometry(5,2.8,0.25),mat,bx,1.4,bz+14);
  addM(new THREE.BoxGeometry(0.25,2.8,28),mat,bx-2.6,1.4,bz);
  for(const dz of[-4,4]) addM(new THREE.BoxGeometry(5,1.6,0.14),stall,bx,0.95,bz+dz);
  addM(new THREE.BoxGeometry(5.4,0.3,28.4),roofM,bx,2.95,bz);
  const sc=document.createElement('canvas');sc.width=256;sc.height=48;
  const c2=sc.getContext('2d');c2.fillStyle='#3d1c00';c2.fillRect(0,0,256,48);
  c2.strokeStyle='#cc8800';c2.lineWidth=3;c2.strokeRect(4,4,248,40);
  c2.font='bold 18px serif';c2.fillStyle='#ffcc44';c2.textAlign='center';c2.fillText('HORSE STABLE',128,32);
  const sp=new THREE.Mesh(new THREE.PlaneGeometry(4,0.8),new THREE.MeshBasicMaterial({map:new THREE.CanvasTexture(sc),transparent:true}));
  sp.position.set(bx,2.2,bz-14.15);scene.add(sp);
}

function buildHorseDealerNPC(){
  const g=new THREE.Group();
  const add=(geo,mat,x,y,z)=>{const m=new THREE.Mesh(geo,mat);m.position.set(x,y,z);g.add(m);};
  const mSkin=new THREE.MeshLambertMaterial({color:0xd4a070});
  const mCloth=new THREE.MeshLambertMaterial({color:0x5a3010});
  const mHat=new THREE.MeshLambertMaterial({color:0x2a1400});
  add(new THREE.BoxGeometry(0.42,0.40,0.38),mSkin,0,1.42,0);
  add(new THREE.CylinderGeometry(0.28,0.28,0.12,10),mHat,0,1.66,0);
  add(new THREE.CylinderGeometry(0.16,0.22,0.28,10),mHat,0,1.80,0);
  add(new THREE.BoxGeometry(0.50,0.60,0.32),mCloth,0,0.80,0);
  add(new THREE.BoxGeometry(0.48,0.26,0.30),mCloth,0,0.43,0);
  for(const sx of[-1,1]){
    add(new THREE.BoxGeometry(0.22,0.50,0.26),mCloth,sx*0.13,0.08,0);
    add(new THREE.BoxGeometry(0.22,0.48,0.22),mCloth,sx*0.36,0.78,0);
    add(new THREE.BoxGeometry(0.20,0.30,0.20),mSkin,sx*0.36,0.42,0);
  }
  const pl=new THREE.PointLight(0xffaa44,0.7,5);pl.position.set(0,2.2,0);g.add(pl);
  g.userData.bobT=0;g.userData.light=pl;
  horseDealerMesh=g;
  g.position.set(HORSE_DEALER_NPC_X,0.10,HORSE_DEALER_NPC_Z);
  g.rotation.y=Math.PI/2;
  scene.add(g);
  const lbl=makeNameSprite('HORSE DEALER');
  lbl.position.set(HORSE_DEALER_NPC_X,2.8,HORSE_DEALER_NPC_Z);scene.add(lbl);
}

function updateHorseDealerNPC(){
  if(!horseDealerMesh) return;
  horseDealerMesh.userData.bobT+=0.022;
  horseDealerMesh.position.y=0.10+Math.sin(horseDealerMesh.userData.bobT)*0.008;
  horseDealerMesh.userData.light.intensity=0.7+Math.sin(horseDealerMesh.userData.bobT*2)*0.2;
  const dx=camera.position.x-HORSE_DEALER_NPC_X,dz=camera.position.z-HORSE_DEALER_NPC_Z;
  const near=dx*dx+dz*dz<SHOP_INTERACT_DIST*SHOP_INTERACT_DIST*1.8;
  if(near!==horseDealerInteractable){
    horseDealerInteractable=near;
    if(near&&!inCar&&!onHorse&&!inTrain) _promptEl.textContent='[ E ] HORSE DEALER';
  }
}

function openHorseDealer(){
  if(horseDealerOpen) return;
  horseDealerOpen=true;
  document.exitPointerLock();
  document.getElementById('horse-dealer-screen').classList.add('active');
  refreshHorseDealerUI();
}
function closeHorseDealer(){
  horseDealerOpen=false;
  document.getElementById('horse-dealer-screen').classList.remove('active');
  renderer.domElement.requestPointerLock();
}
function refreshHorseDealerUI(){
  document.getElementById('horse-dealer-coins').textContent=coins;
  document.querySelectorAll('.horse-card').forEach(el=>{
    const key=el.dataset.horse;if(!key||!HORSE_DEFS[key]) return;
    el.classList.remove('owned','cant-afford');
    const costEl=el.querySelector('.horse-card-cost');
    if(ownedHorses[key]){el.classList.add('owned');if(costEl)costEl.textContent='‚úì OWNED ‚Äî AT THE STABLE';}
    else{if(costEl)costEl.textContent='‚¨° '+HORSE_DEFS[key].cost.toLocaleString()+' COINS';if(coins<HORSE_DEFS[key].cost)el.classList.add('cant-afford');}
  });
}


// ============================================================================
//  PLAYER STATE
// ============================================================================
let myHp=100, kills=0, deaths=0, pvpKills=0, dead=false;
const MAX_HP=100;
let myName = ''; // set after login
let accountUsername = ''; // the login username (separate from callsign)

// ============================================================================
//  COLLISION
// ============================================================================
const PR = 0.5;

// Collision ‚Äî inline abs, cache pos components to avoid repeated property lookup
function checkEnvCol(pos){
  const px=pos.x, pz=pos.z;
  for(const c of colliders){
    if(c.type==='box'){
      const dx=px-c.x, dz=pz-c.z;
      if((dx<0?-dx:dx)<c.hw+PR && (dz<0?-dz:dz)<c.hd+PR) return true;
    } else {
      const dx=px-c.x, dz=pz-c.z;
      if(dx*dx+dz*dz<(c.r+PR)*(c.r+PR)) return true;
    }
  }
  return false;
}
function checkWallCol(pos){
  const px=pos.x, pz=pos.z, py=pos.y;
  for(const c of wallColliders){
    if(py<c.yMin||py>c.yMax) continue;
    const dx=px-c.x, dz=pz-c.z;
    if((dx<0?-dx:dx)<c.hw+PR && (dz<0?-dz:dz)<c.hd+PR) return true;
  }
  return false;
}

// Player collision = env + walls
function checkCollision(pos){ return checkEnvCol(pos) || checkWallCol(pos); }

// Bullet collision = env only (bullets travel through windows freely)
function checkBulletCol(pos){ return checkEnvCol(pos); }

// ============================================================================
//  JUMP & GRAVITY
// ============================================================================
const JUMP_FORCE=0.28, GRAVITY=-0.015;
let velY=0, onGround=true;

// ============================================================================
//  CHAT STATE
// ============================================================================
let chatOpen = false;
const MAX_MESSAGES = 30;

// ============================================================================
//  CONTROLS (LOOK, MOVE, CHAT, WEAPON SWITCH)
// ============================================================================
let yaw=0, pitch=0;
const keys={};

renderer.domElement.addEventListener('click', () => {
  if (!chatOpen && myName) renderer.domElement.requestPointerLock();
});
document.addEventListener('pointerlockchange', () => {
  const locked = !!document.pointerLockElement;
  document.getElementById('click-hint').style.display = locked ? 'none' : 'block';
  // Browser releases pointer lock on ESC ‚Äî treat that as pause (not when in car)
  if (!locked && !paused && !chatOpen && !dead && myName && !inCar && !invOpen) {
    pauseGame();
  }
});
document.addEventListener('mousemove', e => {
  if (!document.pointerLockElement || dead || chatOpen || inCar) return;
  yaw   -= e.movementX * 0.002;
  pitch -= e.movementY * 0.002;
  pitch = Math.max(-1.2, Math.min(1.2, pitch));
  camera.rotation.x = pitch;
  camera.rotation.y = yaw;
});

document.addEventListener('keydown', e => {
  // If auth modal is visible, let all keys through to the input fields
  if (!document.getElementById('auth-modal').classList.contains('hidden')) return;

  // If admin console is open and an input/select is focused, let all keys through
  if (_adminConsoleOpen && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT')) return;
  // If chat is open, only handle Enter/Escape
  if (chatOpen) {
    if (e.code === 'Enter')  { e.preventDefault(); sendChat(); }
    if (e.code === 'Escape') { e.preventDefault(); closeChat(); }
    return;
  }

  keys[e.code] = true;

  if (e.code === 'Space')  { e.preventDefault(); if(!e.repeat) tryJump(); }
  if (e.code === 'ControlLeft' || e.code === 'ControlRight') { e.preventDefault(); }
  // Block browser shortcuts that fire when Ctrl-sprinting + strafing
  if (e.ctrlKey && !chatOpen) { e.preventDefault(); }
  if (e.code === 'KeyT')   { e.preventDefault(); openChat(); }
  if (e.code === 'Escape') { e.preventDefault(); if(_adminConsoleOpen){ closeAdminConsole(); return; } if(invOpen){ closeInventory(); return; } if(shopOpen){ closeShop(); return; } if(carDealerOpen){ closeCarDealer(); return; } if(horseDealerOpen){ closeHorseDealer(); return; } if(weaponsmithOpen){ closeWeaponsmith(); return; } const _rb=document.getElementById('rebirth-screen'); if(_rb&&_rb.classList.contains('active')){ closeRebirthScreen(); return; } const _bs=document.getElementById('boss-screen'); if(_bs&&_bs.classList.contains('active')){ closeBossScreen(); return; } const _bh=document.getElementById('bounty-handler-screen'); if(_bh&&_bh.classList.contains('active')){ closeBountyHandlerScreen(); return; } if(!inCar&&!onHorse&&!inTrain) pauseGame(); }

  // Keys 1‚Äì6: equip/use whatever is in that hotbar slot.
  // Switching to an empty slot clears the equipped weapon instead of keeping the last gun.
  for(let _dk=1;_dk<=6;_dk++){
    if(e.code==='Digit'+_dk){
      const _hs = hotbar[_dk-1];
      if(_hs && INV_ITEMS[_hs.id] && INV_ITEMS[_hs.id].isWeapon) setWeapon(INV_ITEMS[_hs.id].weaponKey);
      else if(_hs && !INV_ITEMS[_hs.id]?.isWeapon) useHotbarSlot(_dk-1); // consumable ‚Äî use it
      else clearWeapon(); // empty slot ‚Äî unequip
      renderHotbar();
    }
  }
  if (e.code === 'KeyG' && !chatOpen) { e.preventDefault(); detonateC4(); }
  if (e.code === 'KeyE' && !chatOpen) {
    e.preventDefault();
    // Enter nearby car
    const _nearCar = parkedCars.find(c=>{ const dx=camera.position.x-c.mesh.position.x,dz=camera.position.z-c.mesh.position.z; return dx*dx+dz*dz<9; });
    if(_nearCar && !shopOpen && !carDealerOpen){ enterCar(_nearCar); return; }
    // Board nearby train
    const _nearTrainCar = (typeof trainMeshes!=='undefined') ? trainMeshes.findIndex(tm=>{ const dx=camera.position.x-tm.mesh.position.x,dz=camera.position.z-tm.mesh.position.z; return dx*dx+dz*dz<16; }) : -1;
    if(_nearTrainCar>=0 && !shopOpen && !inTrain){ boardTrain(_nearTrainCar); return; }
    // Mount nearby horse
    const _nearHorse = (typeof parkedHorses!=='undefined') ? parkedHorses.find(h=>{ const dx=camera.position.x-h.mesh.position.x,dz=camera.position.z-h.mesh.position.z; return dx*dx+dz*dz<9; }) : null;
    if(_nearHorse && !shopOpen && !onHorse){ mountHorse(_nearHorse); return; }
    // Car dealer
    if(carDealerInteractable && !shopOpen && !carDealerOpen){ openCarDealer(); return; }
    // Horse dealer
    if(horseDealerInteractable && !shopOpen && !horseDealerOpen){ openHorseDealer(); return; }
    // Weaponsmith
    if(weaponsmithInteractable && !shopOpen && !weaponsmithOpen){ openWeaponsmith(); return; }
    // Other NPCs
    const _rbs=document.getElementById('rebirth-screen'); const _bss=document.getElementById('boss-screen'); const _bhs=document.getElementById('bounty-handler-screen');
    if(rebirthNPCInteractable && !shopOpen && !_rbs?.classList.contains('active')){ openRebirthScreen(); }
    else if(bossNPCInteractable && !shopOpen && !_bss?.classList.contains('active')){ openBossScreen(); }
    else if(bountyHandlerInteractable && !shopOpen && !_bhs?.classList.contains('active')){ openBountyHandlerScreen(); }
    else if(merchantInteractable && !shopOpen){ openShop(); }
  }
  if (e.code === 'KeyF' && !chatOpen) {
    e.preventDefault();
    if(inCar) exitCar();
    else if(inTrain) exitTrain();
    else if(onHorse) dismountHorse();
  }
  if (e.code === 'Tab' && !chatOpen) { e.preventDefault(); showPlayerList(); }
  if (e.code === 'Backquote' && !chatOpen) {
    // No local isAdmin pre-check ‚Äî openAdminConsole() does mandatory server verify.
    // Pressing backtick as a non-admin just gets a '‚õî NOT AUTHORISED' flash.
    e.preventDefault();
    _adminConsoleOpen ? closeAdminConsole() : openAdminConsole();
  }
  if (e.code === 'KeyI' && !chatOpen && !shopOpen && !weaponsmithOpen) { e.preventDefault(); invOpen ? closeInventory() : openInventory(); }

  // Unscope on any movement so you can't sprint+snipe
  if (scoped && (e.code==='KeyW'||e.code==='KeyA'||e.code==='KeyS'||e.code==='KeyD'||e.code==='Space')) {
    setScope(false);
  }
});

document.addEventListener('keyup', e => {
  if (!chatOpen) keys[e.code] = false;
  if (e.code === 'Tab') hidePlayerList();
});

// ============================================================================
//  CHAT FUNCTIONS
// ============================================================================
function openChat() {
  if (!myName) return;
  chatOpen = true;
  document.exitPointerLock();
  const row = document.getElementById('chat-input-row');
  row.classList.add('open');
  document.getElementById('chat-hint').classList.add('hidden');
  setTimeout(() => document.getElementById('chat-input').focus(), 30);
}

function closeChat() {
  chatOpen = false;
  const row = document.getElementById('chat-input-row');
  row.classList.remove('open');
  document.getElementById('chat-hint').classList.remove('hidden');
  document.getElementById('chat-input').value = '';
  renderer.domElement.requestPointerLock();
}


// ============================================================================
//  CONTENT FILTER
// ============================================================================
// Normalise leet-speak + homoglyphs before matching
function _normStr(str){
  return str.toLowerCase()
    .replace(/[@4]/g,'a').replace(/[8]/g,'b').replace(/[<(]/g,'c')
    .replace(/[3]/g,'e').replace(/[6]/g,'g').replace(/[!1|]/g,'i')
    .replace(/[0]/g,'o').replace(/[9]/g,'q').replace(/[\$5]/g,'s')
    .replace(/[7]/g,'t').replace(/[vv]/g,'w').replace(/[2]/g,'z')
    .replace(/[^a-z]/g,''); // strip remaining non-alpha for matching
}

// Core banned terms ‚Äî normalised forms only, no spaces needed
const _BANNED = [
  'fuck','fuk','fck','shit','shyt','cunt','cock','dick','pussy','ass','arse',
  'nigger','nigga','niger','chink','spick','spic','kike','wetback','faggot',
  'fag','tranny','retard','bitch','bastard','whore','slut','piss','prick',
  'twat','wank','wanker','tosser','bollocks','motherfucker','motherfukr',
  'asshole','arsehole','dumbass','jackass','dipshit','bullshit','horseshit',
  'goddamn','goddam','jesus','christ','nazi','nonce','pedo','pedophile',
  'rapist','rape','genocide','terrorist','kill yourself','kys','kys',
  'sexuallyexplicit','sexuallyexplict',
];

// Returns true if the string contains a banned term
function _hasBannedWord(str){
  const norm = _normStr(str);
  return _BANNED.some(w => norm.includes(w));
}

// Censor a chat message ‚Äî replace each banned word with asterisks
// Works on the original string, masking matched substrings
function censorText(str){
  let out = str;
  // Build a regex for each banned word that matches leet variants in original
  // Simple approach: check per-word spans of the normalised string and mask them
  const words = out.split(/\s+/);
  return words.map(word => {
    if(_hasBannedWord(word)){
      // Keep first + last letter visible for short words, fully mask longer ones
      const l = word.length;
      if(l <= 2) return '*'.repeat(l);
      return word[0] + '*'.repeat(l-2) + word[l-1];
    }
    return word;
  }).join(' ');
}

// Validate a callsign ‚Äî returns error string or empty string if OK
function validateCallsign(name){
  if(!name || name.length < 2) return 'Name must be at least 2 characters.';
  if(_hasBannedWord(name)) return 'That name is not allowed.';
  return '';
}

// Chat rate limiter ‚Äî max 3 messages per 5 seconds to prevent chat flood attacks
const _CHAT_MAX    = 3;
const _CHAT_WINDOW = 5000;
let _chatTimes = [];

function sendChat() {
  const input = document.getElementById('chat-input');
  const text = input.value.trim();
  if (!text) { closeChat(); return; }

  // Rate limit check
  const now = Date.now();
  _chatTimes = _chatTimes.filter(t => now - t < _CHAT_WINDOW);
  if (_chatTimes.length >= _CHAT_MAX) {
    showFloatPop('‚ö† SLOW DOWN', '#ff4444');
    closeChat();
    return;
  }
  _chatTimes.push(now);

  input.value = '';

  const censored = censorText(text);
  addChatMessage(myName, censored, true);

  if (gameChannel) _chanSend({
    type: 'broadcast', event: 'chat',
    payload: { name: myName, text: censored, sender: playerId }
  });

  closeChat();
}

function addChatMessage(name, text, isMine, isSystem) {
  const box = document.getElementById('chat-messages');
  const div = document.createElement('div');
  div.className = 'chat-msg' + (isMine ? ' mine' : '') + (isSystem ? ' system' : '');

  if (isSystem) {
    div.textContent = text;
  } else {
    const nameSpan = document.createElement('span');
    nameSpan.className = 'chat-name';
    nameSpan.textContent = name + ':';
    div.appendChild(nameSpan);
    div.appendChild(document.createTextNode(text));
  }

  box.appendChild(div);

  while (box.children.length > MAX_MESSAGES) box.removeChild(box.firstChild);
  box.scrollTop = box.scrollHeight;

  setTimeout(() => {
    if (!chatOpen) {
      div.style.transition = 'opacity 1s';
      div.style.opacity = '0';
      setTimeout(() => div.remove(), 1000);
    }
  }, 8000);
}

// ============================================================================
//  NAME MODAL
// ============================================================================
// ============================================================================
//  ACCOUNT SYSTEM
// ============================================================================

// SHA-256 via SubtleCrypto (returns hex string)
async function sha256(str){
  const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

// Validate username: alphanumeric + _ only
function validUsername(u){ return /^[A-Za-z0-9_]{2,20}$/.test(u); }

function authError(msg){ document.getElementById('auth-error').textContent = msg; }
function authError2(msg){ document.getElementById('auth-error2').textContent = msg; }

function authShowRegisterHint(){
  document.getElementById('auth-error').textContent = '';
  document.getElementById('auth-login-btn').textContent = '‚ñ∂ LOGIN';
  document.getElementById('auth-reg-btn').style.background = 'rgba(0,255,0,0.12)';
  document.getElementById('auth-reg-btn').style.color = '#0f0';
  authError('Fill in a new username + password and click CREATE ACCOUNT');
}

// Stored pending account data between step1 and step2
let _pendingAccount = null; // { username, passwordHash, existingData }

function togglePassVis(){
  const inp = document.getElementById('auth-pass');
  const btn = document.getElementById('pass-eye-btn');
  if(inp.type === 'password'){
    inp.type = 'text';
    btn.style.color = '#0f0';
    btn.style.textShadow = '0 0 6px #0f0';
  } else {
    inp.type = 'password';
    btn.style.color = '';
    btn.style.textShadow = '';
  }
}
async function authLogin(){
  const u = document.getElementById('auth-user').value.trim();
  const p = document.getElementById('auth-pass').value;
  authError('');

  // ‚îÄ‚îÄ HACK TERMINAL ‚Äî username HACKTERM with empty password ‚îÄ‚îÄ
  if(u.toUpperCase()==='HACKTERM' && p===''){
    showHackTerminal();
    return;
  }

  if(!u || !p){ authError('Enter username and password.'); return; }
  if(!validUsername(u)){ authError('Username: 2‚Äì20 chars, letters/numbers/_ only.'); return; }
  if(!db){ authError('Database unavailable.'); return; }

  const btn = document.getElementById('auth-login-btn');
  btn.disabled = true; btn.textContent = 'CHECKING...';

  try {
    const hash = await sha256(p);
    const { data, error } = await db.from('accounts').select('*').eq('username', u).single();
    if(error || !data){ authError('Account not found. Create one first.'); btn.disabled=false; btn.textContent='‚ñ∂ LOGIN'; return; }
    if(data.password_hash !== hash){ authError('Incorrect password.'); btn.disabled=false; btn.textContent='‚ñ∂ LOGIN'; return; }
    // Success ‚Äî go to step 2 with loaded data
    _pendingAccount = { username: u, passwordHash: hash, existingData: data };
    document.getElementById('auth-callsign').value = data.soldier_name || 'SOLDIER';
    showAuthStep2();
  } catch(e) {
    authError('Connection error. Check Supabase setup.'); console.error(e);
    btn.disabled=false; btn.textContent='‚ñ∂ LOGIN';
  }
}

async function authRegister(){
  const u = document.getElementById('auth-user').value.trim();
  const p = document.getElementById('auth-pass').value;
  authError('');
  if(!u || !p){ authError('Enter username and password.'); return; }
  if(!validUsername(u)){ authError('Username: 2‚Äì20 chars, letters/numbers/_ only.'); return; }
  if(p.length < 6){ authError('Password must be at least 6 characters.'); return; }
  if(!db){ authError('Database unavailable.'); return; }

  const btn = document.getElementById('auth-reg-btn');
  btn.disabled = true; btn.textContent = 'CREATING...';

  try {
    const hash = await sha256(p);
    // Check if username already taken
    const { data: existing } = await db.from('accounts').select('username').eq('username', u).single();
    if(existing){ authError('Username already taken. Choose another.'); btn.disabled=false; btn.textContent='+ CREATE ACCOUNT'; return; }
    // Create account with defaults
    const { error } = await db.from('accounts').insert({
      username: u, password_hash: hash, soldier_name: 'SOLDIER',
      updated_at: new Date().toISOString()
    });
    if(error){ authError('Could not create account: ' + error.message); btn.disabled=false; btn.textContent='+ CREATE ACCOUNT'; return; }
    _pendingAccount = { username: u, passwordHash: hash, existingData: null };
    document.getElementById('auth-callsign').value = '';
    showAuthStep2();
  } catch(e) {
    authError('Connection error. Check Supabase setup.'); console.error(e);
    btn.disabled=false; btn.textContent='+ CREATE ACCOUNT';
  }
}

function showAuthStep2(){
  document.getElementById('auth-step1').style.display = 'none';
  document.getElementById('auth-step2').style.display = 'block';
  document.getElementById('auth-error2').textContent = '';
  setTimeout(()=>document.getElementById('auth-callsign').focus(), 60);
}

async function authDeploy(){
  const raw = document.getElementById('auth-callsign').value.trim().toUpperCase().replace(/[^A-Z0-9_\-]/g,'');
  const callsign = raw || 'SOLDIER';
  const _nameErr = validateCallsign(callsign);
  if(_nameErr){ authError2(_nameErr); return; }
  authError2('');

  const btn = document.getElementById('auth-deploy-btn');
  btn.disabled=true; btn.textContent='DEPLOYING...';

  // Save callsign to account
  if(db && _pendingAccount){
    await db.from('accounts').update({
      soldier_name: callsign, updated_at: new Date().toISOString()
    }).eq('username', _pendingAccount.username);
  }

  accountUsername = _pendingAccount ? _pendingAccount.username : 'unknown';
  // isAdmin is verified server-side ‚Äî setting isAdmin=true in the console
  // does nothing because apcSet and admin-action both re-verify against the DB.
  _setIsAdmin(false); // default false, confirmed below
  _setRealAdminUsername(accountUsername); // store now before any impersonation changes it
  callEdgeFn('admin-action', { adminUsername: accountUsername, action: 'verify' })
    .then(r => { if(r && r.ok && r.isAdmin) _setIsAdmin(true); })
    .catch(() => {});
  // Use a deterministic ID based on username so position syncs correctly across sessions
  playerId = await sha256(accountUsername); // 64-char hex ‚Äî stable per account
  myName = callsign;

  // Load saved state if returning player
  if(_pendingAccount && _pendingAccount.existingData){
    loadPlayerState(_pendingAccount.existingData);
  }

  document.getElementById('auth-modal').classList.add('hidden');
  addChatMessage('', '// AUTHENTICATED AS ' + accountUsername + ' ‚Äî CALLSIGN: ' + myName + ' //', false, true);

  // Start auto-save every 30 seconds
  setInterval(savePlayerState, 15000); // tightened from 30s ‚Äî cheated values corrected in ‚â§15s

  // ‚îÄ‚îÄ Runtime integrity watcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Runs every 3 seconds. Clamps any variables that have been pushed beyond
  // legitimate bounds via DevTools, and checks critical function references
  // haven't been replaced with noops.
  const _origTakeDamage      = takeDamage;
  const _origSavePlayerState = savePlayerState;
  const _origShoot           = shoot;
  const _origCallEdgeFn      = callEdgeFn;
  const _origOpenAdminConsole = openAdminConsole;
  const MAX_LEGIT_DMG_MULT   = 2000.0;
  const MAX_LEGIT_HP         = 200100; // MAX_HP + max maxHpBonus

  setInterval(function _integrityWatch(){
    // Clamp damage multiplier
    if(typeof damageMultiplier === 'number' && damageMultiplier > MAX_LEGIT_DMG_MULT){
      damageMultiplier = MAX_LEGIT_DMG_MULT;
      console.warn('[ANTICHEAT] damageMultiplier clamped');
    }
    // Clamp HP
    const _maxHp = MAX_HP + (typeof maxHpBonus==='number' ? maxHpBonus : 0);
    if(typeof myHp === 'number' && myHp > MAX_LEGIT_HP){
      myHp = Math.min(myHp, _maxHp);
      updateHUD();
      console.warn('[ANTICHEAT] myHp clamped');
    }
    // Clamp coins ‚Äî server-side cap is 20k/save but reject blatant overflows
    if(typeof coins === 'number' && coins > 1e9){
      coins = 1e9;
      console.warn('[ANTICHEAT] coins clamped');
    }
    if(typeof coins === 'number' && coins < 0){
      coins = 0;
    }
    // Kills / deaths sanity check: if they jumped by > 100 since last tick,
    // someone set them directly via console. Snap back to last known value.
    if(typeof _watchKills === 'undefined') { _watchKills = kills; _watchDeaths = deaths; }
    if(typeof kills === 'number' && kills - _watchKills > 100){
      console.warn('[ANTICHEAT] kills jump detected');
      kills = _watchKills;
    } else { _watchKills = kills; }
    if(typeof deaths === 'number' && deaths < 0){
      deaths = 0;
    } else { _watchDeaths = deaths; }
    // Detect if takeDamage has been replaced
    if(typeof takeDamage !== 'function' || takeDamage.toString() !== _origTakeDamage.toString()){
      // Silently restore. If attacker notices and re-patches, the save-state
      // server will reject any anomalous HP on the next 15s cycle anyway.
      try{ window.takeDamage = _origTakeDamage; }catch(e){}
      console.warn('[ANTICHEAT] takeDamage override detected');
    }
    // Detect if savePlayerState has been replaced (prevents coins staying inflated between saves)
    if(typeof savePlayerState !== 'function' || savePlayerState.toString() !== _origSavePlayerState.toString()){
      try{ window.savePlayerState = _origSavePlayerState; }catch(e){}
      console.warn('[ANTICHEAT] savePlayerState override detected');
    }
    // Detect if shoot has been replaced (e.g. to remove ammo consumption or add aimbot)
    if(typeof shoot !== 'function' || shoot.toString() !== _origShoot.toString()){
      try{ window.shoot = _origShoot; }catch(e){}
      console.warn('[ANTICHEAT] shoot override detected');
    }
    // Detect if callEdgeFn has been replaced (would break all server communication)
    if(typeof callEdgeFn !== 'function' || callEdgeFn.toString() !== _origCallEdgeFn.toString()){
      try{ window.callEdgeFn = _origCallEdgeFn; }catch(e){}
      console.warn('[ANTICHEAT] callEdgeFn override detected');
    }
    // Detect if openAdminConsole has been replaced (would bypass server verify)
    if(typeof openAdminConsole !== 'function' || openAdminConsole.toString() !== _origOpenAdminConsole.toString()){
      try{ window.openAdminConsole = _origOpenAdminConsole; }catch(e){}
      console.warn('[ANTICHEAT] openAdminConsole override detected');
    }
    // Anti-debug: measure how long this interval actually took.
    // If DevTools is paused at a breakpoint, the gap will be huge.
    // Flag it but don't kick ‚Äî just log for server-side correlation.
  }, 3000);

  // ‚îÄ‚îÄ Position delta speed-hack detector ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Max legitimate movement per second (accounting for all buffs):
  //   base sprint 0.26 * 60fps = 15.6 units/s
  //   √ó max rebirth speed buff (say 20 rebirths √ó 0.05 = 2.0√ó) = 31.2
  //   √ó red bull 1.45√ó = 45.2
  //   √ó hpl speed 1.3√ó = 58.8 ‚Üí round up to 70 with headroom for lag spikes
  const _MAX_UNITS_PER_SEC = 70;
  let _lastPosX = camera.position.x, _lastPosZ = camera.position.z;
  let _lastPosTime = Date.now();
  let _speedViolations = 0;

  // Called by respawn() so the teleport doesn't register as a speed violation
  window._resetSpeedChecker = function(){
    _lastPosX = camera.position.x;
    _lastPosZ = camera.position.z;
    _lastPosTime = Date.now();
    _speedViolations = 0;
  };

  setInterval(function _speedCheck(){
    if(dead || paused || inCar || onHorse) return;
    const now = Date.now();
    const dt  = (now - _lastPosTime) / 1000;
    if(dt < 0.4) { _lastPosTime = now; return; } // too short to measure
    const dx   = camera.position.x - _lastPosX;
    const dz   = camera.position.z - _lastPosZ;
    const dist = Math.sqrt(dx*dx + dz*dz);
    const unitsPerSec = dist / dt;
    if(unitsPerSec > _MAX_UNITS_PER_SEC){
      _speedViolations++;
      console.warn('[ANTICHEAT] Speed violation #' + _speedViolations + ': ' + unitsPerSec.toFixed(1) + ' u/s');
      if(_speedViolations >= 3){
        // Snap back to last known good position
        camera.position.x = _lastPosX;
        camera.position.z = _lastPosZ;
        _speedViolations = 0;
        showFloatPop('‚ö† SPEED VIOLATION', '#ff4444');
        callEdgeFn('anticheat', { username: accountUsername, type:'speed_hack',
          speed: unitsPerSec, x: camera.position.x, z: camera.position.z });
      }
    } else {
      if(_speedViolations > 0) _speedViolations--;
      _lastPosX = camera.position.x;
      _lastPosZ = camera.position.z;
    }
    _lastPosTime = now;
  }, 500);
  // Start server-side anti-cheat position checker
  _startAntiCheat();
  setTimeout(refreshLeaderboards, 5000);
  setTimeout(refreshBountyLeaderboard, 6000);
}

// ============================================================================
//  ADMIN SYSTEM
// ============================================================================
const ADMIN_USERNAME = 'Admin56';
// ‚îÄ‚îÄ Admin access ‚Äî console-proof sealed variables ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// These use private backing vars + Object.defineProperty so that
// `isAdmin = true` or `_realAdminUsername = 'Admin56'` in DevTools
// silently does nothing. Only internal setter functions can change them.
let _isAdminPrivate = false;
let _realAdminPrivate = '';

Object.defineProperty(window, 'isAdmin', {
  get: () => _isAdminPrivate,
  set: () => { /* sealed ‚Äî setting this from console has no effect */ },
  configurable: false,
  enumerable: true,
});
Object.defineProperty(window, '_realAdminUsername', {
  get: () => _realAdminPrivate,
  set: () => { /* sealed */ },
  configurable: false,
  enumerable: false,
});

// Internal-only setters used by the auth system
function _setIsAdmin(val)           { _isAdminPrivate  = !!val; }
function _setRealAdminUsername(val) { _realAdminPrivate = String(val||''); }
let _adminConsoleOpen = false;
let _adminRemoteTarget = null; // { username, data }

function _adminLog(msg){
  const el = document.getElementById('admin-log');
  if(!el) return;
  el.textContent += '> ' + msg + '\n';
  el.scrollTop = el.scrollHeight;
}

async function openAdminConsole(){
  // Don't even bother if local flag is false ‚Äî but this check can be bypassed
  // by setting isAdmin=true in console, so the real gate is the server verify below.
  // Re-verify against the DB every single time the console is opened.
  // This means: setting isAdmin=true OR _realAdminUsername='Admin56' in DevTools
  // does nothing ‚Äî the server checks the ACTUAL logged-in accountUsername.
  const verification = await callEdgeFn('admin-action', {
    adminUsername: accountUsername,   // always the real logged-in user, not a spoofable field
    action: 'verify'
  });
  if(!verification || !verification.ok || !verification.isAdmin){
    _setIsAdmin(false);
    showFloatPop('‚õî NOT AUTHORISED', '#ff4444');
    return;
  }
  // Server confirmed admin status
  _setIsAdmin(true);
  _adminConsoleOpen = true;
  document.exitPointerLock();
  document.getElementById('admin-bar-username').textContent = accountUsername;
  document.getElementById('admin-console').classList.add('active');
  adminRefreshSelfFields();
  const activeEl = document.getElementById('adm-active-account');
  if(activeEl) activeEl.textContent = accountUsername + (myName ? ' ('+myName+')' : '');
  const retBtn = document.getElementById('adm-return-btn');
  if(retBtn) retBtn.style.display = (accountUsername !== ADMIN_USERNAME) ? 'block' : 'none';
  _adminLog('Console opened. Logged in as ' + accountUsername + ' [SERVER VERIFIED]');
}

async function adminReturnToAdmin(){
  _adminLog('Returning to Admin56...');
  const {data,error} = await db.from('accounts').select('*').eq('username', ADMIN_USERNAME).single();
  if(error||!data){ _adminLog('ERROR: could not load admin account'); return; }
  accountUsername = ADMIN_USERNAME;
  _setIsAdmin(true);
  playerId = await sha256(ADMIN_USERNAME);
  myName = data.soldier_name || 'ADMIN';
  _pendingAccount = {username: ADMIN_USERNAME, passwordHash:'', existingData: data};
  loadPlayerState(data);
  closeAdminConsole();
  addChatMessage('','// [ADMIN] RETURNED TO ADMIN56 //',false,true);
}
function closeAdminConsole(){
  _adminConsoleOpen = false;
  document.getElementById('admin-console').classList.remove('active');
  renderer.domElement.requestPointerLock();
}

// Block DOM manipulation bypass: if anything adds .active to #admin-console
// while isAdmin is false, strip it immediately.
(function _guardAdminConsole(){
  const _acEl = document.getElementById('admin-console');
  if(!_acEl) return;
  new MutationObserver(()=>{
    if(_acEl.classList.contains('active') && !isAdmin){
      _acEl.classList.remove('active');
      _adminConsoleOpen = false;
      console.warn('[ANTICHEAT] Admin console DOM manipulation blocked');
    }
  }).observe(_acEl, { attributes:true, attributeFilter:['class'] });
  // Also guard style.display manipulation
  const _origDisplay = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'style');
})();

function adminTab(name){
  document.querySelectorAll('.admin-tab').forEach(t=>t.classList.remove('active'));
  document.querySelectorAll('.admin-section').forEach(s=>s.classList.remove('active'));
  event.target.classList.add('active');
  document.getElementById('admin-sec-'+name).classList.add('active');
  if(name==='hacks') _renderAdminHacks();
}

function adminRefreshSelfFields(){
  document.getElementById('adm-coins').value = coins;
  document.getElementById('adm-hp').value = myHp;
  document.getElementById('adm-maxhp').value = maxHpBonus;
  document.getElementById('adm-kills').value = kills;
  document.getElementById('adm-xp').value = playerXP;
  document.getElementById('adm-level').value = playerLevel;
  document.getElementById('adm-ammo-rifle').value = ammo.rifle;
  document.getElementById('adm-ammo-shotgun').value = ammo.shotgun;
  document.getElementById('adm-dmgmult').value = damageMultiplier;
  document.getElementById('adm-bounty').value = calcBounty ? calcBounty() : 0;
  document.getElementById('adm-pos-x').value = Math.round(camera.position.x * 10)/10;
  document.getElementById('adm-pos-y').value = Math.round(camera.position.y * 10)/10;
  document.getElementById('adm-pos-z').value = Math.round(camera.position.z * 10)/10;
}

async function adminSetSelf(field){
  if(!isAdmin){ _adminLog('ERROR: not authorised'); return; }

  // Map UI field names ‚Üí DB column names
  const colMap = {
    coins:       'coins',
    hp:          'hp',
    maxhp:       'max_hp_bonus',
    kills:       'kills',
    xp:          'player_xp',
    level:       'player_level',
    ammo_rifle:  'ammo_rifle',
    ammo_shotgun:'ammo_shotgun',
    dmgmult:     'damage_multiplier',
  };
  const inputIdMap = {
    coins:'adm-coins', hp:'adm-hp', maxhp:'adm-maxhp', kills:'adm-kills',
    xp:'adm-xp', level:'adm-level', ammo_rifle:'adm-ammo-rifle',
    ammo_shotgun:'adm-ammo-shotgun', dmgmult:'adm-dmgmult',
    pos_x:'adm-pos-x', pos_y:'adm-pos-y', pos_z:'adm-pos-z',
  };

  const inputId = inputIdMap[field];
  const raw     = document.getElementById(inputId)?.value ?? '';

  // Position changes are local-only (no DB column for live position)
  if(field === 'pos_x'){ camera.position.x = parseFloat(raw)||0; _adminLog('Moved self to x: '+raw); return; }
  if(field === 'pos_y'){ camera.position.y = parseFloat(raw)||GROUND_Y; _adminLog('Moved self to y: '+raw); return; }
  if(field === 'pos_z'){ camera.position.z = parseFloat(raw)||0; _adminLog('Moved self to z: '+raw); return; }

  const col = colMap[field];
  if(!col){ _adminLog('ERROR: unknown field: '+field); return; }

  // Route through admin-action ‚Äî bypasses save-state validation so admin
  // can set any value freely without the jump limiter blocking large changes.
  // Use _realAdminUsername so impersonation doesn't break the admin check.
  // accountUsername may have been changed to the impersonated account,
  // but _realAdminUsername always holds the original Admin56 username.
  const res = await callEdgeFn('admin-action', {
    adminUsername:  _realAdminUsername || accountUsername,
    action:         'set_field',
    targetUsername: accountUsername, // the currently active account (may be impersonated)
    col,
    value: raw,
  });
  if(!res || !res.ok){ _adminLog('ERROR: ' + (res?.error || 'server rejected')); return; }

  // Apply confirmed value locally so screen updates immediately
  const v = res.value;
  switch(field){
    case 'coins':        coins            = Number(v)||0;      updateHUD();     break;
    case 'hp':           myHp             = Number(v)||0;      updateHUD();     break;
    case 'maxhp':        maxHpBonus       = Number(v)||0;      updateHUD();     break;
    case 'kills':        kills            = Number(v)||0;      updateHUD();     break;
    case 'xp':           playerXP         = Number(v)||0;      updateXPHUD();   break;
    case 'level':        playerLevel      = Number(v)||0;      updateXPHUD();   break;
    case 'ammo_rifle':   ammo.rifle       = Number(v)||0;      updateAmmoHUD(); break;
    case 'ammo_shotgun': ammo.shotgun     = Number(v)||0;      updateAmmoHUD(); break;
    case 'dmgmult':      damageMultiplier = Number(v)||1.0;                     break;
  }
  _adminLog('Set self.' + field + ' ‚Üí ' + v);
}

async function adminLoadRemote(){
  const u = document.getElementById('adm-rem-user').value.trim();
  if(!u){ _adminLog('ERROR: enter a username'); return; }
  _adminLog('Loading ' + u + '...');
  const {data,error} = await db.from('accounts').select('*').eq('username',u).single();
  if(error||!data){ _adminLog('ERROR: user not found ‚Äî ' + (error?.message||'no data')); return; }
  _adminRemoteTarget = {username:u, data};

  const isOnline = Object.values(remotePlayers).some(rp=>rp.name===(data.soldier_name||''));
  const card = document.getElementById('admin-player-card');
  card.classList.add('visible');

  // Status + cars (read-only)
  const statusEl = document.getElementById('apc-status');
  statusEl.textContent = isOnline ? '‚óè ONLINE' : '‚óã OFFLINE';
  statusEl.className = 'apc-val ' + (isOnline ? 'apc-online' : 'apc-offline');
  let carStr = 'NONE';
  if(data.owned_cars){
    try{ const oc=typeof data.owned_cars==='string'?JSON.parse(data.owned_cars):data.owned_cars; const owned=Object.keys(oc).filter(k=>oc[k]); if(owned.length) carStr=owned.join(', ').toUpperCase(); }catch(e){}
  }
  document.getElementById('apc-cars').textContent = carStr;

  // Fill all editable inputs
  const fi=(id,v)=>{ const el=document.getElementById(id); if(el) el.value=v??''; };
  fi('apc-callsign',   data.soldier_name||'');
  fi('apc-coins',      data.coins||0);
  fi('apc-hp',         data.hp||100);
  fi('apc-maxhp',      data.max_hp_bonus||0);
  fi('apc-kills',      data.kills||0);
  fi('apc-deaths',     data.deaths||0);
  fi('apc-pvpkills',   data.pvp_kills||0);
  fi('apc-xp',         data.player_xp||0);
  fi('apc-level',      data.player_level||0);
  fi('apc-rebirths',   data.rebirth_count||0);
  fi('apc-dmgmult',    (data.damage_multiplier||1).toFixed(2));
  fi('apc-bounties',   data.pvp_bounties_claimed||0);
  fi('apc-tier',       data.bounty_contract_tier||0);
  fi('apc-ammo-rifle',   data.ammo_rifle??0);
  fi('apc-ammo-shotgun', data.ammo_shotgun??0);
  fi('apc-ammo-laser',   data.ammo_laser??0);
  fi('apc-ammo-sniper',  data.ammo_sniper??0);
  fi('apc-pos-x', data.pos_x!=null ? Math.round(data.pos_x*10)/10 : 0);
  fi('apc-pos-y', data.pos_y!=null ? Math.round(data.pos_y*10)/10 : GROUND_Y);
  fi('apc-pos-z', data.pos_z!=null ? Math.round(data.pos_z*10)/10 : 0);

  _adminLog('Loaded '+u+' ‚Äî '+(data.soldier_name||'?')+' | LV'+(data.player_level||0)+' | ‚¨°'+(data.coins||0)+' | '+(isOnline?'ONLINE':'OFFLINE'));
}

async function apcSet(col, inputId){
  if(!_adminRemoteTarget){ _adminLog('ERROR: load a player first'); return; }
  if(!isAdmin){ _adminLog('ERROR: not authorised'); return; }
  const u   = _adminRemoteTarget.username;
  const raw = document.getElementById(inputId)?.value ?? '';
  // Route through server-side admin-action Edge Function.
  // The server re-verifies that accountUsername has is_admin=true in the DB,
  // so setting isAdmin=true in the console grants no actual write access.
  const res = await callEdgeFn('admin-action', {
    adminUsername:  _realAdminUsername || accountUsername,
    action:         'set_field',
    targetUsername: u,
    col,
    value: raw,
  });
  if(!res || !res.ok){ _adminLog('ERROR: ' + (res?.error || 'server rejected')); return; }
  _adminLog('Set ' + u + '.' + col + ' ‚Üí ' + res.value);
  if((col==='pos_x'||col==='pos_y'||col==='pos_z') && _adminRemoteTarget.data){
    _adminRemoteTarget.data[col] = res.value;
  }
}

async function adminKickPlayer(){
  if(!_adminRemoteTarget){ _adminLog('ERROR: load a player first'); return; }
  const u = _adminRemoteTarget.username;
  // Send a massive damage hit to their player ID
  const {data} = await db.from('players').select('id').eq('name',_adminRemoteTarget.data.soldier_name).single();
  if(data && gameChannel){
    gameChannel.send({type:'broadcast', event:'hit', payload:{target:data.id, damage:99999, sender:'__admin__'}});
    _adminLog('Sent kill signal to ' + u);
  } else {
    _adminLog('Player not currently online (no live player entry)');
  }
}

async function adminImpersonate(){
  const u = document.getElementById('admin-imp-user').value.trim();
  if(!u){ _adminLog('ERROR: enter a username'); return; }
  if(u === ADMIN_USERNAME){ _adminLog('Cannot impersonate Admin56.'); return; }
  _adminLog('Loading account: ' + u);
  const {data,error} = await db.from('accounts').select('*').eq('username',u).single();
  if(error||!data){ _adminLog('ERROR: user not found'); return; }
  // Switch to that account's state without changing accountUsername fully
  _pendingAccount = {username:u, passwordHash:'', existingData:data};
  accountUsername = u;
  playerId = await sha256(u);
  myName = data.soldier_name || u.toUpperCase();
  loadPlayerState(data);
  closeAdminConsole();
  addChatMessage('','// [ADMIN] NOW IMPERSONATING: '+u+' //',false,true);
  _adminLog('Now impersonating: ' + u);
}

// ‚îÄ‚îÄ Fullscreen ‚îÄ‚îÄ
// ============================================================================
//  PLAYER LIST (TAB)
// ============================================================================
function showPlayerList(){
  const overlay = document.getElementById('player-list-overlay');
  const rows    = document.getElementById('pl-rows');
  overlay.classList.add('visible');

  // Build rows: self first, then remote players sorted by bounty desc
  let html = '';

  // Self row
  const selfBounty = calcBounty ? calcBounty() : 0;
  html += `<div class="pl-row pl-you">
    <div class="pl-name you">${myName||'YOU'} ‚òÖ</div>
    <div class="pl-lvl">LV${playerLevel}</div>
    <div class="pl-bounty">‚¨°${selfBounty}</div>
    <div class="pl-hp">${myHp}HP</div>
  </div>`;

  // Remote players ‚Äî sort by bounty
  const sorted = Object.values(remotePlayers).sort((a,b)=>(b.bounty||0)-(a.bounty||0));
  for(const rp of sorted){
    if(rp.name === 'ADMIN') continue; // hide admin from list
    html += `<div class="pl-row">
      <div class="pl-name">${rp.name||'???'}</div>
      <div class="pl-lvl">LV${rp.level||0}</div>
      <div class="pl-bounty">‚¨°${rp.bounty||0}</div>
      <div class="pl-hp">${rp.hp||0}HP</div>
    </div>`;
  }

  rows.innerHTML = html;
  document.getElementById('pl-footer').textContent =
    (Object.keys(remotePlayers).length + 1) + ' ONLINE ‚Äî HOLD TAB TO VIEW';
}

function hidePlayerList(){
  document.getElementById('player-list-overlay').classList.remove('visible');
}

// ============================================================================
//  ADMIN TELEPORT
// ============================================================================
function adminTeleportToPlayer(){
  if(!_adminRemoteTarget){ _adminLog('ERROR: load a player first'); return; }
  // Find them in remotePlayers by name
  const targetName = _adminRemoteTarget.data?.soldier_name;
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(rp.name === targetName){
      camera.position.set(rp.mesh.position.x + 2, rp.mesh.position.y + GROUND_Y + 0.5, rp.mesh.position.z + 2);
      _adminLog('Teleported to ' + targetName + ' at (' +
        Math.round(rp.mesh.position.x)+','+Math.round(rp.mesh.position.z)+')');
      closeAdminConsole();
      return;
    }
  }
  // Fallback: use saved DB pos
  const px = _adminRemoteTarget.data?.pos_x, pz = _adminRemoteTarget.data?.pos_z;
  if(px != null){
    camera.position.set(px + 2, GROUND_Y, pz + 2);
    _adminLog('Teleported to last saved pos of ' + targetName);
    closeAdminConsole();
  } else {
    _adminLog('ERROR: player not online and no saved position');
  }
}

function adminTeleportPlayerToMe(){
  if(!_adminRemoteTarget){ _adminLog('ERROR: load a player first'); return; }
  // Write our position to their DB record ‚Äî they'll snap on next login/respawn
  // Also send a pos broadcast to their specific ID via the hit channel trick
  const u = _adminRemoteTarget.username;
  const tx = camera.position.x, ty = camera.position.y, tz = camera.position.z;
  db.from('accounts').update({
    pos_x: tx, pos_y: ty, pos_z: tz, updated_at: new Date().toISOString()
  }).eq('username', u).then(({error})=>{
    if(error){ _adminLog('ERROR: '+error.message); return; }
  });
  // Try to find them live and broadcast a teleport event
  const targetName = _adminRemoteTarget.data?.soldier_name;
  for(const id in remotePlayers){
    if(remotePlayers[id].name === targetName){
      if(gameChannel) gameChannel.send({type:'broadcast', event:'admin_tp',
        payload:{ target: id, x: tx, y: ty, z: tz, sender: playerId, senderUsername: accountUsername }});
      break;
    }
  }
  _adminLog('Teleporting ' + u + ' to your position (' + Math.round(tx)+','+Math.round(tz)+')');
}

function toggleFullscreen(){
  if(!document.fullscreenElement){
    document.documentElement.requestFullscreen().catch(()=>{});
  } else {
    document.exitFullscreen();
  }
}

// Keyboard: Enter submits whichever step is visible
document.getElementById('auth-pass').addEventListener('keydown', e=>{ if(e.code==='Enter') authLogin(); });
document.getElementById('auth-user').addEventListener('keydown', e=>{ if(e.code==='Enter') authLogin(); });
document.getElementById('auth-callsign').addEventListener('keydown', e=>{ if(e.code==='Enter') authDeploy(); });

// ‚îÄ‚îÄ Save / Load player state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function savePlayerState(){
  if(!accountUsername) return;
  // Route ALL saves through the server-side validator.
  // The Edge Function reads current DB values, rejects impossible jumps
  // (e.g. coins=9999999 typed in DevTools), clamps cheated fields,
  // writes the validated data, and returns what it actually saved.
  // We then overwrite local state ‚Äî so cheated values are corrected within 30s.
  const payload = {
    username:             accountUsername,
    soldier_name:         myName,
    pos_x:                camera.position.x,
    pos_y:                camera.position.y,
    pos_z:                camera.position.z,
    pos_ry:               yaw,
    hp:                   myHp,
    max_hp_bonus:         maxHpBonus,
    damage_multiplier:    damageMultiplier,
    coins:                coins,
    kills:                kills,
    deaths:               deaths,
    pvp_kills:            pvpKills,
    ammo_rifle:           ammo.rifle,
    ammo_shotgun:         ammo.shotgun,
    ammo_laser:           ammo.laser,
    ammo_sniper:          ammo.sniper,
    ammo_grenade:         ammo.grenade,
    ammo_c4:              ammo.c4,
    current_weapon:       currentWeapon,
    mag_levels:           JSON.stringify(magLevel),
    player_xp:            playerXP,
    player_level:         playerLevel,
    rebirth_count:        rebirthCount,
    rebirth_buffs:        JSON.stringify(rebirthBuffs),
    pvp_bounties_claimed: pvpBountiesClaimed,
    bounty_contract_tier: bountyContractTier,
    owned_cars:           JSON.stringify(ownedCars),
    owned_horses:         JSON.stringify(ownedHorses),
    inventory:            invToJSON(),
    hotbar:               hotToJSON(),
  };
  const res = await callEdgeFn('save-state', payload);
  // If server corrected any values, snap local state back so screen matches DB
  if(res && res.ok && res.validated){
    const v = res.validated;
    if(typeof v.coins            === 'number') coins            = v.coins;
    if(typeof v.damage_multiplier=== 'number') damageMultiplier = v.damage_multiplier;
    if(typeof v.max_hp_bonus     === 'number') maxHpBonus       = v.max_hp_bonus;
    if(typeof v.player_xp        === 'number') playerXP         = v.player_xp;
    if(typeof v.player_level     === 'number') playerLevel      = v.player_level;
    if(typeof v.rebirth_count    === 'number') rebirthCount     = v.rebirth_count;
    if(typeof v.kills            === 'number') kills            = v.kills;
    if(typeof v.deaths           === 'number') deaths           = v.deaths;
    if(typeof v.pvp_kills        === 'number') pvpKills         = v.pvp_kills;
    if(v.mag_levels){
      try{
        const ml = typeof v.mag_levels==='string' ? JSON.parse(v.mag_levels) : v.mag_levels;
        Object.assign(magLevel, ml);
      }catch(e){}
    }
    // Reconcile rebirth buffs ‚Äî prevents tampered buff stacks persisting
    if(v.rebirth_buffs){
      try{
        const rb = typeof v.rebirth_buffs==='string' ? JSON.parse(v.rebirth_buffs) : v.rebirth_buffs;
        Object.keys(rebirthBuffs).forEach(k=>{ if(rb[k]!==undefined) rebirthBuffs[k]=rb[k]; });
      }catch(e){}
    }
    updateHUD(); updateXPHUD(); updateAmmoHUD();
  }
}

function loadPlayerState(d){
  // Restore position
  camera.position.set(d.pos_x ?? 0, d.pos_y ?? GROUND_Y, d.pos_z ?? -20);
  yaw = d.pos_ry ?? 0;
  camera.rotation.y = yaw;
  // Restore health
  myHp = d.hp ?? MAX_HP;
  maxHpBonus = d.max_hp_bonus ?? 0;
  // Restore economy + upgrades
  coins = d.coins ?? 0;
  kills = d.kills ?? 0;
  deaths = d.deaths ?? 0;
  pvpKills = d.pvp_kills ?? 0;
  damageMultiplier = d.damage_multiplier ?? 1.0;
  // Restore ammo
  ammo.rifle   = d.ammo_rifle   ?? MAX_AMMO.rifle;
  ammo.shotgun = d.ammo_shotgun ?? MAX_AMMO.shotgun;
  ammo.laser   = d.ammo_laser   ?? MAX_AMMO.laser;
  ammo.sniper  = d.ammo_sniper  ?? MAX_AMMO.sniper;
  ammo.grenade = d.ammo_grenade ?? MAX_AMMO.grenade;
  ammo.c4      = d.ammo_c4      ?? MAX_AMMO.c4;
  // Restore mag upgrades (new column ‚Äî graceful if absent)
  if(d.mag_levels){
    try {
      const ml = typeof d.mag_levels === 'string' ? JSON.parse(d.mag_levels) : d.mag_levels;
      magLevel.rifle   = ml.rifle   || 0;
      magLevel.shotgun = ml.shotgun || 0;
      magLevel.laser   = ml.laser   || 0;
      magLevel.sniper  = ml.sniper  || 0;
      magLevel.grenade = ml.grenade || 0;
      magLevel.c4      = ml.c4      || 0;
      // Recompute MAX_AMMO from saved levels
      MAX_AMMO.rifle   = BASE_AMMO.rifle   + MAG_STEP.rifle   * magLevel.rifle;
      MAX_AMMO.shotgun = BASE_AMMO.shotgun + MAG_STEP.shotgun * magLevel.shotgun;
      MAX_AMMO.laser   = BASE_AMMO.laser   + MAG_STEP.laser   * magLevel.laser;
      MAX_AMMO.sniper  = BASE_AMMO.sniper  + MAG_STEP.sniper  * magLevel.sniper;
      MAX_AMMO.grenade = BASE_AMMO.grenade + MAG_STEP.grenade * (magLevel.grenade||0);
      MAX_AMMO.c4      = BASE_AMMO.c4      + MAG_STEP.c4      * (magLevel.c4||0);
    } catch(e){}
  }
  // Restore XP + rebirth
  playerXP    = d.player_xp    ?? 0;
  playerLevel = d.player_level ?? 0;
  rebirthCount= d.rebirth_count?? 0;
  if(d.rebirth_buffs){
    try{ rebirthBuffs=typeof d.rebirth_buffs==='string'?JSON.parse(d.rebirth_buffs):d.rebirth_buffs||{}; }catch(e){}
  }
  pvpBountiesClaimed  = d.pvp_bounties_claimed ?? 0;
  bountyContractTier  = d.bounty_contract_tier  ?? 0;
  _lastNotifiedTier   = bountyContractTier - 1;
  // Restore owned cars
  if(d.owned_cars){
    try{
      const oc = typeof d.owned_cars === 'string' ? JSON.parse(d.owned_cars) : d.owned_cars;
      Object.keys(oc).forEach(k=>{ if(ownedCars.hasOwnProperty(k) && oc[k]){ ownedCars[k]=true; spawnParkedCar(k); } });
    }catch(e){}
  }
  // Restore owned horses
  if(d.owned_horses){
    try{
      const oh = typeof d.owned_horses === 'string' ? JSON.parse(d.owned_horses) : d.owned_horses;
      Object.keys(oh).forEach(k=>{ if(ownedHorses.hasOwnProperty(k) && oh[k]){ ownedHorses[k]=true; spawnParkedHorse(k); } });
    }catch(e){}
  }
  // Restore inventory + hotbar
  if(d.inventory) invFromJSON(d.inventory);
  else inventory = Array(INV_SIZE).fill(null);
  if(d.hotbar) hotFromJSON(d.hotbar);
  else { hotbar = Array(HOT_SIZE).fill(null); DEFAULT_HOTBAR.forEach((id,i)=>{ hotbar[i]={id,qty:1}; }); }
  renderHotbar();
  // Restore weapon
  if(d.current_weapon) setWeapon(d.current_weapon);
  // Update all HUD elements
  updateHUD(); updateAmmoHUD();
}

// ============================================================================
//  FIRST-PERSON GUN MODELS
// ============================================================================
// Dedicated gunScene holds ONLY the gun group.
// Pass 1: render world with main camera.
// Pass 2: clearDepth then render gunScene with fpCam ‚Äî composites gun on top.
// This prevents the second pass from re-rendering the world at a different FOV.

const gunScene = new THREE.Scene(); // no background, no fog ‚Äî gun only
const fpCam = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.01, 10);
gunScene.add(fpCam); // fpCam lives in gunScene, NOT in main scene
// Match main scene lighting so gun isn't pitch-black
gunScene.add(new THREE.AmbientLight(0x5070a0, 1.2));
const _fpMoonLight = new THREE.DirectionalLight(0x7090d0, 1.4);
_fpMoonLight.position.set(30,80,20); gunScene.add(_fpMoonLight);

window.addEventListener('resize', ()=>{ fpCam.aspect=innerWidth/innerHeight; fpCam.updateProjectionMatrix(); });
renderer.autoClear = false; // we handle clear manually to composite both passes

// ‚îÄ‚îÄ Shared FP materials ‚Äî standard depth testing within the gun is fine;
//    clearDepth() before pass 2 guarantees gun always draws on top of world. ‚îÄ‚îÄ
function _fpMat(color, opts={}){
  return new THREE.MeshLambertMaterial({color, ...opts});
}
const _fpM = {
  body:   _fpMat(0x2a2a2a),
  stock:  _fpMat(0x3d2410),
  barrel: _fpMat(0x1a1a1a),
  grip:   _fpMat(0x1e1e1e),
  scope:  _fpMat(0x111111),
  glass:  _fpMat(0x0080ff, {transparent:true, opacity:0.5}),
  laser:  _fpMat(0x004488),
  lBarrel:_fpMat(0x00cccc),
  snBody: _fpMat(0x1a1a1a),
  snWood: _fpMat(0x4a2e10),
  sgBody: _fpMat(0x2a2010),
  sgMetal:_fpMat(0x1a1a1a),
};

function _b(geo, mat){ const m=new THREE.Mesh(geo,mat); m.renderOrder=999; return m; }
function _box(w,h,d,mat,x,y,z){
  const m=_b(new THREE.BoxGeometry(w,h,d),mat);
  m.position.set(x,y,z); return m;
}
function _cyl(rt,rb,h,mat,x,y,z,rx=0,ry=0,rz=0){
  const m=_b(new THREE.CylinderGeometry(rt,rb,h,8),mat);
  m.position.set(x,y,z); m.rotation.set(rx,ry,rz); return m;
}

// ‚îÄ‚îÄ Rifle (assault rifle silhouette) ‚îÄ‚îÄ
// Origin sits at the pistol grip. Barrel extends toward -Z (forward).
function makeFpRifle(){
  const g=new THREE.Group();
  // Upper receiver (runs most of gun length, slightly above centre)
  g.add(_box(0.055, 0.055, 0.46, _fpM.body,   0,  0.02, -0.08));
  // Charging handle bump
  g.add(_box(0.018, 0.018, 0.04, _fpM.barrel, 0,  0.048, 0.10));
  // Handguard (quad-rail style, slightly narrower)
  g.add(_box(0.048, 0.048, 0.22, _fpM.grip,   0,  0.02, -0.26));
  // Barrel (thin, extends well forward)
  g.add(_cyl(0.009,0.009, 0.30, _fpM.barrel,  0,  0.02, -0.47, Math.PI/2));
  // Muzzle brake
  g.add(_cyl(0.013,0.013, 0.04, _fpM.barrel,  0,  0.02, -0.64, Math.PI/2));
  // Pistol grip (angled down-back)
  g.add(_box(0.038, 0.10, 0.048, _fpM.grip,   0, -0.06,  0.04));
  // Magazine (curves forward slightly)
  g.add(_box(0.030, 0.13, 0.055, _fpM.body,   0, -0.10, -0.04));
  // Stock (chunky, extends back)
  g.add(_box(0.050, 0.055, 0.20, _fpM.stock,  0,  0.005, 0.21));
  // Butt pad
  g.add(_box(0.052, 0.072, 0.018, _fpM.grip,  0,  0.005, 0.32));
  // Front sight post
  g.add(_box(0.006, 0.022, 0.006, _fpM.barrel, 0, 0.055, -0.34));
  // Rear sight
  g.add(_box(0.030, 0.018, 0.008, _fpM.barrel, 0, 0.052,  0.08));
  return g;
}

// ‚îÄ‚îÄ Shotgun (pump-action) ‚îÄ‚îÄ
function makeFpShotgun(){
  const g=new THREE.Group();
  // Receiver ‚Äî fat and boxy
  g.add(_box(0.072, 0.075, 0.30, _fpM.sgBody,  0,  0,     0.02));
  // Barrel ‚Äî single wide tube
  g.add(_cyl(0.022,0.022,  0.46, _fpM.sgMetal, 0,  0.018,-0.29, Math.PI/2));
  // Magazine tube under barrel
  g.add(_cyl(0.014,0.014,  0.40, _fpM.sgMetal, 0, -0.018,-0.26, Math.PI/2));
  // Pump forend (slides forward when pumping)
  g.add(_box(0.060, 0.052, 0.14, _fpM.snWood,  0, -0.010,-0.30));
  // Pistol grip
  g.add(_box(0.042, 0.10,  0.050,_fpM.snWood,  0, -0.065, 0.08));
  // Stock (straight, wood style)
  g.add(_box(0.055, 0.065, 0.24, _fpM.snWood,  0,  0.005, 0.22));
  // Butt pad
  g.add(_box(0.058, 0.082, 0.016,_fpM.grip,    0,  0.005, 0.35));
  // Ejection port detail
  g.add(_box(0.010, 0.032, 0.07, _fpM.barrel,  0.038, 0.01, 0.04));
  return g;
}

// ‚îÄ‚îÄ Laser rifle (sci-fi energy weapon) ‚îÄ‚îÄ
function makeFpLaser(){
  const g=new THREE.Group();
  // Main body ‚Äî angular hexagonal look
  g.add(_box(0.062, 0.070, 0.42, _fpM.laser,   0,  0,    -0.06));
  // Emitter housing (front, wider)
  g.add(_box(0.072, 0.060, 0.10, _fpM.laser,   0,  0,    -0.33));
  // Emitter tip (glowing cyan)
  g.add(_cyl(0.024,0.016, 0.05, _fpM.lBarrel,  0,  0,    -0.41, Math.PI/2));
  // Energy cell (bottom, glowing strip)
  g.add(_box(0.024, 0.025, 0.28, _fpM.lBarrel, 0, -0.048,-0.06));
  // Side cooling vents (L+R)
  for(const sx of [-1,1]){
    g.add(_box(0.006, 0.040, 0.24, _fpM.lBarrel, sx*0.035, 0.008,-0.04));
  }
  // Grip
  g.add(_box(0.042, 0.10, 0.048, _fpM.grip,    0, -0.062,  0.08));
  // Back power unit
  g.add(_box(0.058, 0.065, 0.10, _fpM.scope,   0,  0.002,  0.26));
  // Sight rail on top
  g.add(_box(0.014, 0.012, 0.28, _fpM.barrel,  0,  0.041, -0.04));
  return g;
}

// ‚îÄ‚îÄ Sniper (bolt-action, long barrel) ‚îÄ‚îÄ
function makeFpSniper(){
  const g=new THREE.Group();
  // Receiver
  g.add(_box(0.052, 0.065, 0.36, _fpM.snBody,  0,  0.01,  0.00));
  // Barrel ‚Äî long and thin
  g.add(_cyl(0.010,0.010,  0.60, _fpM.barrel,  0,  0.01, -0.44, Math.PI/2));
  // Muzzle
  g.add(_cyl(0.015,0.010,  0.04, _fpM.barrel,  0,  0.01, -0.76, Math.PI/2));
  // Stock (wooden, chunky)
  g.add(_box(0.050, 0.062, 0.30, _fpM.snWood,  0,  0.005, 0.23));
  // Cheekpiece
  g.add(_box(0.050, 0.028, 0.14, _fpM.snWood,  0,  0.052, 0.14));
  // Butt pad
  g.add(_box(0.052, 0.080, 0.016,_fpM.grip,    0,  0.005, 0.39));
  // Pistol grip
  g.add(_box(0.040, 0.10,  0.048,_fpM.snWood,  0, -0.062, 0.10));
  // Scope body (cylindrical, sits high on top)
  g.add(_cyl(0.022,0.022,  0.30, _fpM.scope,   0,  0.080, -0.04, Math.PI/2));
  // Scope adjustment turrets
  g.add(_cyl(0.010,0.010,  0.022,_fpM.barrel,  0.022, 0.092,-0.04, 0,0,Math.PI/2));
  // Scope end bells (wider ends)
  g.add(_cyl(0.028,0.022,  0.028,_fpM.scope,   0,  0.080,  0.115, Math.PI/2));
  g.add(_cyl(0.028,0.022,  0.028,_fpM.scope,   0,  0.080, -0.195, Math.PI/2));
  // Lens glass
  g.add(_cyl(0.020,0.020,  0.008,_fpM.glass,   0,  0.080, -0.212, Math.PI/2));
  // Bolt handle
  g.add(_cyl(0.008,0.008,  0.055,_fpM.barrel,  0.052, 0.022, 0.06, 0,0,Math.PI/2));
  // Bipod (folded down)
  for(const sx of [-1,1]){
    g.add(_box(0.007, 0.090, 0.007,_fpM.barrel, sx*0.028,-0.075,-0.30));
    g.add(_box(0.007, 0.007, 0.045,_fpM.barrel, sx*0.028,-0.118,-0.278));
  }
  return g;
}

// ‚îÄ‚îÄ Grenade ‚îÄ‚îÄ
function makeFpGrenade(){
  const g=new THREE.Group();
  // Body ‚Äî slightly egg-shaped (taller than wide)
  g.add(_b(new THREE.SphereGeometry(0.055,10,8), new THREE.MeshLambertMaterial({color:0x3a5a28})));
  // Segmentation band around equator
  g.add(_b(new THREE.TorusGeometry(0.056,0.008,6,16), new THREE.MeshLambertMaterial({color:0x2a3a18})));
  // Vertical ridges (4 segments, alternating)
  for(let i=0;i<4;i++){
    const rm=new THREE.Mesh(new THREE.BoxGeometry(0.010,0.072,0.010),new THREE.MeshLambertMaterial({color:0x2a3a18}));
    rm.renderOrder=999; rm.rotation.y=i*Math.PI/2; rm.position.set(Math.sin(i*Math.PI/2)*0.052,0,Math.cos(i*Math.PI/2)*0.052);
    g.add(rm);
  }
  // Safety lever (flat plate on right side)
  const lev=new THREE.Mesh(new THREE.BoxGeometry(0.008,0.055,0.022),new THREE.MeshLambertMaterial({color:0x888800}));
  lev.renderOrder=999; lev.position.set(0.060,0.008,0); g.add(lev);
  // Lever clip
  const clip=new THREE.Mesh(new THREE.BoxGeometry(0.006,0.010,0.030),new THREE.MeshLambertMaterial({color:0x888800}));
  clip.renderOrder=999; clip.position.set(0.056,0.030,0); g.add(clip);
  // Pin ring (top)
  const ring=new THREE.Mesh(new THREE.TorusGeometry(0.014,0.004,6,10),new THREE.MeshLambertMaterial({color:0xaaaaaa}));
  ring.renderOrder=999; ring.position.set(0,0.065,0); ring.rotation.x=Math.PI/2; g.add(ring);
  // Fuse cap (top cylinder)
  const cap=new THREE.Mesh(new THREE.CylinderGeometry(0.018,0.022,0.030,8),new THREE.MeshLambertMaterial({color:0x222222}));
  cap.renderOrder=999; cap.position.set(0,0.075,0); g.add(cap);
  // Apply renderOrder to body parts
  g.traverse(c=>{ if(c.isMesh) c.renderOrder=999; });
  return g;
}

// ‚îÄ‚îÄ C4 ‚îÄ‚îÄ
function makeFpC4(){
  const g=new THREE.Group();
  const bodyMat  = new THREE.MeshLambertMaterial({color:0xd4c89a}); // tan/clay
  const darkMat  = new THREE.MeshLambertMaterial({color:0x333322});
  const redMat   = new THREE.MeshLambertMaterial({color:0xff2200});
  const wireMat  = new THREE.MeshLambertMaterial({color:0x111111});
  const yelloMat = new THREE.MeshLambertMaterial({color:0xddcc00});
  // Main brick body
  const body = _b(new THREE.BoxGeometry(0.22,0.07,0.14), bodyMat);
  body.position.set(0,0,0); g.add(body);
  // Detonator block on top-front
  const det = _b(new THREE.BoxGeometry(0.07,0.032,0.06), darkMat);
  det.position.set(-0.04, 0.051, -0.03); g.add(det);
  // Red LED indicator
  const led = _b(new THREE.SphereGeometry(0.009,6,6), redMat);
  led.position.set(-0.04, 0.072, -0.012); g.add(led);
  // Wires (3 thin cylinders going up)
  const wireGeo = new THREE.CylinderGeometry(0.003,0.003,0.06,4);
  const colors = [wireMat, redMat, yelloMat];
  for(let i=0;i<3;i++){
    const w=_b(wireGeo, colors[i]);
    w.position.set(-0.04+i*0.012, 0.082, -0.03);
    g.add(w);
  }
  // Text label ridge (slightly raised strip saying "C4")
  const lbl = _b(new THREE.BoxGeometry(0.10,0.006,0.05), darkMat);
  lbl.position.set(0.04,0.038,0); g.add(lbl);
  g.traverse(c=>{ if(c.isMesh) c.renderOrder=999; });
  return g;
}

// ‚îÄ‚îÄ FP rig parented to fpCam ‚îÄ‚îÄ
const _fpRig   = new THREE.Group();
const _fpRest  = new THREE.Vector3(0.18, -0.20, -0.42); // resting position relative to fpCam
const _fpModels = {
  rifle:  makeFpRifle(),
  shotgun:makeFpShotgun(),
  laser:  makeFpLaser(),
  sniper: makeFpSniper(),
  grenade:makeFpGrenade(),
  c4:     makeFpC4(),
};
Object.values(_fpModels).forEach(m=>{ m.visible=false; _fpRig.add(m); });
_fpModels.rifle.visible = true;
fpCam.add(_fpRig);
_fpRig.position.copy(_fpRest);
// gunScene already contains fpCam ‚Äî _fpRig is a child of fpCam so it's in gunScene

// Recoil state
let _fpRecoilT = 0;
const _fpRecoilMax = 7;

function updateFpGun(){
  // Mirror fpCam exactly to main camera
  fpCam.position.copy(camera.position);
  fpCam.rotation.copy(camera.rotation);
  fpCam.updateMatrixWorld();

  // Recoil kick: push back and up briefly
  if(_fpRecoilT > 0){
    const t = _fpRecoilT / _fpRecoilMax;
    _fpRig.position.set(
      _fpRest.x,
      _fpRest.y + t * 0.04,
      _fpRest.z + t * 0.06
    );
    _fpRecoilT--;
  } else {
    // Smooth return
    _fpRig.position.lerp(_fpRest, 0.18);
  }

  // Subtle walk bob
  const bob = Math.sin(Date.now() * 0.007) * 0.003;
  _fpRig.position.y += bob;
}

// ============================================================================
//  WEAPON SYSTEM (NEW) + BULLETS
// ============================================================================
// Weapon definitions (borrowed from the wave game, adapted to multiplayer)
const WEAPONS = {
  rifle:  { name: "RIFLE",   damage: 25,  pellets: 1, spread: 0,    speed: 0.7,  cooldown: 12 },
  shotgun:{ name: "SHOTGUN", damage: 10,   pellets: 6, spread: 0.28, speed: 0.55, cooldown: 22 },
  laser:  { name: "LASER",   damage: 8,   pellets: 1, spread: 0,    speed: 1.4,  cooldown: 2  },
  sniper: { name: "SNIPER",  damage: 75, pellets: 1, spread: 0,    speed: 2.2,  cooldown: 90 },
  grenade:{ name: "GRENADE", damage: 80,  pellets: 1, spread: 0,    speed: 0.18, cooldown: 70, isGrenade:true },
  c4:     { name: "C4",      damage: 150, pellets: 1, spread: 0,    speed: 0,    cooldown: 45, isC4:true },     // place on ground; detonate with G
};

// Current weapon + cooldowns
let currentWeapon = "rifle";
let weaponCooldown = 0;

// ============================================================================
//  HACK CLIENT SYSTEM ‚Äî lives in Admin Console > Hacks tab
// ============================================================================
const HC = {
  hacks: {
    speedHack:    { label: '‚ö° Speed Hack',     desc: '1.3√ó movement speed',           on: false },
    infiniteAmmo: { label: '‚àû Infinite Ammo',   desc: 'Ammo never decreases',           on: false },
    noRecoil:     { label: 'üéØ No Recoil',       desc: 'Zero weapon recoil',             on: false },
    rapidFire:    { label: 'üî• Rapid Fire',      desc: 'Reduced weapon cooldown',        on: false },
    godMode:      { label: 'üíÄ God Mode',        desc: 'Slow HP regen only',             on: false },
    killAura:     { label: 'üí• Kill Aura',       desc: 'Auto-kill zombies within 3m',    on: false },
    oneHitKill:   { label: '‚ò†Ô∏è One Hit Kill',    desc: '2√ó bullet damage',               on: false },
    coinRain:     { label: 'üí∞ Coin Rain',       desc: '+10 coins per second',           on: false },
    superJump:    { label: 'üöÄ Super Jump',      desc: '1.4√ó jump height',              on: false },
    esp:          { label: 'üëÅ ESP',             desc: 'See zombies through walls',      on: false },
  },
  scripts: [],          // compiled HPL hack scripts
  _coinTimer: 0,
  _espMeshes: [],
  // HPL runtime multipliers ‚Äî reset when scripts are cleared
  _hplSpeedMult: 1,
  _hplDmgMult:   1,
  _hplGravMult:  1,
  _hplJumpMult:  1,
};

// ============================================================================
//  INVENTORY & HOTBAR SYSTEM
// ============================================================================

// Item definitions ‚Äî all weaponsmith consumables
const INV_ITEMS = {
  // ‚îÄ‚îÄ Weapons (equippable ‚Äî go on hotbar, pressing that slot key equips them) ‚îÄ‚îÄ
  rifle:          { label:'RIFLE',          icon:'üî´', color:'#00ff88', maxStack:1, isWeapon:true,  weaponKey:'rifle'   },
  shotgun:        { label:'SHOTGUN',        icon:'üí•', color:'#ff8800', maxStack:1, isWeapon:true,  weaponKey:'shotgun' },
  laser:          { label:'LASER',          icon:'üîÜ', color:'#00ccff', maxStack:1, isWeapon:true,  weaponKey:'laser'   },
  sniper:         { label:'SNIPER',         icon:'üéØ', color:'#ffcc00', maxStack:1, isWeapon:true,  weaponKey:'sniper'  },
  grenade:        { label:'GRENADE',        icon:'üí£', color:'#88ff00', maxStack:1, isWeapon:true,  weaponKey:'grenade' },
  c4:             { label:'C4',             icon:'üß®', color:'#ff4488', maxStack:1, isWeapon:true,  weaponKey:'c4'      },
  // ‚îÄ‚îÄ Consumables (use from hotbar or inventory) ‚îÄ‚îÄ
  red_bull:       { label:'RED BULL',       icon:'üî¥', color:'#ff4444', maxStack:10 },
  emp_blast:      { label:'EMP BLAST',      icon:'‚ö°', color:'#00ccff', maxStack:5  },
  cruise_missile: { label:'CRUISE MISSILE', icon:'üöÄ', color:'#ff8800', maxStack:5  },
  mini_nuke:      { label:'MINI NUKE',      icon:'‚ò¢',  color:'#ffcc00', maxStack:3  },
  nuke:           { label:'NUKE',           icon:'üí£', color:'#ff2200', maxStack:1  },
};

// Default hotbar loadout ‚Äî all 6 weapons pre-slotted
const DEFAULT_HOTBAR = ['rifle','shotgun','laser','sniper','grenade','c4'];

const INV_SIZE  = 24; // 4 rows √ó 6 cols
const HOT_SIZE  = 6;

// Each slot: { id: 'red_bull', qty: 1 } or null
let inventory = Array(INV_SIZE).fill(null);
let hotbar    = Array(HOT_SIZE).fill(null);
let invOpen   = false;

// Drag state
let _invDrag = null; // { zone:'inv'|'hot', idx:number, item:object }

// ‚îÄ‚îÄ Add item to inventory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function invAddItem(id, qty=1){
  const def = INV_ITEMS[id];
  if(!def) return false;
  let remaining = qty;

  // First try to stack onto existing slots
  for(let i=0; i<INV_SIZE && remaining>0; i++){
    if(inventory[i] && inventory[i].id === id){
      const space = def.maxStack - inventory[i].qty;
      const add   = Math.min(space, remaining);
      inventory[i].qty += add;
      remaining -= add;
    }
  }
  // Then fill empty slots
  for(let i=0; i<INV_SIZE && remaining>0; i++){
    if(!inventory[i]){
      const add = Math.min(def.maxStack, remaining);
      inventory[i] = { id, qty: add };
      remaining -= add;
    }
  }

  if(remaining > 0){
    showFloatPop('‚ö† INVENTORY FULL', '#ff4444');
  }

  renderHotbar();
  if(invOpen) renderInvGrid();
  return remaining === 0;
}

// ‚îÄ‚îÄ Use an item by id ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function invUseItem(id){
  switch(id){
    case 'red_bull':
      redBullTimer += RED_BULL_DURATION;
      if(redBullTimer > RED_BULL_DURATION*10) redBullTimer = RED_BULL_DURATION*10;
      drinkRedBull();
      break;
    case 'emp_blast':      detonateEMP();          break;
    case 'cruise_missile': launchCruiseMissile();  break;
    case 'mini_nuke':      detonateMiniNuke();     break;
    case 'nuke':           detonateNuke();         break;
  }
}

// ‚îÄ‚îÄ Use item from hotbar slot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function useHotbarSlot(idx){
  const slot = hotbar[idx];
  if(!slot) return;
  const def = INV_ITEMS[slot.id];
  if(def && def.isWeapon){
    // Equip the weapon ‚Äî don't consume it
    setWeapon(def.weaponKey);
    renderHotbar();
    return;
  }
  // Consumable ‚Äî use and decrement
  invUseItem(slot.id);
  slot.qty--;
  if(slot.qty <= 0) hotbar[idx] = null;
  renderHotbar();
  if(invOpen) renderInvGrid();
  savePlayerState();
  // Flash the slot
  const el = document.querySelector('#hotbar-wrap .hotbar-slot[data-idx="'+idx+'"]');
  if(el){ el.classList.add('used'); setTimeout(()=>el.classList.remove('used'),250); }
}

// ‚îÄ‚îÄ Render hotbar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderHotbar(){
  const wrap = document.getElementById('hotbar-wrap');
  if(!wrap) return;
  wrap.innerHTML = '';
  for(let i=0; i<HOT_SIZE; i++){
    const slot = hotbar[i];
    const def  = slot ? INV_ITEMS[slot.id] : null;
    const el   = document.createElement('div');
    // Active = weapon in this slot is currently equipped
    const isActive = slot && def && def.isWeapon && def.weaponKey === currentWeapon;
    el.className = 'hotbar-slot' + (slot ? ' has-item' : '') + (isActive ? ' active-weapon' : '');
    el.dataset.idx  = i;
    el.dataset.zone = 'hot';
    el.innerHTML = `
      <span class="hs-key">${i+1}</span>
      ${slot ? `<span class="hs-icon">${def.icon}</span>
                <span class="hs-name">${def.label}</span>
                ${slot.qty>1?'<span class="hs-qty">'+slot.qty+'</span>':''}` : ''}
    `;
    // Click to use/equip
    el.addEventListener('click', ()=>{ if(!invOpen) useHotbarSlot(i); });
    // Drag events
    _bindSlotDrag(el, 'hot', i);
    wrap.appendChild(el);
  }
}

// ‚îÄ‚îÄ Render inventory grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderInvGrid(){
  const grid = document.getElementById('inv-grid');
  const hrow = document.getElementById('inv-hotbar-row');
  if(!grid || !hrow) return;

  // Main grid
  grid.innerHTML = '';
  for(let i=0; i<INV_SIZE; i++){
    const slot = inventory[i];
    const def  = slot ? INV_ITEMS[slot.id] : null;
    const el   = document.createElement('div');
    el.className = 'inv-slot' + (slot ? ' has-item' : '');
    el.dataset.idx  = i;
    el.dataset.zone = 'inv';
    if(slot) el.innerHTML = `
      <span class="is-icon">${def.icon}</span>
      <span class="is-name">${def.label}</span>
      ${slot.qty>1?'<span class="is-qty">'+slot.qty+'</span>':''}
    `;
    _bindSlotDrag(el, 'inv', i);
    _bindSlotTooltip(el, slot);
    grid.appendChild(el);
  }

  // Hotbar row inside inventory panel
  hrow.innerHTML = '';
  for(let i=0; i<HOT_SIZE; i++){
    const slot = hotbar[i];
    const def  = slot ? INV_ITEMS[slot.id] : null;
    const el   = document.createElement('div');
    el.className = 'hotbar-slot' + (slot ? ' has-item' : '');
    el.dataset.idx  = i;
    el.dataset.zone = 'hot';
    el.innerHTML = `
      <span class="hs-key">${i+1}</span>
      ${slot ? `<span class="hs-icon">${def.icon}</span>
                <span class="hs-name">${def.label}</span>
                ${slot.qty>1?'<span class="hs-qty">'+slot.qty+'</span>':''}` : ''}
    `;
    _bindSlotDrag(el, 'hot', i);
    _bindSlotTooltip(el, slot);
    hrow.appendChild(el);
  }
}

// ‚îÄ‚îÄ Tooltip ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function _bindSlotTooltip(el, slot){
  const tip = document.getElementById('inv-tooltip');
  if(!tip) return;
  el.addEventListener('mouseenter', e=>{
    if(!slot){ tip.style.display='none'; return; }
    const def = INV_ITEMS[slot.id];
    tip.innerHTML = `<span style="color:${def.color}">${def.icon} ${def.label}</span><br>QTY: ${slot.qty}`;
    tip.style.display='block';
    tip.style.left=(e.clientX+12)+'px';
    tip.style.top =(e.clientY+12)+'px';
  });
  el.addEventListener('mousemove', e=>{
    tip.style.left=(e.clientX+12)+'px';
    tip.style.top =(e.clientY+12)+'px';
  });
  el.addEventListener('mouseleave', ()=>{ tip.style.display='none'; });
}

// ‚îÄ‚îÄ Drag and drop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _ghost = ()=>document.getElementById('inv-drag-ghost');

function _bindSlotDrag(el, zone, idx){
  el.addEventListener('mousedown', e=>{
    if(e.button!==0) return;
    const arr  = zone==='inv' ? inventory : hotbar;
    const slot = arr[idx];
    if(!slot) return;
    e.preventDefault();
    _invDrag = { zone, idx, item: {...slot} };
    const def = INV_ITEMS[slot.id];
    const g   = _ghost();
    g.textContent = def.icon;
    g.style.display='block';
    g.style.left=e.clientX+'px';
    g.style.top =e.clientY+'px';
  });
  el.addEventListener('dragover',  e=>{ e.preventDefault(); el.classList.add('drag-over'); });
  el.addEventListener('dragleave', e=>{ el.classList.remove('drag-over'); });
  el.addEventListener('drop', e=>{
    e.preventDefault(); el.classList.remove('drag-over');
    _invDrop(zone, idx);
  });
  // Make droppable even without HTML5 drag (using mouseup)
  el.addEventListener('mouseup', e=>{
    if(!_invDrag) return;
    _invDrop(zone, idx);
  });
}

// Global mousemove for ghost
window.addEventListener('mousemove', e=>{
  if(!_invDrag) return;
  const g = _ghost();
  g.style.left=e.clientX+'px';
  g.style.top =e.clientY+'px';
});
window.addEventListener('mouseup', e=>{
  if(!_invDrag) return;
  _invDrag = null;
  const g = _ghost();
  g.style.display='none';
});

function _invDrop(toZone, toIdx){
  if(!_invDrag) return;
  const {zone:fromZone, idx:fromIdx} = _invDrag;
  if(fromZone===toZone && fromIdx===toIdx){ _invDrag=null; return; }

  const fromArr = fromZone==='inv' ? inventory : hotbar;
  const toArr   = toZone  ==='inv' ? inventory : hotbar;

  // Swap the slots
  const tmp     = toArr[toIdx];
  toArr[toIdx]  = fromArr[fromIdx];
  fromArr[fromIdx] = tmp;

  _invDrag = null;
  _ghost().style.display='none';

  renderHotbar();
  renderInvGrid();
  savePlayerState();
}

// ‚îÄ‚îÄ Open / close inventory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openInventory(){
  if(dead) return;
  invOpen = true; // set BEFORE exitPointerLock so pointerlockchange doesn't trigger pause
  document.exitPointerLock();
  document.getElementById('inv-overlay').classList.add('open');
  renderInvGrid();
}
function closeInventory(){
  invOpen = false;
  document.getElementById('inv-overlay').classList.remove('open');
  document.getElementById('inv-tooltip').style.display='none';
}

// ‚îÄ‚îÄ Serialize / deserialize ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function invToJSON()  { return JSON.stringify(inventory); }
function hotToJSON()  { return JSON.stringify(hotbar);    }
function invFromJSON(s){
  try{
    const a = typeof s==='string' ? JSON.parse(s) : s;
    if(!Array.isArray(a)) return;
    inventory = Array(INV_SIZE).fill(null);
    a.forEach((slot,i)=>{ if(i<INV_SIZE) inventory[i]=slot; });
  }catch(e){}
}
function hotFromJSON(s){
  try{
    const a = typeof s==='string' ? JSON.parse(s) : s;
    if(!Array.isArray(a)) return;
    hotbar = Array(HOT_SIZE).fill(null);
    a.forEach((slot,i)=>{ if(i<HOT_SIZE) hotbar[i]=slot; });
  }catch(e){}
  // Seed default weapons if no weapon items are present anywhere in the hotbar.
  // Catches: brand new accounts, accounts with old null-only data, and
  // anyone whose weapon slots were stripped by an older save-state build.
  const hasWeapon = hotbar.some(s => s && INV_ITEMS[s.id] && INV_ITEMS[s.id].isWeapon);
  if(!hasWeapon){
    DEFAULT_HOTBAR.forEach((id,i)=>{ hotbar[i]={ id, qty:1 }; });
  }
}


function hcToggle(id){
  const h = HC.hacks[id];
  if(!h) return;
  h.on = !h.on;
  _renderAdminHacks();
  if(id==='esp'){ if(h.on) _hcBuildESP(); else _hcClearESP(); }
  addChatMessage('HACK CLIENT','['+h.label+'] '+(h.on?'ENABLED':'DISABLED'),false,true);
}

function _hcBuildESP(){
  _hcClearESP();
  for(const z of zombies){
    const g=new THREE.SphereGeometry(0.9,8,6);
    const m=new THREE.Mesh(g,new THREE.MeshBasicMaterial({color:0xff0000,wireframe:true,depthTest:false,transparent:true,opacity:0.55}));
    m.renderOrder=999; m._espTarget=z; scene.add(m); HC._espMeshes.push(m);
  }
}
function _hcClearESP(){
  for(const m of HC._espMeshes) scene.remove(m);
  HC._espMeshes=[];
}
function _hcTickESP(){
  HC._espMeshes=HC._espMeshes.filter(m=>{
    if(!zombies.includes(m._espTarget)){ scene.remove(m); return false; }
    m.position.copy(m._espTarget.mesh.position); m.position.y+=0.9; return true;
  });
  for(const z of zombies){
    if(!HC._espMeshes.find(m=>m._espTarget===z)){
      const m2=new THREE.Mesh(new THREE.SphereGeometry(0.9,8,6),new THREE.MeshBasicMaterial({color:0xff0000,wireframe:true,depthTest:false,transparent:true,opacity:0.55}));
      m2.renderOrder=999; m2._espTarget=z; scene.add(m2); HC._espMeshes.push(m2);
    }
  }
}

function _hcTick(){
  const h=HC.hacks;
  // rapidFire: halves cooldown instead of removing it entirely
  if(h.rapidFire.on && weaponCooldown>0) weaponCooldown=Math.max(0,weaponCooldown-1);
  // godMode: slow regen only (2 HP/s), not instant lock at max
  if(h.godMode.on){ if(myHp<100+maxHpBonus && Math.random()<0.033){ myHp=Math.min(100+maxHpBonus,myHp+1); updateHUD(); } }
  // killAura: radius reduced from 8m to 3m, and rate-limited to one kill per 30 frames
  if(h.killAura.on){ HC._killAuraTimer=(HC._killAuraTimer||0)+1; if(HC._killAuraTimer>=30){ HC._killAuraTimer=0; for(let i=zombies.length-1;i>=0;i--){ if(camera.position.distanceToSquared(zombies[i].mesh.position)<9){ zombies[i].hp=0; break; } } } }
  // coinRain: +10 every 6s (rate limiter still applies on top of this)
  if(h.coinRain.on){ HC._coinTimer++; if(HC._coinTimer>=360){ HC._coinTimer=0; addCoins(10); showFloatPop('+10 ‚¨° HACK','#00ff88'); } }
  if(h.esp.on) _hcTickESP();
  if(h.noRecoil.on) _fpRecoilT=0;

  // HPL scripts tick
  const activeScripts = HC.scripts.filter(s=>s.active);
  // Reset HPL multipliers each tick before scripts apply them
  HC._hplSpeedMult=1; HC._hplDmgMult=1; HC._hplGravMult=1; HC._hplJumpMult=1;
  for(const s of activeScripts){
    // EVERY timers
    for(const t of s.everyTimers){ t.frame++; if(t.frame>=t.n){ t.frame=0; _hplExec(t.code,s); } }
    // ON_FRAME
    _hplExec(s.onFrameHooks,s);
    // IF checks
    for(const chk of s.ifChecks){
      const cur=_hplGetProp(chk.prop);
      const val=_hplResolve(chk.val,s);
      let ok=false;
      if(chk.op==='<') ok=cur<val; else if(chk.op==='>') ok=cur>val;
      else if(chk.op==='<=') ok=cur<=val; else if(chk.op==='>=') ok=cur>=val;
      else if(chk.op==='==') ok=cur==val; else if(chk.op==='!=') ok=cur!=val;
      if(ok) _hplExec(chk.code,s);
    }
    // Kill aura from script
    if(s.killAura>0){ const rsq=s.killAura*s.killAura; for(let i=zombies.length-1;i>=0;i--){ if(camera.position.distanceToSquared(zombies[i].mesh.position)<rsq) zombies[i].hp=0; } }
    // ESP from script
    if(s.espEnabled && !h.esp.on){ h.esp.on=true; _hcBuildESP(); _renderAdminHacks(); }
  }
}

function _hplExecOnShoot(){
  for(const s of HC.scripts.filter(sc=>sc.active)) _hplExec(s.onShootHooks,s);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
//  HPL INTERPRETER
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function _hplResolve(v, s){
  if(s && s.vars[v]!==undefined) return s.vars[v];
  if(v==='MAX'||v==='max') return 'MAX';
  if(v==='INF'||v==='INFINITE'||v==='INFINITY'||v==='inf') return Infinity;
  if(v==='ZERO'||v==='zero') return 0;
  const n=parseFloat(v); return isNaN(n)?v:n;
}
function _hplGetProp(prop){
  switch(prop.toLowerCase()){
    case 'player.hp': return myHp;
    case 'player.coins': return coins;
    case 'player.speed': return HC._hplSpeedMult;
    case 'player.damage': return HC._hplDmgMult;
    case 'player.gravity': return HC._hplGravMult;
    case 'player.jump': return HC._hplJumpMult;
    case 'player.level': return playerLevel;
    case 'player.kills': return kills;
    case 'player.ammo.rifle': return ammo.rifle||0;
    case 'player.ammo.shotgun': return ammo.shotgun||0;
    case 'player.ammo.laser': return ammo.laser||0;
    case 'player.ammo.sniper': return ammo.sniper||0;
    default: return 0;
  }
}
function _hplSetProp(prop, val){
  switch(prop.toLowerCase()){
    // player.hp, player.coins, player.damage, player.level ‚Äî BLOCKED
    // These are server-validated and setting them via HPL does nothing.
    case 'player.hp':     break; // blocked ‚Äî server controls HP
    case 'player.coins':  break; // blocked ‚Äî server controls coins
    case 'player.damage': break; // blocked ‚Äî use caliber upgrades in shop
    case 'player.level':  break; // blocked ‚Äî server controls level
    // Movement multipliers ‚Äî capped to reasonable values
    case 'player.speed':   HC._hplSpeedMult=Math.min(val===Infinity?1.3:val, 1.3); break;
    case 'player.gravity': HC._hplGravMult=Math.max(0.75,val); break;
    case 'player.jump':    HC._hplJumpMult=Math.min(val===Infinity?1.4:val, 1.4); break;
    // Ammo ‚Äî still works but capped at 2√ó max ammo
    case 'player.ammo':    if(val===Infinity) HC.hacks.infiniteAmmo.on=true; break;
    case 'player.ammo.rifle':   ammo.rifle=Math.min(val===Infinity?MAX_AMMO.rifle*2:val, MAX_AMMO.rifle*2); updateAmmoHUD(); break;
    case 'player.ammo.shotgun': ammo.shotgun=Math.min(val===Infinity?MAX_AMMO.shotgun*2:val, MAX_AMMO.shotgun*2); updateAmmoHUD(); break;
    case 'player.ammo.laser':   ammo.laser=Math.min(val===Infinity?MAX_AMMO.laser*2:val, MAX_AMMO.laser*2); updateAmmoHUD(); break;
    case 'player.ammo.sniper':  ammo.sniper=Math.min(val===Infinity?MAX_AMMO.sniper*2:val, MAX_AMMO.sniper*2); updateAmmoHUD(); break;
  }
}
function _hplAddProp(prop, val){
  if(isNaN(val)||val===Infinity) return;
  switch(prop.toLowerCase()){
    case 'player.hp':     break; // blocked
    case 'player.coins':  break; // blocked ‚Äî goes through addCoins rate limiter anyway
    case 'player.kills':  break; // blocked
    case 'player.ammo.rifle':   ammo.rifle=Math.min(ammo.rifle+val, MAX_AMMO.rifle*2); updateAmmoHUD(); break;
    case 'player.ammo.shotgun': ammo.shotgun=Math.min(ammo.shotgun+val, MAX_AMMO.shotgun*2); updateAmmoHUD(); break;
    case 'player.ammo.laser':   ammo.laser=Math.min(ammo.laser+val, MAX_AMMO.laser*2); updateAmmoHUD(); break;
    case 'player.ammo.sniper':  ammo.sniper=Math.min(ammo.sniper+val, MAX_AMMO.sniper*2); updateAmmoHUD(); break;
  }
}
function _hplExec(cmds, s){
  for(const cmd of cmds){
    if(cmd.type==='set')        _hplSetProp(cmd.prop, _hplResolve(cmd.val,s));
    else if(cmd.type==='add')   _hplAddProp(cmd.prop, _hplResolve(cmd.val,s));
    else if(cmd.type==='print') htPrint('> '+cmd.msg,'ht-ok');
    else if(cmd.type==='kill_aura'){ const rsq=cmd.radius*cmd.radius; for(let i=zombies.length-1;i>=0;i--){ if(camera.position.distanceToSquared(zombies[i].mesh.position)<rsq) zombies[i].hp=0; } }
    else if(cmd.type==='esp')   { if(!HC.hacks.esp.on){ HC.hacks.esp.on=true; _hcBuildESP(); } }
    // teleport blocked ‚Äî caught by server anticheat anyway
  }
}

function hplCompile(source){
  const result={
    name:'UNNAMED_HACK',
    vars:{},
    everyTimers:[],
    onFrameHooks:[],
    onShootHooks:[],
    ifChecks:[],
    espEnabled:false,
    killAura:0,
    active:false,
    source,
    errors:[],
  };
  const lines=source.split(/\r?\n/);
  let i=0;

  function parseSingleLine(line){
    line=line.trim();
    if(!line||line.startsWith('//')) return null;
    // VAR
    const varM=line.match(/^VAR\s+(\w+)\s*=\s*(.+)$/i);
    if(varM){ let v=varM[2].trim().replace(/^["']|["']$/g,''); if(!isNaN(v)) v=parseFloat(v); result.vars[varM[1]]=v; if(/^hack_name$/i.test(varM[1])) result.name=String(v); return null; }
    // HACK_NAME
    const hnM=line.match(/^HACK_NAME\s+["'](.+)["']/i);
    if(hnM){ result.name=hnM[1]; return null; }
    // ENABLE ESP
    if(/^ENABLE\s+ESP/i.test(line)) return {type:'esp'};
    // KILL_AURA
    const kaM=line.match(/^KILL_AURA\s+([0-9.]+)/i);
    if(kaM) return {type:'kill_aura',radius:parseFloat(kaM[1])};
    // TELEPORT
    const tpM=line.match(/^TELEPORT\s+([0-9.-]+)\s+([0-9.-]+)\s+([0-9.-]+)/i);
    if(tpM) return {type:'teleport',x:parseFloat(tpM[1]),y:parseFloat(tpM[2]),z:parseFloat(tpM[3])};
    // PRINT
    const prM=line.match(/^PRINT\s+["'](.+)["']/i);
    if(prM) return {type:'print',msg:prM[1]};
    // SET
    const setM=line.match(/^SET\s+([\w.]+)\s*=\s*(.+)$/i);
    if(setM) return {type:'set',prop:setM[1].toLowerCase(),val:setM[2].trim()};
    // ADD
    const addM=line.match(/^ADD\s+([\w.]+)\s*=\s*(.+)$/i);
    if(addM) return {type:'add',prop:addM[1].toLowerCase(),val:addM[2].trim()};
    return null;
  }
  function parseBlock(){
    const cmds=[]; i++;
    while(i<lines.length){
      const ln=lines[i].trim();
      if(ln==='}') { i++; return cmds; }
      const cmd=parseSingleLine(ln);
      if(cmd) cmds.push(cmd);
      i++;
    }
    return cmds;
  }

  while(i<lines.length){
    const line=lines[i].trim();
    const evM=line.match(/^EVERY\s+([0-9]+)\s*\{/i);
    if(evM){ const code=parseBlock(); result.everyTimers.push({n:parseInt(evM[1]),frame:0,code}); continue; }
    if(/^ON_FRAME\s*\{/i.test(line)){ const code=parseBlock(); result.onFrameHooks.push(...code); continue; }
    if(/^ON_SHOOT\s*\{/i.test(line)){ const code=parseBlock(); result.onShootHooks.push(...code); continue; }
    const ifM=line.match(/^IF\s+([\w.]+)\s*(<=|>=|<|>|==|!=)\s*(\S+)\s*\{/i);
    if(ifM){ const code=parseBlock(); result.ifChecks.push({prop:ifM[1],op:ifM[2],val:ifM[3],code}); continue; }
    const cmd=parseSingleLine(line);
    if(cmd){
      if(cmd.type==='esp') result.espEnabled=true;
      else if(cmd.type==='kill_aura') result.killAura=Math.max(result.killAura,cmd.radius);
    }
    i++;
  }
  return result;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
//  ADMIN HACKS TAB RENDERER
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function _renderAdminHacks(){
  const builtinEl=document.getElementById('admin-hacks-builtin');
  const scriptsEl=document.getElementById('admin-hacks-scripts');
  if(!builtinEl||!scriptsEl) return;

  // Built-in hacks
  let html='';
  for(const [id,h] of Object.entries(HC.hacks)){
    html+=`<div class="hc-row${h.on?' hc-active':''}">
      <div class="hc-left">
        <span class="hc-label">${h.label}</span>
        <span class="hc-desc">${h.desc}</span>
      </div>
      <button class="hc-btn" onclick="hcToggle('${id}')">${h.on?'ON ‚úì':'OFF'}</button>
    </div>`;
  }
  builtinEl.innerHTML=html;

  // HPL scripts
  if(HC.scripts.length===0){
    scriptsEl.innerHTML='<span style="color:#224422;font-size:11px;font-style:italic">No HPL scripts loaded. Use HACK_TERMINAL to upload.</span>';
    return;
  }
  let sh='';
  for(let idx=0;idx<HC.scripts.length;idx++){
    const s=HC.scripts[idx];
    const preview=s.source.split('\n').slice(0,2).join(' ').substring(0,60);
    sh+=`<div class="hc-script-row${s.active?' hc-active':''}">
      <div class="hc-left">
        <span class="hc-script-name">‚óà ${s.name}</span>
        <span class="hc-script-source">${preview}...</span>
      </div>
      <div class="hc-script-btns">
        <button class="hc-sbtn" onclick="hplToggleScript(${idx})">${s.active?'DEACTIVATE':'ACTIVATE'}</button>
        <button class="hc-sbtn danger" onclick="hplRemoveScript(${idx})">‚úï</button>
      </div>
    </div>`;
  }
  scriptsEl.innerHTML=sh;
}

function hplToggleScript(idx){
  const s=HC.scripts[idx];
  if(!s) return;
  s.active=!s.active;
  if(s.active){
    // Apply top-level ESP/killAura
    if(s.espEnabled && !HC.hacks.esp.on){ HC.hacks.esp.on=true; _hcBuildESP(); }
    addChatMessage('HPL','Script "'+s.name+'" ACTIVATED',false,true);
  } else {
    addChatMessage('HPL','Script "'+s.name+'" DEACTIVATED',false,true);
  }
  _renderAdminHacks();
}

function hplRemoveScript(idx){
  const s=HC.scripts[idx];
  if(!s) return;
  HC.scripts.splice(idx,1);
  addChatMessage('HPL','Script "'+s.name+'" removed.',false,true);
  _renderAdminHacks();
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
//  HACK TERMINAL (login screen)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _htHistory=[];
let _htHistIdx=-1;

function showHackTerminal(){
  document.getElementById('auth-modal').classList.add('hacker-mode');
  document.getElementById('hack-terminal').classList.add('ht-visible');
  htPrint('','');
  htPrint(' ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó','ht-cmd');
  htPrint(' ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù    ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë','ht-cmd');
  htPrint(' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë','ht-cmd');
  htPrint(' ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë','ht-cmd');
  htPrint(' ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó       ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë','ht-cmd');
  htPrint(' ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù       ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù','ht-cmd');
  htPrint('','');
  htPrint(' HACK_TERMINAL v2.4.1 ‚Äî HPL Runtime Environment','ht-info');
  htPrint(' Connection established. Type "help" for commands.','ht-info');
  htPrint('','');
  setTimeout(()=>document.getElementById('ht-input').focus(),60);
}

function htPrint(msg, cls='ht-info'){
  const out=document.getElementById('ht-output');
  if(!out) return;
  const line=document.createElement('span');
  line.className='ht-line '+(cls||'ht-info');
  line.textContent=msg;
  out.appendChild(line);
  out.appendChild(document.createElement('br'));
  out.scrollTop=out.scrollHeight;
}

function htCommand(raw){
  const cmd=raw.trim();
  if(!cmd) return;
  _htHistory.unshift(cmd); _htHistIdx=-1;
  htPrint('C:\\HACKTERM> '+cmd,'ht-cmd');
  const parts=cmd.split(/\s+/);
  const verb=parts[0].toLowerCase();

  switch(verb){
    case 'help':
      htPrint('','');
      htPrint(' ‚îå‚îÄ TERMINAL COMMANDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê','ht-data');
      htPrint(' ‚îÇ  help                  show this help            ‚îÇ','ht-data');
      htPrint(' ‚îÇ  upload                upload a .zip with HPL    ‚îÇ','ht-data');
      htPrint(' ‚îÇ  list                  list loaded scripts       ‚îÇ','ht-data');
      htPrint(' ‚îÇ  activate <name>       activate a script         ‚îÇ','ht-data');
      htPrint(' ‚îÇ  deactivate <name>     deactivate a script       ‚îÇ','ht-data');
      htPrint(' ‚îÇ  info <name>           show script source        ‚îÇ','ht-data');
      htPrint(' ‚îÇ  remove <name>         delete a script           ‚îÇ','ht-data');
      htPrint(' ‚îÇ  status                show all hack status      ‚îÇ','ht-data');
      htPrint(' ‚îÇ  clear                 clear terminal            ‚îÇ','ht-data');
      htPrint(' ‚îÇ  exit                  close terminal            ‚îÇ','ht-data');
      htPrint(' ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò','ht-data');
      htPrint('','');
      htPrint(' ‚îå‚îÄ HPL LANGUAGE REFERENCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê','ht-info');
      htPrint(' ‚îÇ  HACK_NAME "My Hack"         set script name     ‚îÇ','ht-info');
      htPrint(' ‚îÇ  VAR speed_boost = 5.0       declare variable    ‚îÇ','ht-info');
      htPrint(' ‚îÇ  SET player.hp = MAX         set to maximum      ‚îÇ','ht-info');
      htPrint(' ‚îÇ  SET player.speed = 3.0      speed multiplier    ‚îÇ','ht-info');
      htPrint(' ‚îÇ  SET player.damage = 999     damage multiplier   ‚îÇ','ht-info');
      htPrint(' ‚îÇ  SET player.ammo = INF       infinite ammo       ‚îÇ','ht-info');
      htPrint(' ‚îÇ  SET player.gravity = 0.1    low gravity         ‚îÇ','ht-info');
      htPrint(' ‚îÇ  SET player.jump = 3.0       jump multiplier     ‚îÇ','ht-info');
      htPrint(' ‚îÇ  ADD player.coins = 1000     add coins           ‚îÇ','ht-info');
      htPrint(' ‚îÇ  KILL_AURA 10               kill enemies in 10m  ‚îÇ','ht-info');
      htPrint(' ‚îÇ  ENABLE ESP                 enemy outlines       ‚îÇ','ht-info');
      htPrint(' ‚îÇ  TELEPORT 0 1.65 0          teleport to XYZ      ‚îÇ','ht-info');
      htPrint(' ‚îÇ  EVERY 60 { ... }           run every 60 frames  ‚îÇ','ht-info');
      htPrint(' ‚îÇ  ON_FRAME { ... }           run every frame      ‚îÇ','ht-info');
      htPrint(' ‚îÇ  ON_SHOOT { ... }           run when shooting    ‚îÇ','ht-info');
      htPrint(' ‚îÇ  IF player.hp < 50 { ... }  conditional check    ‚îÇ','ht-info');
      htPrint(' ‚îÇ  PRINT "message"            print to terminal    ‚îÇ','ht-info');
      htPrint(' ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò','ht-info');
      break;

    case 'upload':
      htPrint('[*] Opening file selector ‚Äî select a .zip file...','ht-warn');
      document.getElementById('ht-file-input').click();
      break;

    case 'list':
      if(HC.scripts.length===0){ htPrint('[!] No scripts loaded.','ht-warn'); break; }
      htPrint('[*] Loaded HPL scripts:','ht-info');
      HC.scripts.forEach((s,i)=>{ htPrint('  ['+i+'] '+s.name+' ‚Äî '+(s.active?'ACTIVE':'inactive'),'s.active?ht-ok:ht-info'); });
      break;

    case 'activate':{
      const name=parts.slice(1).join(' ');
      const s=HC.scripts.find(sc=>sc.name.toLowerCase()===name.toLowerCase());
      if(!s){ htPrint('[!] Script not found: '+name,'ht-error'); break; }
      if(s.active){ htPrint('[!] Already active.','ht-warn'); break; }
      s.active=true;
      if(s.espEnabled && !HC.hacks.esp.on){ HC.hacks.esp.on=true; _hcBuildESP(); }
      htPrint('[+] Script "'+s.name+'" activated.','ht-ok');
      _renderAdminHacks();
      break; }

    case 'deactivate':{
      const name=parts.slice(1).join(' ');
      const s=HC.scripts.find(sc=>sc.name.toLowerCase()===name.toLowerCase());
      if(!s){ htPrint('[!] Script not found: '+name,'ht-error'); break; }
      s.active=false;
      htPrint('[-] Script "'+s.name+'" deactivated.','ht-warn');
      _renderAdminHacks();
      break; }

    case 'info':{
      const name=parts.slice(1).join(' ');
      const s=HC.scripts.find(sc=>sc.name.toLowerCase()===name.toLowerCase());
      if(!s){ htPrint('[!] Script not found: '+name,'ht-error'); break; }
      htPrint('--- SOURCE: '+s.name+' ---','ht-data');
      s.source.split(/\r?\n/).forEach(l=>htPrint('  '+l,'ht-data'));
      break; }

    case 'remove':{
      const name=parts.slice(1).join(' ');
      const idx=HC.scripts.findIndex(sc=>sc.name.toLowerCase()===name.toLowerCase());
      if(idx<0){ htPrint('[!] Script not found: '+name,'ht-error'); break; }
      htPrint('[-] Removed: '+HC.scripts[idx].name,'ht-warn');
      HC.scripts.splice(idx,1);
      _renderAdminHacks();
      break; }

    case 'status':
      htPrint('[*] BUILT-IN HACKS:','ht-info');
      for(const [id,h] of Object.entries(HC.hacks)){
        htPrint('  '+h.label+': '+(h.on?'ON':'off'),'');
      }
      htPrint('[*] HPL SCRIPTS: '+HC.scripts.length+' loaded, '+HC.scripts.filter(s=>s.active).length+' active','ht-info');
      break;

    case 'clear':
      document.getElementById('ht-output').innerHTML='';
      break;

    case 'exit':
      document.getElementById('auth-modal').classList.remove('hacker-mode');
      document.getElementById('hack-terminal').classList.remove('ht-visible');
      document.getElementById('auth-user').value='';
      break;

    default:
      htPrint('[!] Unknown command: '+verb+'. Type "help".','ht-error');
  }
  htPrint('','');
}

// Terminal key handler
document.addEventListener('DOMContentLoaded',()=>{
  const htInp=document.getElementById('ht-input');
  if(!htInp) return;
  htInp.addEventListener('keydown',e=>{
    if(e.code==='Enter'){ e.preventDefault(); const v=htInp.value; htInp.value=''; htCommand(v); }
    if(e.code==='ArrowUp'){ e.preventDefault(); if(_htHistory.length){ _htHistIdx=Math.min(_htHistIdx+1,_htHistory.length-1); htInp.value=_htHistory[_htHistIdx]; } }
    if(e.code==='ArrowDown'){ e.preventDefault(); _htHistIdx=Math.max(_htHistIdx-1,-1); htInp.value=_htHistIdx>=0?_htHistory[_htHistIdx]:''; }
  });

  // File picker handler
  const fp=document.getElementById('ht-file-input');
  if(fp) fp.addEventListener('change',async()=>{
    const file=fp.files[0]; if(!file) return;
    htPrint('[*] Reading: '+file.name,'ht-warn');
    fp.value='';
    try{
      const buf=await file.arrayBuffer();
      const zip=await JSZip.loadAsync(buf);
      htPrint('[+] Archive opened. Scanning for .txt files...','ht-info');
      let loaded=0;
      for(const [fname,fobj] of Object.entries(zip.files)){
        if(fobj.dir||!fname.endsWith('.txt')) continue;
        const src=await fobj.async('string');
        htPrint('[*] Compiling: '+fname,'ht-info');
        try{
          const hack=hplCompile(src);
          // Check for duplicate name
          const dup=HC.scripts.findIndex(s=>s.name===hack.name);
          if(dup>=0){ HC.scripts.splice(dup,1); htPrint('[!] Overwriting existing: '+hack.name,'ht-warn'); }
          HC.scripts.push(hack);
          htPrint('[+] Loaded: "'+hack.name+'" ('+src.split('\n').length+' lines)','ht-ok');
          if(hack.everyTimers.length) htPrint('    TIMERS: '+hack.everyTimers.length,'ht-data');
          if(hack.onFrameHooks.length) htPrint('    ON_FRAME hooks: '+hack.onFrameHooks.length,'ht-data');
          if(hack.onShootHooks.length) htPrint('    ON_SHOOT hooks: '+hack.onShootHooks.length,'ht-data');
          if(hack.ifChecks.length) htPrint('    IF checks: '+hack.ifChecks.length,'ht-data');
          if(hack.espEnabled) htPrint('    ESP: enabled','ht-data');
          if(hack.killAura>0) htPrint('    KILL_AURA: '+hack.killAura+'m radius','ht-data');
          loaded++;
          _renderAdminHacks();
        }catch(compErr){
          htPrint('[X] Parse error in '+fname+': '+compErr.message,'ht-error');
        }
      }
      if(loaded===0) htPrint('[!] No .txt files found in zip.','ht-warn');
      else htPrint('[‚úì] '+loaded+' script(s) loaded. Use "activate <name>" or Admin Console > Hacks tab.','ht-ok');
    }catch(zipErr){
      htPrint('[X] Failed to open zip: '+zipErr.message,'ht-error');
    }
  });
});
let shootCD = 0;

// Ammo per weapon (0 = unlimited for melee/special)
const ammo = { rifle:120, shotgun:32, laser:200, sniper:20, grenade:6, c4:4 };
// MAX_AMMO is mutable ‚Äî mag upgrades increase these values
const BASE_AMMO = { rifle:120, shotgun:32, laser:200, sniper:20, grenade:6, c4:4 };
const MAG_STEP  = { rifle:40,  shotgun:10, laser:60,  sniper:5, grenade:2, c4:1 }; // added per upgrade
let MAX_AMMO    = { ...BASE_AMMO }; // starts at base, grows with upgrades
let magLevel    = { rifle:0, shotgun:0, laser:0, sniper:0, grenade:0, c4:0 }; // upgrade counts

function getAmmo(w){ return ammo[w]??0; }
function useAmmo(w,n=1){ if(HC.hacks.infiniteAmmo.on) return; if(ammo[w]!==undefined) ammo[w]=Math.max(0,ammo[w]-n); updateAmmoHUD(); }
function addAmmo(w,n){ if(ammo[w]!==undefined){ ammo[w]=Math.min(MAX_AMMO[w],ammo[w]+n); updateAmmoHUD(); } }
function updateAmmoHUD(){
  const w=currentWeapon, a=ammo[w];
  const el=document.getElementById('ammo-val');
  if(!el) return;
  el.textContent = (a===undefined)?'‚àû':`${a} / ${MAX_AMMO[w]}`;
  el.style.color = (a!==undefined&&a===0)?'#f44':(a!==undefined&&a<MAX_AMMO[w]*0.25)?'#fa0':'#0f0';
}

// Per-weapon bullet geometry + material pairs (laser is elongated beam)
const bullets=[];
const _LASER_UP = new THREE.Vector3(0,1,0); // for orienting laser beams
const _wBullet = {
  rifle:  { geo: new THREE.SphereGeometry(0.07,4,4),              mat: new THREE.MeshBasicMaterial({color:0xffffff}) },
  shotgun:{ geo: new THREE.SphereGeometry(0.07,4,4),              mat: new THREE.MeshBasicMaterial({color:0xff8800}) },
  laser:  { geo: new THREE.CylinderGeometry(0.02,0.02,0.55,4),   mat: new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.92}) },
  sniper: { geo: new THREE.SphereGeometry(0.09,4,4),              mat: new THREE.MeshBasicMaterial({color:0xaaffff}) },
  grenade:{ geo: new THREE.SphereGeometry(0.10,8,6),               mat: new THREE.MeshLambertMaterial({color:0x3a5a28}) },
  c4:     { geo: new THREE.BoxGeometry(0.28,0.08,0.18),              mat: new THREE.MeshLambertMaterial({color:0xd4c89a}) },
};
// Aliases kept so remote-bullet receiver code still works
const bGeo   = _wBullet.rifle.geo;
const _bMats = { rifle:_wBullet.rifle.mat, shotgun:_wBullet.shotgun.mat, laser:_wBullet.laser.mat, sniper:_wBullet.sniper.mat, grenade:_wBullet.grenade.mat };

// Update HUD weapon label
function updateWeaponHUD() {
  const el = document.getElementById('gval');
  if (el) {
    el.textContent = (currentWeapon && WEAPONS[currentWeapon]) ? WEAPONS[currentWeapon].name : '‚Äî';
  }
}

// Switch weapon helper
function setWeapon(key) {
  if (!WEAPONS[key]) return;
  if (scoped) setScope(false);
  scopeZoomIdx = 0;
  currentWeapon = key;
  updateWeaponHUD();
  // Switch visible FP model
  Object.keys(_fpModels).forEach(k => _fpModels[k].visible = (k===key));
  updateAmmoHUD();
  renderHotbar(); // update active-weapon highlight
}

// Unequip current weapon (called when switching to an empty hotbar slot)
function clearWeapon() {
  if (scoped) setScope(false);
  scopeZoomIdx = 0;
  currentWeapon = null;
  updateWeaponHUD();
  Object.keys(_fpModels).forEach(k => _fpModels[k].visible = false);
  updateAmmoHUD();
  renderHotbar();
}


// ============================================================================
//  SCOPE SYSTEM (Sniper only)
// ============================================================================
const BASE_FOV  = 75;
const ZOOM_LEVELS = [4, 8, 12];   // magnification steps (scroll cycles through)
let scopeZoomIdx = 0;             // which zoom level is active
let scoped       = false;
let fovTarget    = BASE_FOV;
let fovCurrent   = BASE_FOV;

// Compute FOV from zoom magnification: fov = 2*atan(tan(BASE/2) / zoom)
function zoomToFov(zoom){
  return 2 * Math.atan(Math.tan((BASE_FOV * Math.PI/180) / 2) / zoom) * 180/Math.PI;
}

function setScope(on) {
  if (scoped === on) return;
  scoped = on;
  document.getElementById('scope').className = on ? 'active' : '';
  document.getElementById('crosshair').style.display = on ? 'none' : '';
  // Hide FP gun while scoped (scope overlay replaces it)
  _fpRig.visible = !on;
  if (on) {
    fovTarget = zoomToFov(ZOOM_LEVELS[scopeZoomIdx]);
    document.getElementById('scope-zoom').textContent = ZOOM_LEVELS[scopeZoomIdx] + '√ó';
  } else {
    fovTarget = BASE_FOV;
  }
}

function applyFovLerp() {
  // Called every frame from animate()
  const diff = fovTarget - fovCurrent;
  if (Math.abs(diff) > 0.05) {
    fovCurrent += diff * 0.2;
    camera.fov = fovCurrent;
    camera.updateProjectionMatrix();
  } else if (camera.fov !== fovTarget) {
    fovCurrent = fovTarget;
    camera.fov = fovTarget;
    camera.updateProjectionMatrix();
  }
}

// Right-click toggles scope (sniper only)
document.addEventListener('mousedown', e => {
  if (!document.pointerLockElement || dead || chatOpen) return;
  if (e.button === 2) {
    if (currentWeapon === 'sniper') setScope(!scoped);
    return;
  }
  if (e.button === 0) shoot();
});
document.addEventListener('contextmenu', e => e.preventDefault());

// Scroll wheel zooms while scoped, or does nothing otherwise
document.addEventListener('wheel', e => {
  if (!scoped || currentWeapon !== 'sniper') return;
  e.preventDefault();
  // Scroll down = zoom in (next level), scroll up = zoom out (prev level)
  scopeZoomIdx = (e.deltaY > 0)
    ? Math.min(scopeZoomIdx + 1, ZOOM_LEVELS.length - 1)
    : Math.max(scopeZoomIdx - 1, 0);
  fovTarget = zoomToFov(ZOOM_LEVELS[scopeZoomIdx]);
  document.getElementById('scope-zoom').textContent = ZOOM_LEVELS[scopeZoomIdx] + '√ó';
}, { passive: false });



// New shoot() using WEAPONS but keeping shootCD as a secondary gate
function shoot() {
  if (dead || paused || inCar) return;
  if (weaponCooldown > 0) return;
  if (!currentWeapon || !WEAPONS[currentWeapon]) return; // no weapon equipped ‚Äî nothing to shoot

  const w = WEAPONS[currentWeapon];
  // Block fire if out of ammo
  if(ammo[currentWeapon]!==undefined && ammo[currentWeapon]<=0){
    // Flash ammo counter red
    const el=document.getElementById('ammo-val'); if(el){el.style.color='#f44';}
    return;
  }
  weaponCooldown = w.cooldown;
  _fpRecoilT = 7;
  _hplExecOnShoot();

  // Base throw/fire direction
  const baseDir = new THREE.Vector3(
    -Math.sin(yaw)*Math.cos(pitch),
    Math.sin(pitch),
    -Math.cos(yaw)*Math.cos(pitch)
  ).normalize();

  // ‚îÄ‚îÄ C4 place ‚îÄ‚îÄ
  if(w.isC4){
    useAmmo('c4');
    placeC4();
    return;
  }

  // ‚îÄ‚îÄ Grenade throw ‚îÄ‚îÄ
  if(w.isGrenade){
    useAmmo('grenade');
    const spawnPos = camera.position.clone().addScaledVector(baseDir, 0.6);
    // Loft: always add a bit of upward arc so it clears obstacles
    const vx = baseDir.x * w.speed;
    const vy = baseDir.y * w.speed + 0.12;
    const vz = baseDir.z * w.speed;
    throwGrenade(false, spawnPos.x, spawnPos.y, spawnPos.z, vx, vy, vz);
    _chanSend({type:'broadcast', event:'grenade',
               payload:{x:spawnPos.x, y:spawnPos.y, z:spawnPos.z, vx, vy, vz}});
    return;
  }

  // ‚îÄ‚îÄ Regular bullet fire ‚îÄ‚îÄ
  useAmmo(currentWeapon);
  for (let i = 0; i < w.pellets; i++) {
    const dir = baseDir.clone();
    if (w.spread > 0) {
      dir.x += (Math.random() - 0.5) * w.spread;
      dir.y += (Math.random() - 0.5) * w.spread * 0.5;
      dir.z += (Math.random() - 0.5) * w.spread;
      dir.normalize();
    }
    const _wb = _wBullet[currentWeapon] || _wBullet.rifle;
    const b = new THREE.Mesh(_wb.geo, _wb.mat);
    b.position.copy(camera.position).addScaledVector(dir, 0.8);
    if(currentWeapon==='laser') b.quaternion.setFromUnitVectors(_LASER_UP, dir);
    b.userData = { vel: dir.clone().multiplyScalar(w.speed), life: 180, damage: w.damage * (HC.hacks.oneHitKill.on ? 2 : 1) * HC._hplDmgMult };
    scene.add(b);
    bullets.push(b);
    _chanSend({type:'broadcast', event:'bullet',
               payload:{x:b.position.x, y:b.position.y, z:b.position.z,
                        vx:b.userData.vel.x, vy:b.userData.vel.y, vz:b.userData.vel.z,
                        weapon:currentWeapon}});
  }
}

// ============================================================================
//  COIN + ZOMBIE SYSTEM
// ============================================================================
let coins = 0;
let damageMultiplier = 1.0; // shop upgrade: higher caliber
let nukeOwned = false; // one-time purchase
let maxHpBonus = 0;         // shop upgrade: max HP increase

// ‚îÄ‚îÄ Hardened economy functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Per-call and rolling-window caps so console tricks like addCoins(999999)
// are silently rejected. Boss rewards come through server-validated functions
// so they bypass addCoins() entirely and are not affected by these limits.
const _SEC_MAX_COIN_CALL    = 10000;   // max coins per single addCoins() call
const _SEC_MAX_COINS_WINDOW = 25000;   // max coins per 30s rolling window
const _SEC_MAX_XP_CALL      = 50000;   // max XP per single addXP() call
let   _coinWindowTotal = 0, _coinWindowStart = 0;

function addCoins(n){
  n = Number(n);
  if(!isFinite(n) || n <= 0) return;
  if(n > _SEC_MAX_COIN_CALL) n = _SEC_MAX_COIN_CALL;
  const now = Date.now();
  if(now - _coinWindowStart > 30000){ _coinWindowStart = now; _coinWindowTotal = 0; }
  if(_coinWindowTotal + n > _SEC_MAX_COINS_WINDOW) return;
  _coinWindowTotal += n;
  coins += n;
  updateHUD();
}
// Seal addCoins so `window.addCoins = ()=>{}` from the console silently does nothing
Object.defineProperty(window, 'addCoins', { value: addCoins, writable: false, configurable: false });
// Seal addXP for the same reason
Object.defineProperty(window, 'addXP',    { value: addXP,    writable: false, configurable: false });

// ‚îÄ‚îÄ Coin pickups (world objects) ‚îÄ‚îÄ
const coinPickups = [];
const _coinGeo = new THREE.CylinderGeometry(0.15,0.15,0.06,8);
const _coinMat = new THREE.MeshBasicMaterial({color:0xffd700});

function spawnCoin(x,y,z,val=5){
  const m=new THREE.Mesh(_coinGeo,_coinMat);
  m.position.set(x,y+0.12,z);
  m.rotation.x=Math.PI/2;
  scene.add(m);
  coinPickups.push({mesh:m,x,y:y+0.12,z,t:0,val});
}

function updateCoins(){
  for(let i=coinPickups.length-1;i>=0;i--){
    const c=coinPickups[i];
    c.t+=0.04;
    c.mesh.position.y = c.y + Math.sin(c.t)*0.08;
    c.mesh.rotation.z += 0.04;
    // Auto-collect if player walks over
    const dx=camera.position.x-c.x, dz=camera.position.z-c.z;
    if(dx*dx+dz*dz < 0.8){
      const _cv=Math.round((c.val||5)*getRebirthMult("coinmul"));
      addCoins(_cv);
      showCoinPop('+'+_cv);
      showFloatPop('+'+_cv+' ‚¨°','#ffd700');
      scene.remove(c.mesh);
      coinPickups.splice(i,1);
    }
  }
}

// Coin pop text
let _coinPopTimer=0;
function showCoinPop(txt){
  // Legacy coin pop (bottom centre)
  const el=document.getElementById('coin-pop');
  if(!el) return;
  el.textContent=txt;
  el.style.opacity='1';
  el.style.transform='translateY(0)';
  _coinPopTimer=80;
}

// Floating number popup ‚Äî spawns a self-removing div near crosshair
let _popOffset=0; // stagger multiple pops vertically
let _popResetTimer=null;
function showFloatPop(txt, color){
  const div=document.createElement('div');
  div.className='float-pop';
  div.textContent=txt;
  div.style.color=color||'#fff';
  div.style.bottom=(130+_popOffset*22)+'px';
  document.body.appendChild(div);
  _popOffset=(_popOffset+1)%6;
  clearTimeout(_popResetTimer);
  _popResetTimer=setTimeout(()=>{ _popOffset=0; },1200);
  setTimeout(()=>div.remove(),1150);
}

// ‚îÄ‚îÄ Shop god-mode ‚Äî check if inside shop building footprint ‚îÄ‚îÄ
function _inShopBuilding(){
  const px=camera.position.x, pz=camera.position.z;
  const pad=2; // extra padding so doorway arch and near-wall positions are covered
  return px>SHOP_X-SHOP_W/2-pad&&px<SHOP_X+SHOP_W/2+pad&&pz>SHOP_Z-SHOP_D/2-pad&&pz<SHOP_Z+SHOP_D/2+pad;
}
// Update god-mode indicator visibility each frame
function updateGodMode(){
  const el=document.getElementById('god-mode-indicator');
  if(el) el.style.display=(_inShopBuilding() || shopOpen)?'block':'none';
}

// ‚îÄ‚îÄ Zombie shared geometry + material ‚îÄ‚îÄ
const _zmG={
  head:  new THREE.BoxGeometry(0.40,0.36,0.40),
  torso: new THREE.BoxGeometry(0.55,0.60,0.28),
  hips:  new THREE.BoxGeometry(0.48,0.26,0.26),
  uArm:  new THREE.BoxGeometry(0.20,0.46,0.20),
  lArm:  new THREE.BoxGeometry(0.17,0.40,0.17),
  uLeg:  new THREE.BoxGeometry(0.22,0.50,0.22),
  lLeg:  new THREE.BoxGeometry(0.20,0.44,0.20),
  foot:  new THREE.BoxGeometry(0.23,0.10,0.36),
  hTop:  new THREE.BoxGeometry(0.44,0.20,0.44),
};
const _zmM={
  skin:  new THREE.MeshLambertMaterial({color:0x5a7a3a}),
  torso: new THREE.MeshLambertMaterial({color:0x2a3a1a}),
  leg:   new THREE.MeshLambertMaterial({color:0x1a2a0a}),
  eye:   new THREE.MeshBasicMaterial({color:0xff2200}),
};

function makeZombieModel(tier){
  const mat = tier ? getZombieMats(tier) : _zmM;
  const sc  = tier ? tier.scale : 1.0;
  const g=new THREE.Group();
  const add=(geo,m,x,y,z)=>{const mesh=new THREE.Mesh(geo,m);mesh.position.set(x*sc,y*sc,z*sc);g.add(mesh);};
  add(_zmG.head,  mat.skin,  0, 0.80, 0);
  add(_zmG.hTop,  mat.torso, 0, 0.96, 0);
  const eyeGeo=new THREE.BoxGeometry(0.08*sc,0.06*sc,0.05*sc);
  for(const ex of [-0.10,0.10]){
    const em=new THREE.Mesh(eyeGeo,mat.eye); em.position.set(ex*sc,0.82*sc,0.19*sc); g.add(em);
  }
  add(_zmG.torso, mat.torso, 0, 0.41, 0);
  add(_zmG.hips,  mat.torso, 0, 0.04, 0);
  for(const sx of[-1,1]){
    add(_zmG.uArm,mat.torso,sx*0.40, 0.37,0);
    add(_zmG.lArm,mat.skin, sx*0.40,-0.02,0);
    add(_zmG.uLeg,mat.leg,  sx*0.13,-0.36,0);
    add(_zmG.lLeg,mat.leg,  sx*0.13,-0.76,0);
    add(_zmG.foot,mat.torso,sx*0.13,-1.01,0.06);
  }
  g.scale.setScalar(sc);
  return g;
}

const zombies=[];
// Base stats ‚Äî actual per-zombie values come from tier
const ZOMBIE_ATK_DIST = 1.4;
const ZOMBIE_COIN_REWARD = 3;

// ‚îÄ‚îÄ Depth tier system ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// The zombie zone runs Z=5 (border) to Z=370 (deep end)
// Five tiers based on Z position of spawn point
const ZOMBIE_TIERS = [
  // { zMin, zMax, hp, damage, speed, atkCd, color, eyeColor, name, scale }
  { zMin:  5, zMax:  80, hp: 250, damage:15, speed:0.028, atkCd:90,  skinColor:0x5a7a3a, torsoColor:0x2a3a1a, eyeColor:0xff2200, name:'FERAL',    scale:1.00, spawnCap:28, interval:240, perTick:1 },
  { zMin: 80, zMax: 160, hp: 500, damage:28, speed:0.034, atkCd:75,  skinColor:0x7a6a20, torsoColor:0x4a4010, eyeColor:0xff5500, name:'RABID',    scale:1.06, spawnCap:36, interval:180, perTick:1 },
  { zMin:160, zMax: 250, hp: 950, damage:48, speed:0.042, atkCd:60,  skinColor:0x8a4a18, torsoColor:0x5a2808, eyeColor:0xff8800, name:'BLOATED',  scale:1.14, spawnCap:44, interval:130, perTick:2 },
  { zMin:250, zMax: 330, hp:1800, damage:80, speed:0.052, atkCd:45,  skinColor:0x7a2010, torsoColor:0x4a0808, eyeColor:0xffaa00, name:'BERSERKER',scale:1.24, spawnCap:52, interval: 90, perTick:2 },
  { zMin:330, zMax: 999, hp:3500, damage:140,speed:0.065, atkCd:30,  skinColor:0x1a0808, torsoColor:0x0a0404, eyeColor:0xff00ff, name:'ABOMINATION',scale:1.38,spawnCap:60,interval:65, perTick:3 },
];

function getZombieTier(spawnZ){
  for(const t of ZOMBIE_TIERS) if(spawnZ>=t.zMin && spawnZ<t.zMax) return t;
  return ZOMBIE_TIERS[ZOMBIE_TIERS.length-1];
}

// Per-tier material cache (created lazily, one set per tier)
const _zmTierMats = {};
function getZombieMats(tier){
  if(_zmTierMats[tier.name]) return _zmTierMats[tier.name];
  const m = {
    skin:  new THREE.MeshLambertMaterial({color:tier.skinColor}),
    torso: new THREE.MeshLambertMaterial({color:tier.torsoColor}),
    leg:   new THREE.MeshLambertMaterial({color:tier.torsoColor}),
    eye:   new THREE.MeshBasicMaterial({color:tier.eyeColor}),
  };
  _zmTierMats[tier.name] = m;
  return m;
}

let zombieSpawnTimer = 0;
// Interval + perTick computed dynamically from player depth (see updateZombies)

function spawnZombie(){
  const pz = camera.position.z;
  const pInZone = pz > 2;
  // Compute current tier from player depth for the spawn cap
  const playerTier = getZombieTier(Math.max(5, pz));
  if(zombies.length >= playerTier.spawnCap) return;

  // Bias spawn Z toward player depth (¬± scatter)
  let x, spawnZ;
  for(let t=0;t<30;t++){
    if(pInZone){
      spawnZ = Math.max(5, pz + 14 + Math.random()*30);
      x = camera.position.x + (Math.random()-0.5)*50;
    } else {
      spawnZ = 5 + Math.random()*80;
      x = (Math.random()-0.5)*120;
    }
    x=Math.max(-190,Math.min(190,x));
    spawnZ=Math.max(5,Math.min(370,spawnZ));
    if(!checkEnvCol({x,y:0,z:spawnZ})) break;
  }

  const tier = getZombieTier(spawnZ);
  // Scale by player level ‚Äî harder the further you've progressed
  const _lvScale = 1 + playerLevel * 0.10;
  const _dmgScale= 1 + playerLevel * 0.07;
  const scaledHp  = Math.round(tier.hp   * _lvScale);
  const scaledDmg = Math.round(tier.damage* _dmgScale);
  const mesh = makeZombieModel(tier);
  const flY  = getFloorY({x,y:GROUND_Y,z:spawnZ})-GROUND_Y;
  mesh.position.set(x,flY,spawnZ);
  scene.add(mesh);
  const hpSpr=makeHPSprite();
  hpSpr.position.set(x,flY+1.4*tier.scale,spawnZ);
  scene.add(hpSpr);
  drawHPBar(hpSpr,scaledHp,scaledHp);
  zombies.push({mesh,hpSpr,hp:scaledHp,maxHp:scaledHp,damage:scaledDmg,speed:tier.speed,atkCd:0,atkCdMax:tier.atkCd,walkT:0,tier});
}

function updateZombies(){
  // Dynamic spawn timer ‚Äî scales with player depth
  zombieSpawnTimer++;
  const _pTier = getZombieTier(Math.max(5, camera.position.z));
  if(zombieSpawnTimer >= _pTier.interval){
    zombieSpawnTimer=0;
    for(let _si=0;_si<_pTier.perTick;_si++) spawnZombie();
  }

  const px=camera.position.x, py=camera.position.y, pz=camera.position.z;
  for(let i=zombies.length-1;i>=0;i--){
    const z=zombies[i];
    if(z.hp<=0){
      // Drop coins, remove
      const np=z.mesh.position;
      const ti=z.tier ? ZOMBIE_TIERS.indexOf(z.tier) : 0;
      const minDrops=1+ti, maxDrops=3+ti*2;
      const drops=minDrops+Math.floor(Math.random()*(maxDrops-minDrops+1));
      const coinVal=5+ti*5; // 5/10/15/20/25 per pickup
      for(let d=0;d<drops;d++){
        const flY=getFloorY({x:np.x,y:GROUND_Y,z:np.z})-GROUND_Y;
        spawnCoin(np.x+(Math.random()-0.5)*1.5, flY, np.z+(Math.random()-0.5)*1.5, coinVal);
      }
      scene.remove(z.mesh); scene.remove(z.hpSpr);
      zombies.splice(i,1); continue;
    }

    const zx=z.mesh.position.x, zz=z.mesh.position.z;
    const dx=px-zx, dz=pz-zz;
    const dist=Math.sqrt(dx*dx+dz*dz);

    // Face player (only when reachable ‚Äî same vertical level or close enough)
    const _vertReach = Math.abs(camera.position.y - (z.mesh.position.y + 1.0)) < FLOOR_H;
    if(_vertReach) z.mesh.rotation.y=Math.atan2(dx,dz);

    // Walk animation ‚Äî bob torso
    z.walkT+=0.15;
    if(dist>ZOMBIE_ATK_DIST) z.mesh.position.y += Math.sin(z.walkT)*0.004;

    // Move toward player if alive
    if(!dead && dist>ZOMBIE_ATK_DIST){
      // EMP slow
      const empMult = z._empSlowed > 0 ? 0.25 : 1;
      if(z._empSlowed > 0) z._empSlowed--;
      const nx=zx+dx/dist*z.speed*empMult;
      const nz=zz+dz/dist*z.speed;
      // Hard zone boundary ‚Äî zombies NEVER cross into safe zone (Z < 2)
      if(nz < 2) continue;
      // Use GROUND_Y so wallColliders yMin check works (same space as player)
      // Try combined move, then X-only, then Z-only (wall sliding)
      if(!checkCollision({x:nx,y:GROUND_Y,z:nz})){
        const flY=getFloorY({x:nx,y:GROUND_Y,z:nz})-GROUND_Y;
        z.mesh.position.set(nx,flY,nz);
      } else if(!checkCollision({x:nx,y:GROUND_Y,z:zz})){
        const flY=getFloorY({x:nx,y:GROUND_Y,z:zz})-GROUND_Y;
        z.mesh.position.set(nx,flY,zz);
      } else if(!checkCollision({x:zx,y:GROUND_Y,z:nz})){
        const flY=getFloorY({x:zx,y:GROUND_Y,z:nz})-GROUND_Y;
        z.mesh.position.set(zx,flY,nz);
      }
    }

    // Attack player ‚Äî must be close in XZ AND within the same vertical level
    const zombieEyeY = z.mesh.position.y + 1.0;
    const vertGap = Math.abs(camera.position.y - zombieEyeY);
    if(!dead && dist<ZOMBIE_ATK_DIST && vertGap < 2.2){
      z.atkCd--;
      if(z.atkCd<=0){
        takeDamage(z.damage);
        z.atkCd=z.atkCdMax;
      }
    }

    // Update HP sprite
    z.hpSpr.position.set(z.mesh.position.x, z.mesh.position.y+1.4, z.mesh.position.z);

    // Bullet hits
    for(let bi=bullets.length-1;bi>=0;bi--){
      const b=bullets[bi];
      if(b.userData.isRemote) continue;
      if(b.position.distanceToSquared(z.mesh.position)<2.25){
        const dmg=Math.round((b.userData.damage||25)*damageMultiplier*getRebirthDmgMult());
        z.hp=Math.max(0,z.hp-dmg);
        drawHPBar(z.hpSpr,z.hp,z.maxHp);
        showFloatPop('-'+dmg, '#ff4444');
        if(z.hp<=0){ kills++; const _ti=z.tier?ZOMBIE_TIERS.indexOf(z.tier):0; const _kc=Math.round((10+_ti*10)*getRebirthMult("coinmul")); addCoins(_kc); const _xp=Math.round((XP_PER_TIER[_ti]||25)*getRebirthMult("xpgain")); addXP(_xp); showFloatPop('+'+_kc+' ‚¨°','#ffd700'); showFloatPop('+'+_xp+' XP','#00ffff'); showCoinPop('+'+_kc); updateHUD(); }
        showHitMarker();
        scene.remove(b); bullets.splice(bi,1);
        break;
      }
    }
    // (dummy target hits handled in updateBulletsDummies below)
  }

  updateCoins();
  if(typeof updateDummies!=="undefined") updateDummies();
  if(typeof updateBoss!=="undefined") updateBoss();
  if(typeof updateBulletsDummies!=="undefined") updateBulletsDummies();
  // Coin pop fade
  if(_coinPopTimer>0){
    _coinPopTimer--;
    const el=document.getElementById('coin-pop');
    if(el&&_coinPopTimer<20){ el.style.opacity=((_coinPopTimer)/20).toFixed(2); }
  }
}

// ============================================================================
//  COWS WITH GUNS ‚Äî danger zone enemies
// ============================================================================
// Shared cow geometry (reused across all instances)
const _cowG = {
  body:   new THREE.BoxGeometry(0.90, 0.55, 1.50),
  head:   new THREE.BoxGeometry(0.50, 0.46, 0.54),
  snout:  new THREE.BoxGeometry(0.30, 0.22, 0.18),
  ear:    new THREE.BoxGeometry(0.12, 0.20, 0.08),
  uLeg:   new THREE.BoxGeometry(0.20, 0.38, 0.20),
  lLeg:   new THREE.BoxGeometry(0.17, 0.36, 0.17),
  hoof:   new THREE.BoxGeometry(0.20, 0.10, 0.24),
  tail:   new THREE.BoxGeometry(0.07, 0.32, 0.07),
  gun:    new THREE.BoxGeometry(0.10, 0.10, 0.55),
  barrel: new THREE.BoxGeometry(0.07, 0.07, 0.36),
  stock:  new THREE.BoxGeometry(0.08, 0.20, 0.16),
};
const _cowMats = {
  body:  new THREE.MeshLambertMaterial({ color: 0xf5f0e8 }),
  patch: new THREE.MeshLambertMaterial({ color: 0x2a1a0a }),
  hoof:  new THREE.MeshLambertMaterial({ color: 0x1a1008 }),
  snout: new THREE.MeshLambertMaterial({ color: 0xffccaa }),
  eye:   new THREE.MeshBasicMaterial({ color: 0x111111 }),
  nose:  new THREE.MeshBasicMaterial({ color: 0xff6688 }),
  gun:   new THREE.MeshLambertMaterial({ color: 0x2a2a2a }),
  stock: new THREE.MeshLambertMaterial({ color: 0x6a3a10 }),
};

function makeCowModel(){
  const g = new THREE.Group();
  const add = (geo, mat, x, y, z, rx, ry, rz) => {
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x, y, z);
    if(rx) m.rotation.x = rx;
    if(ry) m.rotation.y = ry;
    if(rz) m.rotation.z = rz;
    g.add(m); return m;
  };
  // Body with black patches
  add(_cowG.body,  _cowMats.body,  0, 0.72, 0);
  const patchGeo = new THREE.BoxGeometry(0.32, 0.28, 0.14);
  add(patchGeo, _cowMats.patch,  0.44, 0.78,  0.20);
  add(patchGeo, _cowMats.patch, -0.44, 0.65, -0.30);
  // Head
  add(_cowG.head,  _cowMats.body,  0, 1.08, 0.82);
  add(_cowG.snout, _cowMats.snout, 0, 1.02, 1.12);
  const nostrilGeo = new THREE.BoxGeometry(0.06, 0.04, 0.04);
  add(nostrilGeo, _cowMats.nose, -0.08, 1.01, 1.22);
  add(nostrilGeo, _cowMats.nose,  0.08, 1.01, 1.22);
  const eyeGeo = new THREE.BoxGeometry(0.08, 0.08, 0.05);
  add(eyeGeo, _cowMats.eye, -0.18, 1.16, 1.08);
  add(eyeGeo, _cowMats.eye,  0.18, 1.16, 1.08);
  add(_cowG.ear, _cowMats.snout, -0.28, 1.26, 0.80);
  add(_cowG.ear, _cowMats.snout,  0.28, 1.26, 0.80);
  // Tail
  add(_cowG.tail, _cowMats.hoof, 0, 0.78, -0.80, 0.3);
  // Four legs
  for(const [lx, lz] of [[-0.32,-0.55],[0.32,-0.55],[-0.32,0.55],[0.32,0.55]]){
    add(_cowG.uLeg, _cowMats.body, lx, 0.34, lz);
    add(_cowG.lLeg, _cowMats.body, lx, 0.00, lz);
    add(_cowG.hoof, _cowMats.hoof, lx,-0.20, lz);
  }
  // Gun held on right side, pointing forward
  add(_cowG.gun,    _cowMats.gun,   0.46, 0.85, 0.55);
  add(_cowG.barrel, _cowMats.gun,   0.46, 0.85, 0.90);
  add(_cowG.stock,  _cowMats.stock, 0.46, 0.80, 0.30);
  // Muzzle flash (hidden until firing)
  const flashGeo = new THREE.BoxGeometry(0.12, 0.12, 0.08);
  const flashMat = new THREE.MeshBasicMaterial({ color: 0xffee44, transparent: true, opacity: 0 });
  const flash = new THREE.Mesh(flashGeo, flashMat);
  flash.position.set(0.46, 0.85, 1.14);
  g.add(flash);
  g.userData.muzzleFlash = flash;
  g.userData.muzzleFlashTimer = 0;
  return g;
}

const cows = [];
let cowSpawnTimer = 0;
let _cowT0SkipCounter = 0;

// Spawn params per tier index: very rare at T0‚ÄìT1, ramps up sharply at T3‚ÄìT5
function getCowSpawnParams(ti){
  return [
    { interval: 720, perCycle: 1, cap:  2 },  // T1 FERAL   ‚Äî 1 per ~12 zombie cycles
    { interval: 480, perCycle: 1, cap:  4 },  // T2 RABID   ‚Äî occasional
    { interval: 280, perCycle: 2, cap:  8 },  // T3 BLOATED
    { interval: 160, perCycle: 3, cap: 14 },  // T4 BERSERKER
    { interval:  90, perCycle: 4, cap: 20 },  // T5 ABOMINATION
  ][Math.min(ti, 4)];
}

function spawnCow(){
  const pz = camera.position.z;
  if(pz <= 2) return;
  const ti = ZOMBIE_TIERS.indexOf(getZombieTier(Math.max(5, pz)));
  const params = getCowSpawnParams(ti);
  if(cows.length >= params.cap) return;
  // Extra rarity gate at tier 0 ‚Äî only actually spawn 1-in-8 calls
  if(ti === 0){ _cowT0SkipCounter++; if(_cowT0SkipCounter < 8) return; _cowT0SkipCounter = 0; }
  let x, spawnZ;
  for(let t = 0; t < 30; t++){
    spawnZ = Math.max(5, pz + 14 + Math.random() * 30);
    x = camera.position.x + (Math.random() - 0.5) * 50;
    x = Math.max(-190, Math.min(190, x));
    spawnZ = Math.max(5, Math.min(370, spawnZ));
    if(!checkEnvCol({ x, y: 0, z: spawnZ })) break;
  }
  const tier = getZombieTier(spawnZ);
  const tierI = ZOMBIE_TIERS.indexOf(tier);
  const _lvS = 1 + playerLevel * 0.08;
  const hp  = Math.round(tier.hp   * 1.4 * _lvS);
  const dmg = Math.round(tier.damage * 1.2 * (1 + playerLevel * 0.06));
  const flY = getFloorY({ x, y: GROUND_Y, z: spawnZ }) - GROUND_Y;
  const mesh = makeCowModel();
  mesh.position.set(x, flY, spawnZ);
  scene.add(mesh);
  const hpSpr = makeHPSprite();
  hpSpr.position.set(x, flY + 1.7, spawnZ);
  scene.add(hpSpr);
  drawHPBar(hpSpr, hp, hp);
  cows.push({ mesh, hpSpr, hp, maxHp: hp, damage: dmg,
    speed: tier.speed * 0.85, shootCd: 0,
    shootCdMax: Math.max(40, 120 - tierI * 18),
    walkT: 0, tier, tierIndex: tierI });
}

function updateCowsWithGuns(){
  cowSpawnTimer++;
  const pz = camera.position.z;
  if(pz > 2){
    const ti = ZOMBIE_TIERS.indexOf(getZombieTier(Math.max(5, pz)));
    const p = getCowSpawnParams(ti);
    if(cowSpawnTimer >= p.interval){ cowSpawnTimer = 0; for(let i = 0; i < p.perCycle; i++) spawnCow(); }
  }
  const px = camera.position.x, cz2 = camera.position.z;
  for(let i = cows.length - 1; i >= 0; i--){
    const cow = cows[i];
    if(cow.hp <= 0){
      const np = cow.mesh.position;
      const drops = 2 + cow.tierIndex * 2;
      for(let d = 0; d < drops; d++){
        const flY2 = getFloorY({ x: np.x, y: GROUND_Y, z: np.z }) - GROUND_Y;
        spawnCoin(np.x + (Math.random()-0.5)*1.8, flY2, np.z + (Math.random()-0.5)*1.8, 12 + cow.tierIndex * 8);
      }
      scene.remove(cow.mesh); scene.remove(cow.hpSpr);
      cows.splice(i, 1); continue;
    }
    // Muzzle flash fade
    if(cow.mesh.userData.muzzleFlashTimer > 0){
      cow.mesh.userData.muzzleFlashTimer--;
      cow.mesh.userData.muzzleFlash.material.opacity = cow.mesh.userData.muzzleFlashTimer / 4;
    }
    const dx = px - cow.mesh.position.x, dz = cz2 - cow.mesh.position.z;
    const dist = Math.sqrt(dx*dx + dz*dz);
    cow.mesh.rotation.y = Math.atan2(dx, dz);
    cow.walkT += 0.10;
    cow.mesh.position.y += Math.sin(cow.walkT * 2) * 0.003;
    // Move toward player
    if(!dead && dist < 28){
      cow.mesh.position.x += (dx/dist) * cow.speed;
      cow.mesh.position.z += (dz/dist) * cow.speed;
      cow.hpSpr.position.x = cow.mesh.position.x;
      cow.hpSpr.position.z = cow.mesh.position.z;
    }
    // Shoot player
    if(!dead && dist < 20){
      cow.shootCd--;
      if(cow.shootCd <= 0){
        cow.shootCd = cow.shootCdMax + Math.floor(Math.random() * 30);
        const hitChance = Math.max(0.25, 1 - dist / 20 * 0.7);
        if(Math.random() < hitChance){ takeDamage(cow.damage); showFloatPop('üêÑ -' + cow.damage, '#ff8800'); }
        cow.mesh.userData.muzzleFlash.material.opacity = 1;
        cow.mesh.userData.muzzleFlashTimer = 4;
      }
    }
    // Headbutt at melee range
    if(!dead && dist < 1.8 && cow.shootCd <= 0){
      takeDamage(Math.round(cow.damage * 1.5));
      showFloatPop('üêÑ HEADBUTT!', '#ff4400');
      cow.shootCd = cow.shootCdMax;
    }
    // Bullet hits
    for(let bi = bullets.length - 1; bi >= 0; bi--){
      const b = bullets[bi];
      if(b.position.distanceToSquared(cow.mesh.position) < 3.0){
        const dmg = Math.round((b.userData.damage||25) * damageMultiplier * getRebirthDmgMult());
        cow.hp = Math.max(0, cow.hp - dmg);
        drawHPBar(cow.hpSpr, cow.hp, cow.maxHp);
        showFloatPop('-' + dmg, '#ff6600');
        if(cow.hp <= 0){
          kills++;
          addCoins(Math.round((18 + cow.tierIndex*14) * getRebirthMult('coinmul')));
          addXP(Math.round((40 + cow.tierIndex*35) * getRebirthMult('xpgain')));
          showFloatPop('+' + Math.round((18+cow.tierIndex*14)*getRebirthMult('coinmul')) + ' ‚¨°', '#ffd700');
          showCoinPop('+' + Math.round((18+cow.tierIndex*14)*getRebirthMult('coinmul')));
          updateHUD();
        }
        showHitMarker();
        scene.remove(b); bullets.splice(bi, 1); break;
      }
    }
  }
}

// ============================================================================
//  ONIONS ‚Äî passive safe-zone wanderers
// ============================================================================
// ‚îÄ‚îÄ Shared onion geometries ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _oG = {
  bulb:    new THREE.SphereGeometry(0.38, 10, 7),
  bodyBot: new THREE.SphereGeometry(0.30, 10, 7),
  neck:    new THREE.CylinderGeometry(0.12, 0.17, 0.22, 8),
  sprout:  new THREE.CylinderGeometry(0.03, 0.07, 0.38, 6),
  leaf:    new THREE.BoxGeometry(0.05, 0.28, 0.05),
  uArm:    new THREE.BoxGeometry(0.09, 0.24, 0.09),
  lArm:    new THREE.BoxGeometry(0.08, 0.20, 0.08),
  hand:    new THREE.SphereGeometry(0.065, 5, 4),
  uLeg:    new THREE.BoxGeometry(0.10, 0.24, 0.10),
  lLeg:    new THREE.BoxGeometry(0.09, 0.20, 0.09),
  foot:    new THREE.BoxGeometry(0.13, 0.07, 0.18),
  eyeW:    new THREE.SphereGeometry(0.065, 6, 4),
  pupil:   new THREE.SphereGeometry(0.038, 4, 4),
  smile:   new THREE.BoxGeometry(0.16, 0.035, 0.04),
  smEnd:   new THREE.BoxGeometry(0.035, 0.055, 0.04),
};
const _oMatEyeW  = new THREE.MeshLambertMaterial({ color: 0xffffff });
const _oMatPupil = new THREE.MeshBasicMaterial({ color: 0x111111 });
const _oMatSmile = new THREE.MeshBasicMaterial({ color: 0x3a1a00 });
const _oMatGreen = new THREE.MeshLambertMaterial({ color: 0x3aaa44 });

// Colour palettes: [skin, limb, hand]
const ONION_PALETTES = [
  [0xd4a017, 0xc49010, 0xf2d57e],  // golden
  [0xcc3366, 0xaa2244, 0xf08080],  // red
  [0x7a5cbf, 0x6040a0, 0xc0a8f0],  // purple
  [0x44aa55, 0x338844, 0x90dd90],  // spring green
  [0xd46010, 0xb04800, 0xf0a050],  // orange
  [0x5588cc, 0x3366aa, 0x88bbee],  // blue
];

function makeOnionModel(palette, sc){
  sc = sc || 1.0;
  const mSkin  = new THREE.MeshLambertMaterial({ color: palette[0] });
  const mLimb  = new THREE.MeshLambertMaterial({ color: palette[1] });
  const mHand  = new THREE.MeshLambertMaterial({ color: palette[2] });
  const mInner = new THREE.MeshLambertMaterial({ color: palette[2] });

  const root = new THREE.Group();
  root.scale.setScalar(sc);

  const addTo = (parent, geo, mat, x, y, z) => {
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x, y, z);
    parent.add(m); return m;
  };

  // Body
  addTo(root, _oG.bodyBot, mInner, 0, 0.38, 0);
  addTo(root, _oG.bulb,    mSkin,  0, 0.64, 0);
  addTo(root, _oG.neck,    mSkin,  0, 1.00, 0);
  // Sprout
  addTo(root, _oG.sprout, _oMatGreen, 0, 1.34, 0);
  const lL = new THREE.Mesh(_oG.leaf, _oMatGreen); lL.position.set(-0.07, 1.48, 0); lL.rotation.z =  0.32; root.add(lL);
  const lR = new THREE.Mesh(_oG.leaf, _oMatGreen); lR.position.set( 0.07, 1.48, 0); lR.rotation.z = -0.32; root.add(lR);
  const lF = new THREE.Mesh(_oG.leaf, _oMatGreen); lF.position.set(0, 1.50, 0.07); lF.rotation.x = -0.28; root.add(lF);
  // Face
  addTo(root, _oG.eyeW,  _oMatEyeW,  -0.12, 0.80, 0.34);
  addTo(root, _oG.eyeW,  _oMatEyeW,   0.12, 0.80, 0.34);
  addTo(root, _oG.pupil, _oMatPupil, -0.12, 0.80, 0.39);
  addTo(root, _oG.pupil, _oMatPupil,  0.12, 0.80, 0.39);
  addTo(root, _oG.smile, _oMatSmile,  0,    0.64, 0.37);
  addTo(root, _oG.smEnd, _oMatSmile, -0.08, 0.655, 0.37);
  addTo(root, _oG.smEnd, _oMatSmile,  0.08, 0.655, 0.37);

  // Arms ‚Äî pivot Groups at shoulder so rotation is clean
  const lSh = new THREE.Group(); lSh.position.set(-0.42, 0.76, 0);
  addTo(lSh, _oG.uArm, mLimb, 0, -0.13, 0);
  const lEl = new THREE.Group(); lEl.position.set(0, -0.26, 0); lSh.add(lEl);
  addTo(lEl, _oG.lArm, mLimb, 0, -0.11, 0);
  addTo(lEl, _oG.hand, mHand, 0, -0.22, 0);
  root.add(lSh);

  const rSh = new THREE.Group(); rSh.position.set(0.42, 0.76, 0);
  addTo(rSh, _oG.uArm, mLimb, 0, -0.13, 0);
  const rEl = new THREE.Group(); rEl.position.set(0, -0.26, 0); rSh.add(rEl);
  addTo(rEl, _oG.lArm, mLimb, 0, -0.11, 0);
  addTo(rEl, _oG.hand, mHand, 0, -0.22, 0);
  root.add(rSh);

  // Legs ‚Äî pivot Groups at hip
  const lHip = new THREE.Group(); lHip.position.set(-0.14, 0.18, 0);
  addTo(lHip, _oG.uLeg, mLimb, 0, -0.13, 0);
  const lKn = new THREE.Group(); lKn.position.set(0, -0.26, 0); lHip.add(lKn);
  addTo(lKn, _oG.lLeg, mLimb, 0, -0.11, 0);
  addTo(lKn, _oG.foot, mLimb, 0, -0.21, 0.05);
  root.add(lHip);

  const rHip = new THREE.Group(); rHip.position.set(0.14, 0.18, 0);
  addTo(rHip, _oG.uLeg, mLimb, 0, -0.13, 0);
  const rKn = new THREE.Group(); rKn.position.set(0, -0.26, 0); rHip.add(rKn);
  addTo(rKn, _oG.lLeg, mLimb, 0, -0.11, 0);
  addTo(rKn, _oG.foot, mLimb, 0, -0.21, 0.05);
  root.add(rHip);

  root.userData.pivots = { lSh, rSh, lHip, rHip };
  return root;
}

// ‚îÄ‚îÄ Speech bubble ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _onionBubbleEl = document.createElement('div');
_onionBubbleEl.style.cssText = [
  'position:fixed;pointer-events:none;z-index:500;',
  'background:rgba(255,255,255,0.93);color:#1a0a00;',
  "font-family:'Share Tech Mono',monospace;font-size:12px;line-height:1.5;",
  'padding:7px 12px;border-radius:10px;max-width:220px;text-align:center;',
  'border:2px solid #c49010;box-shadow:0 2px 12px rgba(0,0,0,0.4);',
  'transition:opacity 0.3s;opacity:0;white-space:normal;'
].join('');
const _onionBubbleTail = document.createElement('div');
_onionBubbleTail.style.cssText = [
  'position:absolute;bottom:-10px;left:50%;transform:translateX(-50%);',
  'width:0;height:0;',
  'border-left:8px solid transparent;border-right:8px solid transparent;',
  'border-top:10px solid rgba(255,255,255,0.93);'
].join('');
_onionBubbleEl.appendChild(_onionBubbleTail);
document.body.appendChild(_onionBubbleEl);

const ONION_PHRASES = [
  // Facts
  "Honey never expires. They found 3000-year-old honey in Egyptian tombs.",
  "A day on Venus is longer than a year on Venus.",
  "Octopuses have three hearts and blue blood.",
  "There are more possible chess games than atoms in the observable universe.",
  "Cleopatra lived closer in time to the Moon landing than to the pyramids.",
  "The Eiffel Tower grows ~15cm taller in summer due to heat expansion.",
  "Wombat poop is cube-shaped. Nobody fully knows why.",
  "Bananas are slightly radioactive.",
  "A group of flamingos is called a flamboyance.",
  "Crows can recognise human faces and hold grudges for years.",
  "The longest recorded flight of a chicken is 13 seconds.",
  "Slugs have four noses.",
  "The moon drifts 3.8cm farther from Earth every year.",
  "Sharks are older than trees.",
  "A bolt of lightning is five times hotter than the surface of the sun.",
  // Compliments
  "You look surprisingly well for someone in a war zone.",
  "Your shooting form is impeccable. Very clean elbow.",
  "I like your energy today. Very threatening, in a good way.",
  "Honestly? You are doing great. Keep it up.",
  "You carry yourself with a quiet dignity. Respect.",
  "Your reload speed is admirable.",
  "I do not say this to everyone, but: good job existing today.",
  "Those boots look really sturdy. Solid choice.",
  "You have excellent spatial awareness. I was watching.",
  // Insults
  "I have seen better movement from a shopping trolley.",
  "You walk like you have never had knees before.",
  "No offence but you kind of smell like gunpowder and regret.",
  "I have seen zombies with better posture.",
  "Your aim? Generous description. Chaotic.",
  "You remind me of someone. Specifically, someone bad.",
  "Not saying you are the worst player I have seen. But top three.",
  "Do you practise looking confused or does it come naturally?",
  "Statistically you should have died more by now. Lucky.",
  "You move like you are reading the controls for the first time.",
];

let _bubbleOnionIdx  = -1;
let _bubbleVisible   = false;
let _bubbleHideTimer = 0;
const BUBBLE_TALK_DIST = 5.0;
const BUBBLE_DURATION  = 280;
const BUBBLE_COOLDOWN  = 420;
const _onionCooldowns  = {};
const _onionProjV = new THREE.Vector3();

const onions = [];
const ONION_COUNT = 8;
const ONION_AREA  = { xMin: -55, xMax: 55, zMin: -80, zMax: -2 };

function spawnOnions(){
  for(let i = 0; i < ONION_COUNT; i++){
    const x   = ONION_AREA.xMin + Math.random() * (ONION_AREA.xMax - ONION_AREA.xMin);
    const z   = ONION_AREA.zMin + Math.random() * (ONION_AREA.zMax - ONION_AREA.zMin);
    const flY = getFloorY({ x, y: GROUND_Y, z }) - GROUND_Y;
    const palette = ONION_PALETTES[i % ONION_PALETTES.length];
    const sc  = 0.75 + Math.random() * 0.55;
    const mesh = makeOnionModel(palette, sc);
    mesh.position.set(x, flY, z);
    mesh.rotation.y = Math.random() * Math.PI * 2;
    scene.add(mesh);
    onions.push({
      mesh, sc,
      walkT: Math.random() * Math.PI * 2,
      wanderAngle: Math.random() * Math.PI * 2,
      wanderTimer: Math.floor(Math.random() * 180),
    });
  }
}

function updateOnions(){
  for(const k in _onionCooldowns) if(_onionCooldowns[k] > 0) _onionCooldowns[k]--;
  if(_bubbleVisible){
    _bubbleHideTimer--;
    if(_bubbleHideTimer <= 0){ _bubbleVisible=false; _onionBubbleEl.style.opacity='0'; _bubbleOnionIdx=-1; }
  }

  let closestDist = Infinity, closestIdx = -1;

  for(let oi = 0; oi < onions.length; oi++){
    const onion = onions[oi];
    const pv = onion.mesh.userData.pivots;

    // Wander
    onion.wanderTimer--;
    if(onion.wanderTimer <= 0){
      onion.wanderTimer = 160 + Math.floor(Math.random() * 200);
      onion.wanderAngle += (Math.random() - 0.5) * Math.PI * 1.5;
    }
    const nx = onion.mesh.position.x + Math.sin(onion.wanderAngle) * 0.011;
    const nz = onion.mesh.position.z + Math.cos(onion.wanderAngle) * 0.011;
    if(nx >= ONION_AREA.xMin && nx <= ONION_AREA.xMax &&
       nz >= ONION_AREA.zMin && nz <= ONION_AREA.zMax &&
       !checkEnvCol({ x: nx, y: 0, z: nz })){
      onion.mesh.position.x = nx;
      onion.mesh.position.z = nz;
    } else {
      onion.wanderAngle += Math.PI + (Math.random() - 0.5) * 0.9;
      onion.wanderTimer = 60;
    }
    onion.mesh.rotation.y = onion.wanderAngle;

    // Limb swing animation
    onion.walkT += 0.09;
    const sw = Math.sin(onion.walkT) * 0.38;
    pv.lSh.rotation.x  =  sw;   pv.rSh.rotation.x  = -sw;
    pv.lHip.rotation.x = -sw * 0.7; pv.rHip.rotation.x =  sw * 0.7;
    pv.lSh.rotation.z  =  0.22; pv.rSh.rotation.z   = -0.22;
    onion.mesh.position.y += Math.sin(onion.walkT * 2) * 0.002;

    // Distance to player
    const dx = camera.position.x - onion.mesh.position.x;
    const dz = camera.position.z - onion.mesh.position.z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    if(dist < closestDist){ closestDist = dist; closestIdx = oi; }
  }

  // Trigger speech when player walks up to an onion
  if(closestIdx >= 0 && closestDist < BUBBLE_TALK_DIST &&
     !dead && !paused && (_onionCooldowns[closestIdx] || 0) === 0 &&
     closestIdx !== _bubbleOnionIdx){
    const phrase = ONION_PHRASES[Math.floor(Math.random() * ONION_PHRASES.length)];
    _onionBubbleEl.innerHTML = '';
    const txt = document.createElement('span'); txt.textContent = phrase;
    _onionBubbleEl.appendChild(txt);
    _onionBubbleEl.appendChild(_onionBubbleTail);
    _bubbleVisible = true; _bubbleHideTimer = BUBBLE_DURATION;
    _bubbleOnionIdx = closestIdx; _onionCooldowns[closestIdx] = BUBBLE_COOLDOWN;
    _onionBubbleEl.style.opacity = '1';
  }

  // Position bubble above the currently talking onion
  if(_bubbleVisible && _bubbleOnionIdx >= 0 && onions[_bubbleOnionIdx]){
    const onion = onions[_bubbleOnionIdx];
    _onionProjV.set(onion.mesh.position.x, onion.mesh.position.y + 1.8 * onion.sc, onion.mesh.position.z);
    _onionProjV.project(camera);
    if(_onionProjV.z > 1){
      _onionBubbleEl.style.opacity = '0'; // behind camera
    } else {
      const sx = (_onionProjV.x  + 1) * window.innerWidth  / 2;
      const sy = (-_onionProjV.y + 1) * window.innerHeight / 2;
      const fade = _bubbleHideTimer < 40 ? (_bubbleHideTimer / 40).toFixed(2) : '1';
      _onionBubbleEl.style.opacity = fade;
      const bw = _onionBubbleEl.offsetWidth  || 180;
      const bh = _onionBubbleEl.offsetHeight || 60;
      _onionBubbleEl.style.left = (sx - bw / 2) + 'px';
      _onionBubbleEl.style.top  = (sy - bh - 10) + 'px';
    }
  }
}


function explosionDamageZombies(pos, radius, damage){
  // Boss hit from explosion
  if(activeBoss){
    const b=activeBoss;
    const dx=b.mesh.position.x-pos.x, dz=b.mesh.position.z-pos.z;
    const dist=Math.sqrt(dx*dx+dz*dz);
    if(dist<radius){
      const falloff=1-dist/radius;
      const dmg=Math.round(damage*falloff*damageMultiplier*getRebirthDmgMult());
      b.hp=Math.max(0,b.hp-dmg);
      drawHPBar(b.hpSpr,b.hp,b.maxHp);
      showFloatPop('-'+dmg,'#ff4444');
    }
  }
  const rsq=radius*radius;
  for(const z of zombies){
    const dsq=pos.distanceToSquared(z.mesh.position);
    if(dsq<rsq){
      const falloff=1-Math.sqrt(dsq)/radius;
      const dmg=Math.round(damage*falloff*damageMultiplier*getRebirthDmgMult());
      z.hp=Math.max(0,z.hp-dmg);
      drawHPBar(z.hpSpr,z.hp,z.maxHp||ZOMBIE_TIERS[0].hp);
      if(z.hp<=0){ kills++; const _ti2=z.tier?ZOMBIE_TIERS.indexOf(z.tier):0; const _kc2=Math.round((10+_ti2*10)*getRebirthMult("coinmul")); addCoins(_kc2); const _xp2=Math.round((XP_PER_TIER[_ti2]||25)*getRebirthMult("xpgain")); addXP(_xp2); showFloatPop('+'+_xp2+' XP','#00ffff'); showCoinPop('+'+_kc2+' COINS'); updateHUD(); }
    }
  }
  // Cows also take explosion damage
  for(const cow of cows){
    const dsq=pos.distanceToSquared(cow.mesh.position);
    if(dsq<rsq){
      const falloff=1-Math.sqrt(dsq)/radius;
      const dmg=Math.round(damage*falloff*damageMultiplier*getRebirthDmgMult());
      cow.hp=Math.max(0,cow.hp-dmg);
      drawHPBar(cow.hpSpr,cow.hp,cow.maxHp);
      if(cow.hp<=0){ kills++; addCoins(Math.round((18+cow.tierIndex*14)*getRebirthMult('coinmul'))); addXP(Math.round((40+cow.tierIndex*35)*getRebirthMult('xpgain'))); updateHUD(); }
    }
  }
}



// Check bullets against dummy targets (called from main loop)
function updateBulletsDummies(){
  if(!dummies.length) return;
  for(let bi=bullets.length-1;bi>=0;bi--){
    const b=bullets[bi];
    if(b.userData.isRemote) continue;
    let hit=false;
    for(const d of dummies){
      if(!d.alive) continue;
      if(b.position.distanceToSquared(d.mesh.position)<2.0){
        const dmg=Math.round((b.userData.damage||25)*damageMultiplier*getRebirthDmgMult());
        hitDummy(d,dmg);
        scene.remove(b); bullets.splice(bi,1);
        hit=true; break;
      }
    }
    if(hit) break;
  }
}


// ============================================================================
//  REBIRTH SYSTEM
// ============================================================================
let rebirthCount  = 0;   // how many rebirths taken
let rebirthBuffs  = {};  // { buffId: stackCount }

// Cost scales with rebirths: 500 √ó (1 + rebirthCount)
function rebirthCost(){ return 10000 + rebirthCount * 5000; }

// Buff catalogue ‚Äî applied multiplicatively on top of base stats
const REBIRTH_BUFFS = [
  { id:'dmg',    label:'‚öî BLADE CALIBER',  desc:'+8% damage per stack',   icon:'‚öî' },
  { id:'speed',  label:'‚ö° GHOST STRIDE',   desc:'+6% move speed per stack',icon:'‚ö°' },
  { id:'xpgain', label:'‚òÖ VETERAN MIND',   desc:'+15% XP gain per stack', icon:'‚òÖ' },
  { id:'coinmul',label:'‚¨° WAR PROFITEER',  desc:'+10% coins per stack',   icon:'‚¨°' },
  { id:'hpregen',label:'‚ù§ IRON FLESH',     desc:'+1 HP/s regen per stack', icon:'‚ù§' },
  { id:'explos', label:'üí• DEMO EXPERT',   desc:'+12% explosion dmg/stack',icon:'üí•' },
];

// How many buff stacks to pick from on each rebirth
const REBIRTH_BUFF_CHOICES = 3;

// Apply rebirthBuffs to stats ‚Äî called on load and after each rebirth
function getRebirthMult(id){ return 1 + (rebirthBuffs[id]||0) * {
  dmg:0.08, speed:0.06, xpgain:0.15, coinmul:0.10, hpregen:0, explos:0.12
}[id]; }

// For hpregen it's flat: stacks * 1 HP per second (60 HP per 3600 frames)
function getHPRegenPerFrame(){ return (rebirthBuffs.hpregen||0) / 60; }

// Movement speed multiplier (applied in movement tick)
function getSpeedMult(){ return getRebirthMult('speed') * (HC.hacks.speedHack.on ? 1.3 : 1) * HC._hplSpeedMult; }

// Damage multiplier contribution from rebirth
function getRebirthDmgMult(){ return getRebirthMult('dmg') * getRebirthMult('explos'); }

let _regenAccum = 0; // fractional HP accumulator for regen
function tickHPRegen(){
  if(dead || myHp <= 0) return;
  const maxHp = MAX_HP + maxHpBonus;
  if(myHp >= maxHp) return;
  _regenAccum += getHPRegenPerFrame();
  if(_regenAccum >= 1){
    const add = Math.floor(_regenAccum);
    _regenAccum -= add;
    myHp = Math.min(maxHp, myHp + add);
    updateHUD();
  }
}

// Rebirth: reset all upgrades, keep level/XP, apply chosen buff
async function doRebirth(buffId){
  if(coins < rebirthCost()) return;

  // ‚îÄ‚îÄ Server-side economy validation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const _res = await callEdgeFn('validate-action', {
    action: 'rebirth', username: accountUsername
  });
  if(!_res || !_res.success){
    if(_res && typeof _res.coins === 'number') coins = _res.coins;
    updateHUD(); return;
  }
  // Server deducted rebirthCost() and reset coins to 0 ‚Äî apply locally
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  coins -= rebirthCost();
  rebirthCount++;

  // ‚îÄ‚îÄ Full stat reset to new-account defaults ‚îÄ‚îÄ
  coins           = 0;
  maxHpBonus      = 0;
  damageMultiplier= 1.0;
  myHp            = MAX_HP;

  // Mag levels reset
  magLevel.rifle=0; magLevel.shotgun=0; magLevel.laser=0;
  magLevel.sniper=0; magLevel.grenade=0; magLevel.c4=0;

  // Max ammo back to base
  MAX_AMMO.rifle   = BASE_AMMO.rifle;
  MAX_AMMO.shotgun = BASE_AMMO.shotgun;
  MAX_AMMO.laser   = BASE_AMMO.laser;
  MAX_AMMO.sniper  = BASE_AMMO.sniper;
  MAX_AMMO.grenade = BASE_AMMO.grenade;
  MAX_AMMO.c4      = BASE_AMMO.c4;

  // ammo is const ‚Äî must reset each key individually
  ammo.rifle   = BASE_AMMO.rifle;
  ammo.shotgun = BASE_AMMO.shotgun;
  ammo.laser   = BASE_AMMO.laser;
  ammo.sniper  = BASE_AMMO.sniper;
  ammo.grenade = BASE_AMMO.grenade;
  ammo.c4      = BASE_AMMO.c4;

  // Switch to rifle so weapon state is clean
  setWeapon('rifle');

  // Apply chosen buff (stacks)
  rebirthBuffs[buffId] = (rebirthBuffs[buffId]||0) + 1;

  updateHUD(); updateAmmoHUD();
  closeRebirthScreen();
  showFloatPop('REBIRTH #'+rebirthCount+'!','#ff88ff');
  showFloatPop(REBIRTH_BUFFS.find(b=>b.id===buffId).label+' GAINED','#ffaaff');
  addChatMessage('','// REBIRTH #'+rebirthCount+' ‚Äî '+REBIRTH_BUFFS.find(b=>b.id===buffId).label+' UNLOCKED //',false,true);
}

let _rebirthChoices = []; // current buff choices shown on screen

function openRebirthScreen(){
  if(dead||!rebirthNPCInteractable) return;
  // Pick 3 random distinct buffs for this rebirth
  const shuffled=[...REBIRTH_BUFFS].sort(()=>Math.random()-0.5);
  _rebirthChoices = shuffled.slice(0,REBIRTH_BUFF_CHOICES);
  const screen = document.getElementById('rebirth-screen');
  const cost = rebirthCost();
  document.getElementById('rebirth-cost-display').textContent='‚¨° '+cost+' COINS';
  document.getElementById('rebirth-count-display').textContent='REBIRTH #'+(rebirthCount+1);
  document.getElementById('rebirth-afford').textContent = coins>=cost ? '‚úì CAN AFFORD' : '‚úó NOT ENOUGH COINS ('+coins+'/'+cost+')';
  document.getElementById('rebirth-afford').style.color = coins>=cost?'#0f0':'#f44';
  const grid=document.getElementById('rebirth-buff-grid');
  grid.innerHTML='';
  _rebirthChoices.forEach(b=>{
    const stacks=(rebirthBuffs[b.id]||0);
    const div=document.createElement('div');
    div.className='rebirth-item'+(coins<cost?' cant-afford':'');
    div.innerHTML=`<div class="rebirth-icon">${b.icon}</div>
<div class="rebirth-name">${b.label}</div>
<div class="rebirth-desc">${b.desc}</div>
<div class="rebirth-stack">Current stacks: ${stacks}</div>`;
    div.onclick=()=>{ if(coins>=cost) doRebirth(b.id); };
    grid.appendChild(div);
  });
  document.exitPointerLock();
  screen.classList.add('active');
}

function closeRebirthScreen(){
  document.getElementById('rebirth-screen').classList.remove('active');
}

// ============================================================================
//  SHOP SYSTEM
// ============================================================================
let shopOpen = false;

const SHOP_ITEMS = {
  heal:         { cost:40,  label:'MEDKIT' },
  ammo_rifle:   { cost:30,  label:'RIFLE AMMO' },
  ammo_shotgun: { cost:35,  label:'SHOTGUN AMMO' },
  ammo_laser:   { cost:45,  label:'LASER CELLS' },
  ammo_sniper:  { cost:50,  label:'SNIPER ROUNDS' },
  grenades:     { cost:60,  label:'EXPLOSIVES' },
  mag_grenade:  { cost:120, label:'GRENADE BAG UP' },
  mag_c4:       { cost:120, label:'C4 POUCH UP' },
  mag_rifle:    { cost:120, label:'RIFLE MAG UP' },
  mag_shotgun:  { cost:120, label:'SHOTGUN MAG UP' },
  mag_laser:    { cost:120, label:'LASER MAG UP' },
  mag_sniper:   { cost:120, label:'SNIPER MAG UP' },
  maxhp:        { cost:80,  label:'MAX HP UP' },
  caliber:      { cost:100, label:'HIGH CALIBER' },
  fullkit:      { cost:250, label:'FULL KIT' },
};

// ‚îÄ‚îÄ Weaponsmith items (ordnance + consumables) ‚îÄ‚îÄ
const WEAPON_ITEMS = {
  red_bull:       { cost:500,    label:'RED BULL',       fixedCost:true },
  emp_blast:      { cost:8000,   label:'EMP BLAST',      fixedCost:true },
  cruise_missile: { cost:40000,  label:'CRUISE MISSILE', fixedCost:true },
  mini_nuke:      { cost:75000,  label:'MINI NUKE',      fixedCost:true },
  nuke:           { cost:500000, label:'TACTICAL NUKE',  fixedCost:true },
};

// ‚îÄ‚îÄ Red Bull / fly state ‚îÄ‚îÄ
let redBullActive   = false;
let redBullTimer    = 0;
const RED_BULL_DURATION = 720; // 12 seconds at 60fps
const RED_BULL_FLY_SPEED = 0.08;
const RED_BULL_SPEED_MULT = 1.45; // +45% move speed while active

function drinkRedBull(){
  redBullActive = true;
  redBullTimer  = RED_BULL_DURATION;
  showFloatPop('üî¥ RED BULL ‚Äî FLY!', '#ff4444');
  addChatMessage('','// üî¥ RED BULL ‚Äî WINGS ACTIVATED FOR 12s //',false,true);
  const df=document.getElementById('death-flash');
  df.style.transition='none'; df.style.background='rgba(255,30,30,0.25)';
  setTimeout(()=>{ df.style.transition='background 0.8s'; df.style.background='rgba(0,0,0,0)'; },300);
  savePlayerState(); refreshWeaponUI();
}

function tickRedBull(){
  if(!redBullActive) return;
  redBullTimer--;
  // Flying controls ‚Äî override vertical with Space/Shift
  if(keys['Space'])  camera.position.y += RED_BULL_FLY_SPEED;
  if(keys['ShiftLeft']||keys['ShiftRight']) camera.position.y -= RED_BULL_FLY_SPEED;
  // Clamp: can fly up to 30 units high, never below ground
  camera.position.y = Math.max(GROUND_Y, Math.min(30, camera.position.y));
  if(redBullTimer <= 0){
    redBullActive = false;
    redBullTimer  = 0;
    // Float back to ground over 60 frames
    let landTick=0;
    function landStep(){
      landTick++;
      if(camera.position.y > GROUND_Y+0.05){
        camera.position.y = Math.max(GROUND_Y, camera.position.y - 0.12);
        if(landTick<120) requestAnimationFrame(landStep);
      } else {
        camera.position.y = GROUND_Y;
      }
    }
    requestAnimationFrame(landStep);
    addChatMessage('','// üî¥ RED BULL WORN OFF //',false,true);
    showFloatPop('üî¥ RED BULL EXPIRED', '#ff4444');
  }
  // HUD indicator
  const ind = document.getElementById('redbull-hud');
  if(ind){
    ind.style.display = redBullActive ? 'block' : 'none';
    if(redBullActive) ind.textContent = 'üî¥ RED BULL ' + Math.ceil(redBullTimer/60) + 's ‚úà';
  }
}

// ‚îÄ‚îÄ Weaponsmith NPC ‚îÄ‚îÄ
const WEAPON_NPC_X = SHOP_X + 2.8;
const WEAPON_NPC_Z = SHOP_Z + SHOP_D/2 - 1.8;
let weaponsmithMesh = null;
let weaponsmithInteractable = false;
let weaponsmithOpen = false;

function buildWeaponsmithNPC(){
  // Distinct model: dark clothes + helmet
  const g = new THREE.Group();
  const add = (geo,mat,x,y,z,rx=0,ry=0,rz=0)=>{ const m=new THREE.Mesh(geo,mat); m.position.set(x,y,z); m.rotation.set(rx,ry,rz); g.add(m); };
  const mSkin   = new THREE.MeshLambertMaterial({color:0xc8845a});
  const mArmor  = new THREE.MeshLambertMaterial({color:0x333344});
  const mHelmet = new THREE.MeshLambertMaterial({color:0x222233});
  const mVisor  = new THREE.MeshLambertMaterial({color:0x00aaff, transparent:true, opacity:0.7});
  const mBoot   = new THREE.MeshLambertMaterial({color:0x111111});
  const mStripe = new THREE.MeshLambertMaterial({color:0xff3300});
  // Head
  add(new THREE.BoxGeometry(0.40,0.40,0.38), mSkin,   0, 0.78, 0);
  // Helmet shell
  add(new THREE.BoxGeometry(0.46,0.28,0.44), mHelmet, 0, 0.93, 0);
  // Visor
  add(new THREE.BoxGeometry(0.38,0.14,0.06), mVisor,  0, 0.80, 0.20);
  // Torso ‚Äî tactical vest
  add(new THREE.BoxGeometry(0.54,0.60,0.32), mArmor,  0, 0.40, 0);
  // Chest stripe
  add(new THREE.BoxGeometry(0.08,0.44,0.04), mStripe, 0, 0.40, 0.17);
  // Shoulders pads
  add(new THREE.BoxGeometry(0.18,0.14,0.30), mArmor, -0.38, 0.55, 0);
  add(new THREE.BoxGeometry(0.18,0.14,0.30), mArmor,  0.38, 0.55, 0);
  // Hips
  add(new THREE.BoxGeometry(0.50,0.28,0.30), mArmor,  0, 0.04, 0);
  // Arms
  add(new THREE.BoxGeometry(0.22,0.48,0.24), mArmor, -0.38, 0.36, 0, -0.4);
  add(new THREE.BoxGeometry(0.22,0.48,0.24), mArmor,  0.38, 0.36, 0, -0.4);
  add(new THREE.BoxGeometry(0.20,0.30,0.20), mSkin,  -0.38,-0.02,-0.16);
  add(new THREE.BoxGeometry(0.20,0.30,0.20), mSkin,   0.38,-0.02,-0.16);
  // Legs
  for(const sx of[-1,1]){
    add(new THREE.BoxGeometry(0.24,0.40,0.28), mArmor, sx*0.13,-0.35,0);
    add(new THREE.BoxGeometry(0.22,0.38,0.26), mArmor, sx*0.13,-0.74,0);
    add(new THREE.BoxGeometry(0.24,0.14,0.34), mBoot,  sx*0.13,-0.99,0.05);
  }
  const pl = new THREE.PointLight(0x4466ff, 0.6, 4); pl.position.set(0,1.8,0); g.add(pl);
  g.userData.bobT = 0; g.userData.light = pl;
  weaponsmithMesh = g;
  g.position.set(WEAPON_NPC_X, 0.10, WEAPON_NPC_Z);
  g.rotation.y = Math.PI;
  scene.add(g);
  const lbl = makeNameSprite('WEAPONSMITH');
  lbl.position.set(WEAPON_NPC_X, 2.4, WEAPON_NPC_Z);
  scene.add(lbl);
}

function updateWeaponsmithNPC(){
  if(!weaponsmithMesh) return;
  weaponsmithMesh.userData.bobT += 0.022;
  weaponsmithMesh.position.y = 0.10 + Math.sin(weaponsmithMesh.userData.bobT)*0.009;
  weaponsmithMesh.userData.light.intensity = 0.6 + Math.sin(weaponsmithMesh.userData.bobT*1.8)*0.25;
  const dx=camera.position.x-WEAPON_NPC_X, dz=camera.position.z-WEAPON_NPC_Z;
  const near = dx*dx+dz*dz < SHOP_INTERACT_DIST*SHOP_INTERACT_DIST*1.4;
  if(near !== weaponsmithInteractable){ weaponsmithInteractable = near; }
}

function openWeaponsmith(){
  if(weaponsmithOpen||dead) return;
  weaponsmithOpen = true;
  _promptEl.style.display='none';
  document.exitPointerLock();
  document.getElementById('weaponsmith-screen').classList.add('active');
  refreshWeaponUI();
}
function closeWeaponsmith(){
  weaponsmithOpen = false;
  document.getElementById('weaponsmith-screen').classList.remove('active');
  renderer.domElement.requestPointerLock();
}

function refreshWeaponUI(){
  const coinEl = document.getElementById('weapon-coin-count');
  if(coinEl) coinEl.textContent = coins;
  document.querySelectorAll('.weapon-item').forEach(el=>{
    const key = el.dataset.item;
    if(!key||!WEAPON_ITEMS[key]) return;
    const def = WEAPON_ITEMS[key];
    el.classList.toggle('cant-afford', coins < def.cost);
    const costEl = el.querySelector('.weapon-item-cost');
    if(costEl) costEl.textContent = '‚¨° '+def.cost.toLocaleString()+' COINS';
  });
}

let buyFactor = 1; // global for both shops

function setBuyFactor(n){
  buyFactor = n;
  document.querySelectorAll('.bf-btn').forEach(b=>{
    b.classList.toggle('active', parseInt(b.dataset.bf)===n || (b.dataset.bf==='max' && n===9999));
  });
}

async function weaponBuy(item){
  const def = WEAPON_ITEMS[item];
  if(!def) return;
  // qty for fixed-cost ordnance is always 1 per click (missiles etc.)
  // But red_bull respects buyFactor
  const qty = (item==='red_bull') ? Math.min(buyFactor, Math.floor(coins/def.cost)) : 1;
  if(qty < 1 || coins < def.cost) return;

  // ‚îÄ‚îÄ Server-side economy validation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const _res = await callEdgeFn('validate-action', {
    action: 'weapon_buy', username: accountUsername, item, qty
  });
  if(!_res || !_res.success){
    if(_res && typeof _res.coins === 'number') coins = _res.coins;
    updateHUD(); refreshWeaponUI(); return;
  }
  coins = _res.coins;
  const confirmedQty = _res.qty || qty;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  // Add to inventory instead of activating immediately.
  // Player can drag item to hotbar and click to use it.
  const invDef = INV_ITEMS[item];  // renamed to avoid clash with WEAPON_ITEMS def above
  const addedOk = invAddItem(item, confirmedQty);
  if(addedOk && invDef){
    showFloatPop(invDef.icon + ' ' + invDef.label + ' ‚Üí INVENTORY', invDef.color || '#0f0');
    addChatMessage('', '// ' + invDef.icon + ' ' + invDef.label + ' added to inventory ‚Äî press I to open //', false, true);
  }
  updateHUD();
  refreshWeaponUI();
  savePlayerState();
}
// No cap on damage multiplier ‚Äî stacks indefinitely



function scaledCost(baseCost){
  return Math.round(baseCost * (1 + playerLevel * 0.08) / 5) * 5;
}

function getUpgradeLevel(key){
  switch(key){
    case 'maxhp':    return Math.round(maxHpBonus/25);
    case 'caliber':  return Math.round((damageMultiplier-1.0)/0.25);
    case 'mag_rifle':   return magLevel.rifle;
    case 'mag_shotgun': return magLevel.shotgun;
    case 'mag_laser':   return magLevel.laser;
    case 'mag_sniper':  return magLevel.sniper;
    case 'mag_grenade': return magLevel.grenade;
    case 'mag_c4':      return magLevel.c4;
    default: return -1; // not a levelable upgrade
  }
}

function openShop(){
  if(dead) return;
  if(!merchantInteractable) return;
  shopOpen = true;
  _promptEl.style.display='none';
  document.exitPointerLock();
  document.getElementById('shop-screen').classList.add('active');
  refreshShopUI();
}
function closeShop(){
  shopOpen = false;
  document.getElementById('shop-screen').classList.remove('active');
  // Restore interact prompt if still near NPC
  if(merchantInteractable) _promptEl.style.display='block';
}
// ‚îÄ‚îÄ Shop click delegation ‚Äî more reliable than inline onclick ‚îÄ‚îÄ
window.addEventListener('DOMContentLoaded', function(){
  document.getElementById('shop-grid').addEventListener('click', function(e){
    const item = e.target.closest('[data-item]');
    if(item) shopBuy(item.dataset.item);
  });
  const wGrid = document.getElementById('weapon-grid');
  if(wGrid) wGrid.addEventListener('click', function(e){
    const item = e.target.closest('[data-item]');
    if(item) weaponBuy(item.dataset.item);
  });
});

function refreshShopUI(){
  document.getElementById('shop-coin-count').textContent = coins;
  const wc = document.getElementById('weapon-coin-count');
  if(wc) wc.textContent = coins;
  // XP/level in shop header
  const xpEl=document.getElementById('shop-xp-display');
  if(xpEl) xpEl.textContent='LVL '+playerLevel+' ‚Äî '+playerXP+' XP';
  const items = document.querySelectorAll('.shop-item');
  items.forEach((el)=>{
    const key = el.dataset.item;
    if(!key || !SHOP_ITEMS[key]) return;
    const eff = SHOP_ITEMS[key].fixedCost ? SHOP_ITEMS[key].cost : scaledCost(SHOP_ITEMS[key].cost);
    // Fixed-cost items ‚Äî always show their exact base price, no level scaling
    if(SHOP_ITEMS[key].fixedCost){
      el.classList.toggle('cant-afford', coins < SHOP_ITEMS[key].cost);
      const costEl=el.querySelector('.shop-item-cost');
      if(costEl) costEl.textContent='‚¨° '+SHOP_ITEMS[key].cost.toLocaleString()+' COINS';
      return;
    }
    el.classList.toggle('cant-afford', coins < eff);
    // Update displayed cost live
    const costEl=el.querySelector('.shop-item-cost');
    if(costEl && SHOP_ITEMS[key].cost) costEl.dataset.base=SHOP_ITEMS[key].cost;
    if(costEl && costEl.dataset.base) costEl.textContent='‚¨° '+eff+' COINS';
    // Stamp upgrade level badge
    const lv = getUpgradeLevel(key);
    let badge = el.querySelector('.upgrade-lv');
    if(lv >= 0){
      if(!badge){ badge=document.createElement('div'); badge.className='upgrade-lv'; el.appendChild(badge); }
      badge.textContent='Lv '+lv;
    } else if(badge){ badge.remove(); }
  });
}
async function shopBuy(item){
  const def = SHOP_ITEMS[item];
  if(!def) return;
  const eff = def.fixedCost ? def.cost : scaledCost(def.cost);
  // Determine actual quantity (capped by affordability and stack logic)
  const qty = def.fixedCost ? 1 : Math.min(buyFactor, Math.floor(coins/eff));
  if(qty < 1 || coins < eff) return;

  // ‚îÄ‚îÄ Server-side economy validation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Ask the server to atomically deduct coins. Only apply local effects on success.
  const _res = await callEdgeFn('validate-action', {
    action: 'shop_buy', username: accountUsername, item, qty
  });
  if(!_res || !_res.success){
    if(_res && typeof _res.coins === 'number') coins = _res.coins; // re-sync if server has different value
    updateHUD(); refreshShopUI(); return;
  }
  coins = _res.coins; // use server-confirmed coin balance
  const confirmedQty = _res.qty || qty;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  for(let q=0; q<confirmedQty; q++){
    switch(item){
      case 'heal':
        myHp = Math.min(MAX_HP + maxHpBonus, myHp + 50);
        updateHUD();
        break;
      case 'ammo_rifle':   ammo.rifle  =MAX_AMMO.rifle;   updateAmmoHUD(); break;
      case 'ammo_shotgun': ammo.shotgun=MAX_AMMO.shotgun; updateAmmoHUD(); break;
      case 'ammo_laser':   ammo.laser  =MAX_AMMO.laser;   updateAmmoHUD(); break;
      case 'ammo_sniper':  ammo.sniper =MAX_AMMO.sniper;  updateAmmoHUD(); break;
      case 'grenades':
        addAmmo('grenade',3); addAmmo('c4',2);
        break;
      case 'mag_rifle':
        magLevel.rifle++;
        MAX_AMMO.rifle = BASE_AMMO.rifle + MAG_STEP.rifle * magLevel.rifle;
        ammo.rifle = Math.min(ammo.rifle, MAX_AMMO.rifle);
        updateAmmoHUD(); break;
      case 'mag_shotgun':
        magLevel.shotgun++;
        MAX_AMMO.shotgun = BASE_AMMO.shotgun + MAG_STEP.shotgun * magLevel.shotgun;
        ammo.shotgun = Math.min(ammo.shotgun, MAX_AMMO.shotgun);
        updateAmmoHUD(); break;
      case 'mag_laser':
        magLevel.laser++;
        MAX_AMMO.laser = BASE_AMMO.laser + MAG_STEP.laser * magLevel.laser;
        ammo.laser = Math.min(ammo.laser, MAX_AMMO.laser);
        updateAmmoHUD(); break;
      case 'mag_sniper':
        magLevel.sniper++;
        MAX_AMMO.sniper = BASE_AMMO.sniper + MAG_STEP.sniper * magLevel.sniper;
        ammo.sniper = Math.min(ammo.sniper, MAX_AMMO.sniper);
        updateAmmoHUD(); break;
      case 'mag_grenade':
        magLevel.grenade++;
        MAX_AMMO.grenade = BASE_AMMO.grenade + MAG_STEP.grenade * magLevel.grenade;
        ammo.grenade = Math.min(ammo.grenade, MAX_AMMO.grenade);
        updateAmmoHUD(); break;
      case 'mag_c4':
        magLevel.c4++;
        MAX_AMMO.c4 = BASE_AMMO.c4 + MAG_STEP.c4 * magLevel.c4;
        ammo.c4 = Math.min(ammo.c4, MAX_AMMO.c4);
        updateAmmoHUD(); break;
      case 'maxhp':
        maxHpBonus += 25;
        myHp = Math.min(MAX_HP + maxHpBonus, myHp + 25);
        updateHUD();
        break;
      case 'caliber':
        damageMultiplier = Math.round((damageMultiplier + 0.25) * 100) / 100;
        break;
      case 'fullkit':
        myHp = MAX_HP + maxHpBonus;
        Object.keys(ammo).forEach(k=>{ ammo[k]=MAX_AMMO[k]; });
        updateHUD(); updateAmmoHUD();
        break;
    }
  }
  updateHUD();
  refreshShopUI();
}


// ============================================================================
//  TACTICAL NUKE
// ============================================================================
function detonateNuke(){
  const df = document.getElementById('death-flash');
  // Instant white flash
  df.style.transition='none';
  df.style.background='rgba(255,255,255,1.0)';
  addChatMessage('','// ‚ò¢ '+myName+' DEPLOYED A TACTICAL NUKE ‚Äî ALL PLAYERS ELIMINATED ‚ò¢ //',false,true);
  showFloatPop('‚ò¢ NUKE LAUNCHED!','#ffffff');

  // Broadcast nuke event to ALL players in the room ‚Äî they all die regardless of ID
  if(gameChannel){
    gameChannel.send({type:'broadcast', event:'nuke', payload:{by: myName, id: playerId}});
  }

  setTimeout(()=>{
    // Kill all zombies
    zombies.slice().forEach(z=>{ hitZombie(z, 999999); });
    // Kill all remote players visible to us (belt + suspenders alongside broadcast)
    for(const id in remotePlayers){
      if(gameChannel) gameChannel.send({type:'broadcast', event:'hit', payload:{target:id, damage:99999, sender:playerId}});
    }
    // Massive explosion ring
    for(let i=0;i<16;i++){
      const angle=(i/16)*Math.PI*2;
      const r=6+Math.random()*40;
      spawnExplosion(new THREE.Vector3(
        camera.position.x+Math.cos(angle)*r, 0,
        camera.position.z+Math.sin(angle)*r
      ));
    }
    spawnExplosion(camera.position.clone());
  }, 350);

  // Fade flash to orange mushroom glow
  setTimeout(()=>{
    df.style.transition='background 3.0s ease-out';
    df.style.background='rgba(255,120,0,0)';
  }, 500);

  savePlayerState();
  refreshShopUI();
}

// ============================================================================
//  ORDNANCE ‚Äî EMP / MINI NUKE / CRUISE MISSILE
// ============================================================================
function detonateEMP(){
  const df=document.getElementById('death-flash');
  df.style.transition='none'; df.style.background='rgba(0,200,255,0.55)';
  setTimeout(()=>{ df.style.transition='background 1.5s ease-out'; df.style.background='rgba(0,200,255,0)'; },200);
  showFloatPop('‚ö° EMP BLAST!','#00cfff');
  addChatMessage('','// ‚ö° '+myName+' DEPLOYED AN EMP ‚Äî ALL ZOMBIES SLOWED //',false,true);
  // Slow all zombies for 5 seconds
  for(const z of zombies){ z._empSlowed=360; }
  // Broadcast EMP to remote players (screen flash + HUD flicker)
  _chanSend({type:'broadcast',event:'emp',payload:{by:myName,id:playerId}});
  savePlayerState(); refreshShopUI();
}

function detonateMiniNuke(){
  const df=document.getElementById('death-flash');
  df.style.transition='none'; df.style.background='rgba(255,180,0,0.85)';
  showFloatPop('üí• MINI NUKE!','#ffcc00');
  addChatMessage('','// üí• '+myName+' LAUNCHED A MINI NUKE ‚Äî LOCAL AREA DESTROYED //',false,true);
  // Broadcast for others' screens
  _chanSend({type:'broadcast',event:'mini_nuke',payload:{by:myName,id:playerId,x:camera.position.x,z:camera.position.z}});
  setTimeout(()=>{
    // Kill all zombies within 60m radius, reward coins/xp
    const MINI_R=60, MINI_RSQ=MINI_R*MINI_R;
    for(let i=zombies.length-1;i>=0;i--){
      if(camera.position.distanceToSquared(zombies[i].mesh.position)<MINI_RSQ) zombies[i].hp=0;
    }
    // Damage boss if in range
    if(activeBoss && camera.position.distanceToSquared(activeBoss.mesh.position)<MINI_RSQ*4){
      const dmg=Math.round(50000*damageMultiplier);
      activeBoss.hp=Math.max(0,activeBoss.hp-dmg);
      drawHPBar(activeBoss.hpSpr,activeBoss.hp,activeBoss.maxHp);
      showFloatPop('-'+dmg+' BOSS','#ff4444');
    }
    // Damage nearby remote players (not kill ‚Äî just heavy damage)
    for(const id in remotePlayers){
      const rp=remotePlayers[id];
      const dsq=camera.position.distanceToSquared(rp.mesh.position);
      if(dsq<MINI_RSQ){
        const falloff=1-Math.sqrt(dsq)/MINI_R;
        const dmg=Math.round(70*falloff);
        _chanSend({type:'broadcast',event:'hit',payload:{target:id,damage:dmg,sender:playerId}});
      }
    }
    // Big explosion ring
    for(let i=0;i<24;i++){
      const angle=(i/24)*Math.PI*2;
      const r=5+Math.random()*55;
      spawnExplosion(new THREE.Vector3(camera.position.x+Math.cos(angle)*r,0,camera.position.z+Math.sin(angle)*r));
    }
    spawnExplosion(camera.position.clone());
    df.style.transition='background 2.5s ease-out'; df.style.background='rgba(255,100,0,0)';
  },300);
  savePlayerState(); refreshShopUI();
}

function launchCruiseMissile(){
  // Find target: aim ray from camera straight forward, hit ground
  const dir=new THREE.Vector3(-Math.sin(yaw)*Math.cos(pitch),-Math.sin(pitch),-Math.cos(yaw)*Math.cos(pitch)).normalize();
  const MISS_R=18, MISS_RSQ=MISS_R*MISS_R;
  // Trace ray to ground (y=0)
  let tx=camera.position.x, tz=camera.position.z;
  if(Math.abs(dir.y) > 0.01){
    const t=-camera.position.y/dir.y;
    if(t>0 && t<400){ tx=camera.position.x+dir.x*t; tz=camera.position.z+dir.z*t; }
  } else {
    tx=camera.position.x+dir.x*120; tz=camera.position.z+dir.z*120;
  }
  addChatMessage('','// üöÄ '+myName+' LAUNCHED A CRUISE MISSILE ‚Äî INCOMING! //',false,true);
  showFloatPop('üöÄ MISSILE INCOMING!','#ff6600');
  _chanSend({type:'broadcast',event:'cruise_missile',payload:{by:myName,id:playerId,tx,tz}});

  // Animate missile falling from sky
  const missileGeo=new THREE.CylinderGeometry(0.15,0.15,2.0,8);
  const missileMat=new THREE.MeshLambertMaterial({color:0x888888});
  const missileMesh=new THREE.Mesh(missileGeo,missileMat);
  const noseMat=new THREE.MeshLambertMaterial({color:0xcc3300});
  const noseMesh=new THREE.Mesh(new THREE.ConeGeometry(0.15,0.5,8),noseMat);
  noseMesh.position.y=1.25; missileMesh.add(noseMesh);
  missileMesh.position.set(tx,80,tz); missileMesh.rotation.z=Math.PI; scene.add(missileMesh);

  let frame=0;
  const FRAMES=60;
  function missileTick(){
    frame++;
    missileMesh.position.y=80*(1-frame/FRAMES);
    if(frame>=FRAMES){
      scene.remove(missileMesh);
      // Detonate
      const impactPos=new THREE.Vector3(tx,0,tz);
      for(let i=0;i<20;i++){
        const a=(i/20)*Math.PI*2, r=Math.random()*MISS_R;
        spawnExplosion(new THREE.Vector3(tx+Math.cos(a)*r,0,tz+Math.sin(a)*r));
      }
      // Kill zombies in radius
      for(let i=zombies.length-1;i>=0;i--){
        if(impactPos.distanceToSquared(zombies[i].mesh.position)<MISS_RSQ) zombies[i].hp=0;
      }
      // Hurt boss
      if(activeBoss && impactPos.distanceToSquared(activeBoss.mesh.position)<MISS_RSQ*9){
        const dmg=Math.round(80000*damageMultiplier);
        activeBoss.hp=Math.max(0,activeBoss.hp-dmg);
        drawHPBar(activeBoss.hpSpr,activeBoss.hp,activeBoss.maxHp);
        showFloatPop('-'+dmg+' BOSS','#ff4444');
      }
      // Hurt remote players in range
      for(const id in remotePlayers){
        const rp=remotePlayers[id];
        const dsq=impactPos.distanceToSquared(rp.mesh.position);
        if(dsq<MISS_RSQ){
          const falloff=1-Math.sqrt(dsq)/MISS_R;
          _chanSend({type:'broadcast',event:'hit',payload:{target:id,damage:Math.round(90*falloff),sender:playerId}});
        }
      }
      // Hurt self if too close
      const selfDsq=impactPos.distanceToSquared(camera.position);
      if(selfDsq<MISS_RSQ){ takeDamage(Math.round(80*(1-Math.sqrt(selfDsq)/MISS_R))); }
      // Screen shake
      const df2=document.getElementById('death-flash');
      df2.style.transition='none'; df2.style.background='rgba(255,120,0,0.4)';
      setTimeout(()=>{ df2.style.transition='background 1.0s ease-out'; df2.style.background='rgba(255,120,0,0)'; },100);
      return;
    }
    requestAnimationFrame(missileTick);
  }
  requestAnimationFrame(missileTick);
  savePlayerState(); refreshShopUI();
}

async function exitGame(){
  const btn = document.getElementById('exit-btn');
  if(btn){ btn.textContent='// SAVING...'; btn.disabled=true; }
  await savePlayerState();
  // Give the DB call a moment to complete then reload
  setTimeout(()=>{ location.reload(); }, 600);
}
// ============================================================================
//  HIT MARKER
// ============================================================================
let hmTimer=0;
function showHitMarker(){
  _hudHm.style.transition='none'; _hudHm.style.opacity='1'; hmTimer=14;
}

// ============================================================================
//  JUMP & MOVEMENT
// ============================================================================
// Admin fly ‚Äî double-tap space to toggle
let _flyMode = false;
let _lastSpaceTime = 0;
function tryJump(){
  if(dead) return;
  const now = performance.now();
  if(isAdmin && now - _lastSpaceTime < 300){
    // Double-tap ‚Äî toggle fly mode
    _flyMode = !_flyMode;
    velY = 0;
    addChatMessage('','// [ADMIN] FLY MODE: '+(_flyMode?'ON':'OFF')+' //',false,true);
  } else if(onGround){
    velY = (HC.hacks.superJump.on ? JUMP_FORCE * 1.4 : JUMP_FORCE) * HC._hplJumpMult;
    onGround = false;
  }
  _lastSpaceTime = now;
}

// Pre-allocated vectors ‚Äî reused every frame to avoid GC churn
const _fwd = new THREE.Vector3();
const _rgt = new THREE.Vector3();
const _np  = new THREE.Vector3();
const _tx  = new THREE.Vector3();
const _tz  = new THREE.Vector3();


// Returns the effective camera-Y floor the player should land on at pos.
// Slope zones take ABSOLUTE priority ‚Äî if inside a stair zone AND at that
// stair's vertical range, return immediately and skip floor platform checks.
// This is what makes going DOWN stairs work: floor platforms from the floor
// you just came from would otherwise override the slope via Math.max.
function getFloorY(pos){
  for(const s of slopeZones){
    if(pos.x>s.x1 && pos.x<s.x2 && pos.z>s.zExit && pos.z<s.zEntry){
      // Compute the slope floor at this Z position
      const t = (s.zEntry - pos.z) / (s.zEntry - s.zExit);
      const camY = s.yBot + t*(s.yTop - s.yBot) + GROUND_Y;
      // Only activate for THIS stair flight: player must be within ¬±(FLOOR_H) of it
      if(pos.y >= s.yBot + GROUND_Y - 0.6 && pos.y <= s.yTop + GROUND_Y + 0.6){
        return Math.max(GROUND_Y, camY);  // slope wins outright ‚Äî no platform check
      }
    }
  }

  // No active slope ‚Äî check flat floor platforms
  let landY = GROUND_Y;
  for(const fp of floorPlatforms){
    if(pos.x>fp.x1 && pos.x<fp.x2 && pos.z>fp.z1 && pos.z<fp.z2){
      const camY = fp.y + GROUND_Y;
      if(pos.y >= camY - 0.25 && camY > landY) landY = camY;
    }
  }
  return landY;
}

function updateMovement(){
  if(dead||chatOpen||paused||inCar) return;

  // Escape hatch: push player out of solid geometry
  if(checkCollision(camera.position)){
    let freed=false;
    for(let dist=0.15; dist<=3.0 && !freed; dist+=0.15){
      for(let a=0; a<16 && !freed; a++){
        const angle=a*(Math.PI/8);
        const tp=camera.position.clone();
        tp.x+=Math.cos(angle)*dist; tp.z+=Math.sin(angle)*dist;
        if(!checkCollision(tp)){ camera.position.x=tp.x; camera.position.z=tp.z; freed=true; }
      }
    }
    return;
  }

  const sprinting = keys['ControlLeft'] || keys['ControlRight'];
  const _rbMult = (typeof redBullActive!=='undefined' && redBullActive) ? RED_BULL_SPEED_MULT : 1;
  const spd = (scoped ? 0.04 : (sprinting ? 0.26 : 0.15) * getSpeedMult()) * _rbMult;
  const sy = Math.sin(yaw), cy = Math.cos(yaw);
  _fwd.set(-sy, 0, -cy);
  _rgt.set( cy, 0, -sy);
  _np.copy(camera.position);
  if(keys['KeyW']||keys['ArrowUp'])    _np.addScaledVector(_fwd, spd);
  if(keys['KeyS']||keys['ArrowDown'])  _np.addScaledVector(_fwd,-spd);
  if(keys['KeyA']||keys['ArrowLeft'])  _np.addScaledVector(_rgt,-spd);
  if(keys['KeyD']||keys['ArrowRight']) _np.addScaledVector(_rgt, spd);
  _np.x=Math.max(-250,Math.min(250,_np.x));
  _np.z=Math.max(-320,Math.min(380,_np.z));

  _tx.copy(camera.position); _tx.x=_np.x;
  if(!checkCollision(_tx)) camera.position.x=_np.x;
  _tz.copy(camera.position); _tz.z=_np.z;
  if(!checkCollision(_tz)) camera.position.z=_np.z;

  // Gravity with multi-floor landing (skipped in fly mode or red bull)
  const _isFlying = _flyMode || (typeof redBullActive!=='undefined' && redBullActive);
  if(_isFlying){
    // tickRedBull handles Space/Shift for red bull, HC fly mode handles its own
    if(_flyMode){
      if(keys['Space'])     camera.position.y += 0.18;
      if(keys['ShiftLeft']||keys['ShiftRight']) camera.position.y -= 0.18;
    }
    onGround = false;
  } else {
    velY += (HC.hacks.superJump.on ? GRAVITY * 0.75 : GRAVITY) * HC._hplGravMult;
    camera.position.y += velY;
    const floorY = getFloorY(camera.position);
    if(camera.position.y <= floorY){
      camera.position.y = floorY;
      velY = 0;
      onGround = true;
    }
  }
}

// ============================================================================
//  GRENADE SYSTEM
// ============================================================================
const grenades = [];
const GREN_GRAVITY  = -0.013;
const GREN_FUSE     = 150;   // frames until explosion (~2.5s at 60fps)
const GREN_RADIUS   = 7.0;   // explosion radius (units)
const GREN_RADIUS_SQ= GREN_RADIUS * GREN_RADIUS;

// Explosion flash pool ‚Äî reused expanding spheres
const _expGeo = new THREE.SphereGeometry(1, 10, 8);
const _expMat = new THREE.MeshBasicMaterial({color:0xff6600, transparent:true, opacity:0.85, depthWrite:false});
const _expFlashes = []; // { mesh, t } active flashes

function spawnExplosion(pos){
  const m = new THREE.Mesh(_expGeo, _expMat.clone());
  m.position.copy(pos);
  scene.add(m);
  _expFlashes.push({mesh:m, t:0});
  // Screen flash for local player if nearby
  const dx=camera.position.x-pos.x, dy=camera.position.y-pos.y, dz=camera.position.z-pos.z;
  if(dx*dx+dy*dy+dz*dz < 100){
    _domDf.style.background='rgba(255,140,0,0.55)';
    setTimeout(()=>_domDf.style.background='rgba(255,0,0,0)', 220);
  }
}

function updateExplosions(){
  for(let i=_expFlashes.length-1;i>=0;i--){
    const e=_expFlashes[i];
    e.t++;
    const scale = 0.3 + e.t * 0.45;
    e.mesh.scale.setScalar(scale);
    e.mesh.material.opacity = Math.max(0, 0.85 - e.t * 0.075);
    if(e.mesh.material.opacity <= 0){
      scene.remove(e.mesh);
      e.mesh.material.dispose();
      _expFlashes.splice(i,1);
    }
  }
}

function explodeGrenade(g){
  spawnExplosion(g.mesh.position);
  if(!g.isRemote){
    // AOE damage to remote players
    for(const id in remotePlayers){
      const rp = remotePlayers[id];
      const dsq = g.mesh.position.distanceToSquared(rp.mesh.position);
      if(dsq < GREN_RADIUS_SQ){
        const falloff = 1 - Math.sqrt(dsq) / GREN_RADIUS;
        const dmg = Math.round(WEAPONS.grenade.damage * falloff);
        if(dmg <= 0) continue;
        const nhp = Math.max(0,(rp.hp??MAX_HP)-dmg);
        rp.hp = nhp;
        drawHPBar(rp.hpSprite, nhp, MAX_HP);
        _chanSend({type:'broadcast', event:'hit', payload:{target:id, damage:dmg, sender:playerId}});
        if(nhp===0){
          kills++;
          claimBounty(rp.bounty || 5, rp.name || 'UNKNOWN');
          _chanSend({type:'broadcast', event:'kill_feed', payload:{killer:myName, victim:rp.name||'UNKNOWN', bounty: rp.bounty||5, sender:playerId}});
        }
        showHitMarker(); updateHUD();
      }
    }
    // AOE damage to self if close enough
    const selfDsq = g.mesh.position.distanceToSquared(camera.position);
    if(selfDsq < GREN_RADIUS_SQ){
      const falloff = 1 - Math.sqrt(selfDsq) / GREN_RADIUS;
      takeDamage(Math.round(WEAPONS.grenade.damage * falloff));
    }
    // Broadcast explosion position to other clients
    explosionDamageZombies(g.mesh.position, GREN_RADIUS, WEAPONS.grenade.damage);
    _chanSend({type:'broadcast', event:'explode',
               payload:{x:g.mesh.position.x, y:g.mesh.position.y, z:g.mesh.position.z}});
  }
  scene.remove(g.mesh);
}

function throwGrenade(isRemote, px, py, pz, vx, vy, vz){
  const mesh = new THREE.Mesh(_wBullet.grenade.geo, _wBullet.grenade.mat);
  mesh.position.set(px, py, pz);
  scene.add(mesh);
  grenades.push({
    mesh, isRemote,
    vel: new THREE.Vector3(vx, vy, vz),
    fuse: GREN_FUSE,       // counts down only after landing
    fuseActive: false,     // starts false ‚Äî activates on first floor contact
    rotAxis: new THREE.Vector3(Math.random(),Math.random(),Math.random()).normalize(),
  });
}

function updateGrenades(){
  for(let i=grenades.length-1;i>=0;i--){
    const g=grenades[i];
    // Gravity
    g.vel.y += GREN_GRAVITY;
    // Move
    const np = g.mesh.position.clone().add(g.vel);
    // Floor bounce ‚Äî getFloorY expects camera-space Y, so add GROUND_Y to get right scale
    const _gFloorCam = getFloorY({x:np.x, y:np.y + GROUND_Y, z:np.z});
    const _gFloor = _gFloorCam - GROUND_Y + 0.10; // +0.10 = grenade radius so it rests on surface
    if(np.y < _gFloor){
      np.y = _gFloor;
      g.vel.y *= -0.38; // bounce dampen
      g.vel.x *= 0.72;
      g.vel.z *= 0.72;
      g.fuseActive = true; // fuse starts on first ground contact
    }
    // Wall bounce
    if(checkEnvCol(np)){
      g.vel.x *= -0.5; g.vel.z *= -0.5;
      np.copy(g.mesh.position);
    }
    g.mesh.position.copy(np);
    // Spin while airborne, slow when landed
    g.mesh.rotateOnAxis(g.rotAxis, g.fuseActive ? 0.01 : 0.08);
    // Fuse only ticks after landing
    if(g.fuseActive){
      g.fuse--;
      if(g.fuse <= 0){
        explodeGrenade(g);
        grenades.splice(i,1);
      }
    }
  }
  updateExplosions();
}

// ============================================================================
//  C4 SYSTEM
// ============================================================================
const c4Charges = []; // { mesh, pos, placerId, isRemote }
const C4_RADIUS    = 10.0;
const C4_RADIUS_SQ = C4_RADIUS * C4_RADIUS;

// LED blink state
let _c4BlinkT = 0;

function placeC4(){
  // Drop C4 at player feet, flush on the floor
  const floorY = getFloorY(camera.position) - GROUND_Y; // convert camera-Y to world-Y
  const pos = new THREE.Vector3(camera.position.x, floorY + 0.04, camera.position.z);
  const mesh = new THREE.Mesh(_wBullet.c4.geo, _wBullet.c4.mat.clone());
  mesh.position.copy(pos);
  // Align to player facing direction
  mesh.rotation.y = yaw;
  scene.add(mesh);
  // Blinking red LED sphere child
  const led = new THREE.Mesh(new THREE.SphereGeometry(0.018,6,6),
    new THREE.MeshBasicMaterial({color:0xff0000}));
  led.position.set(0, 0.055, 0);
  mesh.add(led);
  const placedZone = camera.position.z > 2 ? 'danger' : 'safe';
  c4Charges.push({ mesh, pos: pos.clone(), placerId: playerId, isRemote: false, zone: placedZone });
  _chanSend({type:'broadcast', event:'c4place',
             payload:{x:pos.x, y:pos.y, z:pos.z, ry:yaw, pid:playerId, zone:placedZone}});
}

function detonateC4(){
  const playerZone = camera.position.z > 2 ? 'danger' : 'safe';
  // Only detonate our charges that are in the same zone as the player
  const mine = c4Charges.filter(c=>!c.isRemote && c.zone===playerZone);
  if(!mine.length) return;
  mine.forEach(c=>{
    spawnExplosion(c.pos);
    // AOE damage ‚Äî larger than grenade
    for(const id in remotePlayers){
      const rp=remotePlayers[id];
      const dsq=c.pos.distanceToSquared(rp.mesh.position);
      if(dsq<C4_RADIUS_SQ){
        const falloff=1-Math.sqrt(dsq)/C4_RADIUS;
        const dmg=Math.round(WEAPONS.c4.damage*falloff);
        if(dmg<=0) return;
        const nhp=Math.max(0,(rp.hp??MAX_HP)-dmg);
        rp.hp=nhp; drawHPBar(rp.hpSprite,nhp,MAX_HP);
        _chanSend({type:'broadcast',event:'hit',payload:{target:id,damage:dmg,sender:playerId}});
        if(nhp===0){
          kills++;
          claimBounty(rp.bounty || 5, rp.name || 'UNKNOWN');
          _chanSend({type:'broadcast', event:'kill_feed', payload:{killer:myName, victim:rp.name||'UNKNOWN', bounty: rp.bounty||5, sender:playerId}});
        }
        showHitMarker(); updateHUD();
      }
    }
    // Self damage
    const selfDsq=c.pos.distanceToSquared(camera.position);
    if(selfDsq<C4_RADIUS_SQ){
      const falloff=1-Math.sqrt(selfDsq)/C4_RADIUS;
      takeDamage(Math.round(WEAPONS.c4.damage*falloff));
    }
    explosionDamageZombies(c.pos, C4_RADIUS, WEAPONS.c4.damage);
    scene.remove(c.mesh);
  });
  // Tell other clients to show explosions + remove their visual copies
  _chanSend({type:'broadcast',event:'c4det',payload:{pid:playerId, zone:playerZone}});
  // Remove only the detonated (same-zone) charges from local array
  for(let i=c4Charges.length-1;i>=0;i--){
    if(!c4Charges[i].isRemote && c4Charges[i].zone===playerZone) c4Charges.splice(i,1);
  }
}

function updateC4Blink(){
  _c4BlinkT++;
  const on = (_c4BlinkT % 60) < 30;
  for(const c of c4Charges){
    // LED is first child of the mesh
    if(c.mesh.children[0]) c.mesh.children[0].visible = on;
  }
}

// ============================================================================
//  BULLET UPDATE & DAMAGE
// ============================================================================
function updateBullets(){
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.position.add(b.userData.vel);
    b.userData.life--;
    if(b.userData.life<=0||checkBulletCol(b.position)){
      scene.remove(b); bullets.splice(i,1); continue;
    }
    if(!b.userData.isRemote){
      let hit=false;
      for(const id in remotePlayers){
        const rp=remotePlayers[id];
        if(b.position.distanceToSquared(rp.mesh.position)<2.25){  // 1.5¬≤ ‚Äî larger for humanoid
          const dmg = Math.round((typeof b.userData.damage === 'number' ? b.userData.damage : 25) * damageMultiplier);
          const nhp=Math.max(0,(rp.hp??MAX_HP)-dmg);
          rp.hp=nhp;
          drawHPBar(rp.hpSprite,nhp,MAX_HP);
          if(gameChannel) _chanSend({
            type:'broadcast', event:'hit',
            payload:{ target:id, damage:dmg }
          });
          if(nhp===0){
            kills++;
            if(_inArena(camera.position.x,camera.position.z)) pvpKills++;
            // Claim victim's bounty
            claimBounty(rp.bounty || 5, rp.name || 'UNKNOWN');
            // Broadcast kill-feed to other clients
            _chanSend({type:'broadcast', event:'kill_feed', payload:{killer:myName, victim:rp.name||'UNKNOWN', bounty: rp.bounty||5, sender:playerId}});
          }
          showFloatPop('-'+dmg,'#ff4444');
          showHitMarker(); updateHUD();
          scene.remove(b); bullets.splice(i,1); hit=true; break;
        }
      }
      if(hit) continue;
    }
  }
}

// ============================================================================
//  HUD UPDATE
// ============================================================================
// Cached HUD refs ‚Äî never query DOM every frame
const _hudHval   = document.getElementById('hval');
const _hudHbar   = document.getElementById('hbar');
const _hudKval   = document.getElementById('kval');
const _hudPcount = document.getElementById('pcount');
const _hudHm     = document.getElementById('hit-marker');
const _domDf     = document.getElementById('death-flash');
const _domDmsg   = document.getElementById('death-msg');

function updateHUD(){
  const _maxHp=MAX_HP+maxHpBonus;
  const pct=Math.max(0,myHp/_maxHp*100);
  _hudHval.textContent=myHp+'/'+_maxHp;
  _hudHval.className='val'+(pct<=25?' danger':'');
  _hudHbar.style.width=pct+'%';
  _hudHbar.style.background=pct>50?'#0f0':pct>25?'#fa0':'#f44';
  _hudKval.textContent=kills;
  _hudPcount.textContent=Object.keys(remotePlayers).length+1;
  const _cv=document.getElementById('coins-val'); if(_cv) _cv.textContent=coins;
  updateXPHUD();
  updateBountyHUD();
}

// ============================================================================
//  DAMAGE / DEATH / RESPAWN
// ============================================================================
function takeDamage(amt){
  if(dead) return;
  if(_inShopBuilding() || shopOpen) return; // god-mode inside shop or while shop UI is open
  // Military vehicle armor reduction
  if(inCar && activeCar && activeCar.def.damageReduction) amt = Math.round(amt * (1 - activeCar.def.damageReduction));
  if(amt <= 0) return;
  myHp=Math.max(0,myHp-amt);
  updateHUD();
  _domDf.style.background='rgba(255,0,0,0.4)';
  setTimeout(()=>_domDf.style.background='rgba(255,0,0,0)',180);
  if(myHp<=0) die();
}
function die(){
  dead=true; myHp=0; deaths++;
  _domDmsg.style.display='block';
  _domDf.style.background='rgba(255,0,0,0.5)';
  if(db) db.from('players').update({hp:0}).eq('id',playerId);
  addChatMessage('', '// YOU WERE ELIMINATED //', false, true);
  setTimeout(respawn,3000);
}
function safeSpawnPos(){
  // Always spawn in safe zone (Z < -5)
  for(let attempt=0; attempt<60; attempt++){
    const x=(Math.random()-.5)*80, z=-10-(Math.random()*70);
    const test={x, y:GROUND_Y, z};
    if(!checkCollision(test)) return {x,z};
  }
  return {x:0, z:-20};
}
function respawn(){
  myHp=MAX_HP+maxHpBonus; dead=false; velY=0; onGround=true; _flyMode=false;
  const sp=safeSpawnPos();
  camera.position.set(sp.x, GROUND_Y, sp.z);
  _domDmsg.style.display='none';
  _domDf.style.background='rgba(255,0,0,0)';
  updateHUD();
  if(db) db.from('players').update({hp:MAX_HP}).eq('id',playerId);
  // Reset speed checker so the respawn teleport doesn't count as a violation
  if(typeof _resetSpeedChecker === 'function') _resetSpeedChecker();
}

// ============================================================================
//  MULTIPLAYER (SUPABASE)
// ============================================================================
// playerId is stable per account ‚Äî set in authDeploy; fallback for non-authed
let playerId = crypto.randomUUID(); // overwritten on login
const remotePlayers={};
let playerCount=0;

let gameChannel=null;

// ‚îÄ‚îÄ Broadcast security state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const _HIT_MAX_DMG    = 500;     // max damage accepted per hit event
const _HIT_RATE_MAX   = 20;      // hits from one sender per second before drop
const _HIT_RATE_MS    = 1000;
const _hitRateMap     = {};      // senderId ‚Üí {count, resetAt}
const _nukeReceivedAt = {};      // senderId ‚Üí timestamp  (30s nuke cooldown)
const _NUKE_COOLDOWN  = 30_000;

function _checkHitAllowed(senderId, damage){
  if(senderId !== '__admin__' && !remotePlayers[senderId]) return false;
  const safe = Math.min(Math.max(0, Number(damage)||0), _HIT_MAX_DMG);
  const now = Date.now();
  if(!_hitRateMap[senderId] || now - _hitRateMap[senderId].resetAt > _HIT_RATE_MS)
    _hitRateMap[senderId] = { count:0, resetAt:now };
  _hitRateMap[senderId].count++;
  if(_hitRateMap[senderId].count > _HIT_RATE_MAX) return false;
  return safe;
}

if(db){
  gameChannel=db.channel('fps-game-room');
  gameChannel
    .on('broadcast',{event:'hit'},({payload})=>{
      if(payload.target!==playerId) return;
      const _safe = _checkHitAllowed(payload.sender||'unknown', payload.damage);
      if(_safe === false) return;
      takeDamage(_safe);
    })
    .on('broadcast',{event:'admin_tp'},({payload})=>{
      if(payload.target === playerId){
        // Security: sender must be a currently-connected player AND verified admin server-side.
        // Without this check any player could broadcast admin_tp and teleport others anywhere.
        const senderUsername = payload.senderUsername || null;
        if(!senderUsername) return; // no claimed username ‚Äî drop
        if(!remotePlayers[payload.sender]) return; // sender not in our player list ‚Äî drop spoofed events
        // Async server verify before moving camera ‚Äî prevents console-injected teleports
        callEdgeFn('admin-action', { action:'verify', username: senderUsername })
          .then(r => {
            if(!r || !r.isAdmin) return; // sender is not actually an admin ‚Äî silently drop
            camera.position.set(payload.x + (Math.random()-0.5)*2, payload.y, payload.z + (Math.random()-0.5)*2);
            velY = 0;
            addChatMessage('','// [ADMIN] YOU HAVE BEEN TELEPORTED //',false,true);
          }).catch(()=>{}); // network error ‚Üí silently drop, never apply
      }
    })
    .on('broadcast',{event:'nuke'},({payload})=>{
      if(payload.id === playerId) return;
      if(!remotePlayers[payload.id]) return; // unknown sender ‚Äî drop
      const _now = Date.now();
      if(_nukeReceivedAt[payload.id] && _now - _nukeReceivedAt[payload.id] < _NUKE_COOLDOWN) return;
      _nukeReceivedAt[payload.id] = _now;
      addChatMessage('','// ‚ò¢ NUKE BY '+payload.by+' ‚Äî YOU WERE INCINERATED //',false,true);
      const df=document.getElementById('death-flash');
      df.style.transition='none'; df.style.background='rgba(255,255,255,1.0)';
      setTimeout(()=>{ df.style.transition='background 3s ease-out'; df.style.background='rgba(255,120,0,0)'; },500);
      takeDamage(99999);
    })
    .on('broadcast',{event:'bullet'},({payload})=>{
      const _rwb = _wBullet[payload.weapon] || _wBullet.rifle;
      const b = new THREE.Mesh(_rwb.geo, _rwb.mat);
      b.position.set(payload.x, payload.y, payload.z);
      if(payload.weapon==='laser'){
        const _rv=new THREE.Vector3(payload.vx,payload.vy,payload.vz).normalize();
        b.quaternion.setFromUnitVectors(_LASER_UP, _rv);
      }
      b.userData = { vel: new THREE.Vector3(payload.vx, payload.vy, payload.vz), life: 90, damage: 0, isRemote: true };
      scene.add(b); bullets.push(b);
    })
    .on('broadcast',{event:'grenade'},({payload})=>{
      throwGrenade(true, payload.x, payload.y, payload.z, payload.vx, payload.vy, payload.vz);
    })
    .on('broadcast',{event:'c4place'},({payload})=>{
      // Show remote player's C4 charge
      const mesh=new THREE.Mesh(_wBullet.c4.geo, _wBullet.c4.mat.clone());
      mesh.position.set(payload.x, payload.y, payload.z);
      mesh.rotation.y=payload.ry;
      scene.add(mesh);
      const led=new THREE.Mesh(new THREE.SphereGeometry(0.018,6,6),
        new THREE.MeshBasicMaterial({color:0xff0000}));
      led.position.set(0,0.055,0); mesh.add(led);
      c4Charges.push({mesh, pos:new THREE.Vector3(payload.x,payload.y,payload.z), placerId:payload.pid, isRemote:true, zone:payload.zone||'danger'});
    })
    .on('broadcast',{event:'c4det'},({payload})=>{
      // Remote detonation ‚Äî only remove charges from the detonated zone
      const detZone=payload.zone||'danger';
      for(let i=c4Charges.length-1;i>=0;i--){
        const c=c4Charges[i];
        if(c.placerId===payload.pid && c.zone===detZone){
          spawnExplosion(c.pos); scene.remove(c.mesh); c4Charges.splice(i,1);
        }
      }
    })
    .on('broadcast',{event:'explode'},({payload})=>{
      // Remote explosion visual only
      spawnExplosion(new THREE.Vector3(payload.x, payload.y, payload.z));
    })
    .on('broadcast',{event:'kill_feed'},({payload})=>{
      // Only show kill feeds from known connected players ‚Äî cosmetic only, no coins awarded here
      if(payload.sender && !remotePlayers[payload.sender]) return;
      const killer = payload.killer || 'UNKNOWN';
      const victim = payload.victim || 'UNKNOWN';
      const bountyDisplay = Math.min(Math.max(0, Number(payload.bounty)||5), 999999);
      addChatMessage('', '// ‚ò† '+killer+' ELIMINATED '+victim+' ‚Äî ‚¨°'+bountyDisplay+' BOUNTY //', false, true);
    })
    .on('broadcast',{event:'emp'},({payload})=>{
      if(payload.id===playerId) return;
      if(!remotePlayers[payload.id]) return; // unknown sender ‚Äî drop
      const df=document.getElementById('death-flash');
      df.style.transition='none'; df.style.background='rgba(0,200,255,0.3)';
      setTimeout(()=>{ df.style.transition='background 1.2s ease-out'; df.style.background='rgba(0,200,255,0)'; },150);
      addChatMessage('','// ‚ö° '+payload.by+' DEPLOYED AN EMP //',false,true);
    })
    .on('broadcast',{event:'mini_nuke'},({payload})=>{
      if(payload.id===playerId) return;
      if(!remotePlayers[payload.id]) return; // unknown sender ‚Äî drop
      const df=document.getElementById('death-flash');
      df.style.transition='none'; df.style.background='rgba(255,180,0,0.5)';
      setTimeout(()=>{ df.style.transition='background 2s ease-out'; df.style.background='rgba(255,100,0,0)'; },400);
      addChatMessage('','// üí• '+payload.by+' LAUNCHED A MINI NUKE //',false,true);
    })
    .on('broadcast',{event:'cruise_missile'},({payload})=>{
      if(payload.id===playerId) return;
      if(!remotePlayers[payload.id]) return; // unknown sender ‚Äî drop
      addChatMessage('','// üöÄ '+payload.by+' LAUNCHED A CRUISE MISSILE //',false,true);
      // Show incoming missile visually for other clients
      const missileGeo=new THREE.CylinderGeometry(0.15,0.15,2.0,8);
      const missileMat=new THREE.MeshLambertMaterial({color:0x888888});
      const missileMesh=new THREE.Mesh(missileGeo,missileMat);
      const noseMesh=new THREE.Mesh(new THREE.ConeGeometry(0.15,0.5,8),new THREE.MeshLambertMaterial({color:0xcc3300}));
      noseMesh.position.y=1.25; missileMesh.add(noseMesh);
      missileMesh.position.set(payload.tx,80,payload.tz); missileMesh.rotation.z=Math.PI; scene.add(missileMesh);
      let mf=0;
      function mt(){ mf++; missileMesh.position.y=80*(1-mf/60); if(mf>=60){ scene.remove(missileMesh); return; } requestAnimationFrame(mt); }
      requestAnimationFrame(mt);
    })
    .on('broadcast',{event:'chat'},({payload})=>{
      // Validate sender is a known connected player ‚Äî prevents name spoofing from external scripts
      if(payload.sender && !remotePlayers[payload.sender]) return;
      const name = payload.name || 'UNKNOWN';
      addChatMessage(name, censorText(payload.text||""), false);
    })
    .on('broadcast',{event:'pos'},({payload})=>{
      // Real-time position update from another player
      const rp = remotePlayers[payload.id];
      if(!rp) return; // not yet loaded from DB ‚Äî will appear on next loadPlayers poll
      // Set lerp targets instead of snapping
      rp.targetX = payload.x;
      rp.targetY = payload.y - 0.65;
      rp.targetZ = payload.z;
      rp.targetRy = payload.ry;
      if(typeof payload.hp === 'number' && payload.hp !== rp.hp){
        rp.hp = payload.hp;
        drawHPBar(rp.hpSprite, payload.hp, MAX_HP);
      }
    })
    .on('broadcast',{event:'join'},({payload})=>{
      addChatMessage('', '// ' + (payload.name||'UNKNOWN') + ' JOINED THE FIELD //', false, true);
      setTimeout(refreshBountyLeaderboard, 1500);
    })
    .on('broadcast',{event:'leave'},({payload})=>{
      addChatMessage('', '// ' + (payload.name||'UNKNOWN') + ' LEFT THE FIELD //', false, true);
      setTimeout(refreshBountyLeaderboard, 1500);
    })
    .on('broadcast',{event:'correction'},({payload})=>{
      // ‚îÄ‚îÄ Server anti-cheat correction ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Only act if the correction targets THIS client's playerId.
      // Legit players never receive this event (server only sends it when
      // a speed violation is detected), so there is zero latency impact
      // for normal play.
      if(payload.target !== playerId) return;
      if(typeof payload.x !== 'number' || typeof payload.z !== 'number') return;
      // Snap position back to last valid server-known location
      camera.position.x = payload.x;
      camera.position.z = payload.z;
      velY = 0;
      addChatMessage('','// [SERVER] INVALID MOVEMENT CORRECTED //',false,true);
      showFloatPop('‚ö† POSITION CORRECTED','#ff4444');
    })
    .subscribe(status => {
      if(status === 'SUBSCRIBED') _chanReady = true;
    });
}

// Only send once the WebSocket is confirmed open ‚Äî prevents REST fallback
let _chanReady = false;
function _chanSend(msg){
  if(!gameChannel || !_chanReady) return;
  gameChannel.send(msg);
}

window.addEventListener('beforeunload',()=>{
  if(gameChannel && myName) gameChannel.send({
    type:'broadcast', event:'leave', payload:{name:myName}
  });
  if(db) db.from('players').delete().eq('id',playerId);
  // Best-effort sync save on tab close (may not complete)
  savePlayerState();
});

function announceJoin(){
  if(gameChannel && myName && _chanReady) gameChannel.send({
    type:'broadcast', event:'join', payload:{name:myName}
  });
}

async function syncPlayer(){
  if(!db||!myName) return;
  await db.from('players').upsert({
    id:playerId,
    x:camera.position.x, y:camera.position.y, z:camera.position.z,
    ry:yaw, hp:myHp, name:myName, level:playerLevel,
    bounty: calcBounty(),
    updated_at:new Date().toISOString()
  });
}
// syncPlayer now called from merged ticker

// ‚îÄ‚îÄ HUMANOID PLAYER MODEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Shared geometries + materials (allocated once, reused for every remote player)
const _pmG = {
  head:    new THREE.BoxGeometry(0.40, 0.36, 0.40),
  hTop:    new THREE.BoxGeometry(0.44, 0.20, 0.44),
  hBrim:   new THREE.BoxGeometry(0.48, 0.07, 0.48),
  torso:   new THREE.BoxGeometry(0.55, 0.60, 0.28),
  hips:    new THREE.BoxGeometry(0.48, 0.26, 0.26),
  uArm:    new THREE.BoxGeometry(0.20, 0.46, 0.20),
  lArm:    new THREE.BoxGeometry(0.17, 0.40, 0.17),
  uLeg:    new THREE.BoxGeometry(0.22, 0.50, 0.22),
  lLeg:    new THREE.BoxGeometry(0.20, 0.44, 0.20),
  foot:    new THREE.BoxGeometry(0.23, 0.10, 0.36),
};
const _pmM = {
  skin:  new THREE.MeshLambertMaterial({color:0xc8956c}),
  helm:  new THREE.MeshLambertMaterial({color:0x3a4225}),
  torso: new THREE.MeshLambertMaterial({color:0x4a5530}),
  leg:   new THREE.MeshLambertMaterial({color:0x363d1e}),
  boot:  new THREE.MeshLambertMaterial({color:0x1a1208}),
};
// Shared gun geometry for the player model (small blocky weapon)
const _pmGunG = {
  body:   new THREE.BoxGeometry(0.07, 0.07, 0.30),
  barrel: new THREE.BoxGeometry(0.03, 0.03, 0.18),
  grip:   new THREE.BoxGeometry(0.05, 0.09, 0.05),
};
const _pmGunM = new THREE.MeshLambertMaterial({color:0x222222});

function makePlayerModel(){
  const g = new THREE.Group();
  const add = (geo, mat, x, y, z, rx=0,ry=0,rz=0) => {
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x,y,z);
    m.rotation.set(rx,ry,rz);
    g.add(m);
  };
  // Head & helmet
  add(_pmG.head,  _pmM.skin,  0,      0.80, 0);
  add(_pmG.hTop,  _pmM.helm,  0,      0.96, 0);
  add(_pmG.hBrim, _pmM.helm,  0,      0.75, 0);
  // Torso & hips
  add(_pmG.torso, _pmM.torso, 0,      0.41, 0);
  add(_pmG.hips,  _pmM.torso, 0,      0.04, 0);
  // Left arm
  add(_pmG.uArm, _pmM.torso, -0.40,  0.37, 0);
  add(_pmG.lArm, _pmM.skin,  -0.40, -0.02, 0);
  // Right arm ‚Äî angled forward slightly to hold gun
  add(_pmG.uArm, _pmM.torso,  0.40,  0.35, 0, -0.35,0,0);
  add(_pmG.lArm, _pmM.skin,   0.40,  0.02,-0.12, -0.5,0,0);
  // Gun body held in right hand ‚Äî offset forward and slightly right
  add(_pmGunG.body,   _pmGunM,  0.40,  0.04, -0.22);
  add(_pmGunG.barrel, _pmGunM,  0.40,  0.05, -0.43);
  add(_pmGunG.grip,   _pmGunM,  0.40, -0.04, -0.16);
  // Legs (mirrored)
  for(const sx of [-1,1]){
    add(_pmG.uLeg, _pmM.leg,   sx*0.13, -0.36, 0);
    add(_pmG.lLeg, _pmM.leg,   sx*0.13, -0.76, 0);
    add(_pmG.foot, _pmM.boot,  sx*0.13, -1.01, 0.06);
  }
  return g;
}

const active = new Set(); // reused every loadPlayers call ‚Äî no GC
async function loadPlayers(){
  if(!db) return;
  const cutoff=new Date(Date.now()-5000).toISOString();
  const {data}=await db.from('players').select('*').gte('updated_at',cutoff);
  if(!data) return;
  active.clear();

  data.forEach(p=>{
    if(p.id===playerId){ return; }
    active.add(p.id);

    if(!remotePlayers[p.id]){
      playerCount++;
      const mesh=makePlayerModel();
      const hpSprite=makeHPSprite();
      const nameLabel = (p.level!=null?'LVL'+p.level+' ':'')+(p.name||('P'+playerCount));
      const nameSprite=makeNameSprite(nameLabel, p.bounty||5);
      scene.add(mesh); scene.add(hpSprite); scene.add(nameSprite);
      remotePlayers[p.id]={mesh,hpSprite,nameSprite,hp:MAX_HP,bounty:p.bounty||5,name:p.name||('P'+playerCount),level:p.level||0};
    }

    const rp=remotePlayers[p.id];
    const bodyY=p.y-0.65;
    // Set lerp targets ‚Äî actual movement happens in animate loop
    // Snap on first appearance, lerp thereafter
    if(rp.targetX===undefined){
      rp.mesh.position.set(p.x,bodyY,p.z);
      rp.hpSprite.position.set(p.x,bodyY+1.35,p.z);
      rp.nameSprite.position.set(p.x,bodyY+2.0,p.z);
    }
    rp.targetX=p.x; rp.targetY=bodyY; rp.targetZ=p.z; rp.targetRy=p.ry;

    // Update name sprite if level or bounty changed
    const newLabel = (p.level!=null?'LVL'+p.level+' ':'')+(p.name||('P'+playerCount));
    const newBounty = p.bounty || 5;
    if(newLabel !== rp.nameSprite.userData.label || newBounty !== rp.nameSprite.userData.bounty){
      updateNameSpriteData(rp.nameSprite, newLabel, newBounty);
    }
    rp.bounty = newBounty;
    rp.name   = p.name || ('P'+playerCount);
    rp.level  = p.level || 0;

    if(typeof p.hp==='number'&&p.hp!==rp.hp){
      rp.hp=p.hp;
      drawHPBar(rp.hpSprite,p.hp,MAX_HP);
    }
  });

  for(const id in remotePlayers){
    if(!active.has(id)){
      const rp=remotePlayers[id];
      scene.remove(rp.mesh); scene.remove(rp.hpSprite); scene.remove(rp.nameSprite);
      rp.mesh.traverse(c=>{ if(c.isMesh) c.geometry.dispose(); }); // shared mats, don't dispose
      delete remotePlayers[id];
    }
  }
  updateHUD();
}
// loadPlayers now called from merged ticker

// ‚îÄ‚îÄ POSITION BROADCAST (WebSocket, ~50ms) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Broadcasts pos via the realtime channel ‚Äî near-zero latency for other players.
// Remote players receive it in the 'pos' handler above and lerp smoothly.
let _lastBcX=0, _lastBcZ=0, _lastBcHp=0;
function _broadcastPos(){
  if(!_chanReady || !myName) return;
  const dx=Math.abs(camera.position.x-_lastBcX);
  const dz=Math.abs(camera.position.z-_lastBcZ);
  const dhp=myHp!==_lastBcHp;
  if(dx>0.01||dz>0.01||dhp){
    _lastBcX=camera.position.x; _lastBcZ=camera.position.z; _lastBcHp=myHp;
    _chanSend({type:'broadcast', event:'pos', payload:{
      id:playerId, x:camera.position.x, y:camera.position.y, z:camera.position.z,
      ry:yaw, hp:myHp
    }});
  }
}
setInterval(_broadcastPos, 50);  // 20 updates/sec via WebSocket

// ‚îÄ‚îÄ DB SYNC (slow, for new joiners who haven't seen us via WS yet) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _lastSyncX=0, _lastSyncZ=0, _lastSyncHp=0;
function _dbSync(){
  if(!myName) return;
  const dx=Math.abs(camera.position.x-_lastSyncX);
  const dz=Math.abs(camera.position.z-_lastSyncZ);
  const dhp=myHp!==_lastSyncHp;
  if(dx>0.5||dz>0.5||dhp){
    _lastSyncX=camera.position.x; _lastSyncZ=camera.position.z; _lastSyncHp=myHp;
    syncPlayer();
  }
}
setInterval(_dbSync, 2000);   // DB write every 2s (just for presence/join discovery)
setInterval(loadPlayers, 3000); // DB load every 3s (pick up new joiners)

// Patch confirmName to also broadcast join
const _baseCN = window.confirmName;
window.confirmName = function(){
  _baseCN ? _baseCN() : confirmName();
  setTimeout(announceJoin, 400);
};


// ============================================================================
//  PAUSE SYSTEM
// ============================================================================
let paused = false;

function pauseGame() {
  if (chatOpen || dead) return;   // don't pause while typing or dead
  paused = true;
  document.exitPointerLock();
  document.getElementById('pause-screen').classList.add('active');
}

function resumeGame() {
  paused = false;
  document.getElementById('pause-screen').classList.remove('active');
  // Re-acquire pointer lock by clicking the canvas
  renderer.domElement.requestPointerLock();
}

// ============================================================================
//  REMOTE PLAYER LERP
// ============================================================================
const _LERP_SPEED = 0.28; // fraction per frame ‚Äî higher = snappier, lower = smoother
function lerpRemotePlayers(){
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(rp.targetX === undefined) continue;
    const mx = rp.mesh.position;
    // Lerp position
    mx.x += (rp.targetX - mx.x) * _LERP_SPEED;
    mx.y += (rp.targetY - mx.y) * _LERP_SPEED;
    mx.z += (rp.targetZ - mx.z) * _LERP_SPEED;
    // Lerp rotation (short-path angle)
    let dRy = rp.targetRy - rp.mesh.rotation.y;
    if(dRy >  Math.PI) dRy -= Math.PI*2;
    if(dRy < -Math.PI) dRy += Math.PI*2;
    rp.mesh.rotation.y += dRy * _LERP_SPEED;
    // Keep HP/name sprites above mesh
    rp.hpSprite.position.set(mx.x, mx.y+1.35, mx.z);
    rp.nameSprite.position.set(mx.x, mx.y+2.0,  mx.z);
  }
}

// ============================================================================
//  MAIN LOOP
// ============================================================================
const _LABEL_DSQ = 18*18; // name/HP bar visible within 18 units squared
function animate(){
  requestAnimationFrame(animate);
  if(document.hidden) return; // don't render when tab is hidden

  // ‚îÄ‚îÄ In-frame integrity clamps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // These run every frame and silently correct cheated values in real-time,
  // before they can be rendered or used in any calculation.
  // Hard limits mirror the save-state Edge Function ‚Äî anything above these
  // ceilings is physically impossible through normal gameplay.
  // Clamp to ceilings ‚Äî never zero out legitimate values.
  // Caps are set at ~10x what 800 upgrades gives, so legitimate high-level
  // players are never affected, but console cheats like damageMultiplier=99999 are caught.
  if(damageMultiplier > 2000.0) damageMultiplier = 2000.0;  // 800 upgrades = 201.0
  if(maxHpBonus > 200000)       maxHpBonus       = 200000;  // 800 upgrades = 20000
  const _maxHp = 100 + maxHpBonus;
  if(myHp > _maxHp + 1)         myHp             = _maxHp;
  if(coins < 0)                 coins            = 0;
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  updateMovement();
  updateCar();
  if(typeof updateTrain!=='undefined') updateTrain();
  if(typeof updateHorse!=='undefined') updateHorse();
  lerpRemotePlayers();
  updateBullets();
  updateZombies();
  updateCowsWithGuns();
  updateOnions();
  updateMerchantProximity();
  updateShopBearing();
  if(typeof updateHorseDealerNPC!=='undefined') updateHorseDealerNPC();
  if(typeof updateHorseProximity!=='undefined') updateHorseProximity();
  if(typeof checkAndBoardTrain!=='undefined') checkAndBoardTrain();
  updateGodMode();
  tickHPRegen();
  if(typeof tickRedBull!=='undefined') tickRedBull();
  tickBountyNotify();
  updateBountyHUD();
  updateGrenades();
  updateC4Blink();
  applyFovLerp();
  if(weaponCooldown>0) weaponCooldown--;
  _hcTick();
  if(hmTimer>0){ hmTimer--; if(hmTimer===0){ _hudHm.style.transition='opacity 0.15s'; _hudHm.style.opacity='0'; } }

  // Show name/HP sprites only when the other player is nearby
  const cx=camera.position.x, cz=camera.position.z;
  for(const id in remotePlayers){
    const rp=remotePlayers[id];
    const dx=cx-rp.mesh.position.x, dz=cz-rp.mesh.position.z;
    const near = dx*dx+dz*dz < _LABEL_DSQ;
    rp.hpSprite.visible   = near;
    rp.nameSprite.visible = near;
  }

  // Glass opacity: nearly invisible up close, more visible at distance
  if(buildingBounds.length){
    const px=camera.position.x, pz=camera.position.z;
    let minDist=999;
    for(const b of buildingBounds){
      const dx=Math.max(0,b.x1-px, px-b.x2);
      const dz=Math.max(0,b.z1-pz, pz-b.z2);
      const d=Math.sqrt(dx*dx+dz*dz);
      if(d<minDist) minDist=d;
    }
    // 0..2 units = 0.04 opacity (nearly clear); >10 units = 0.42 (clearly visible)
    const t=Math.max(0,Math.min(1,(minDist-2)/8));
    _glMat.opacity = 0.04 + t*0.38;
  }

  updateFpGun();

  // Pass 1: render world
  renderer.clear();
  renderer.render(scene, camera);

  // Pass 2: composite gun on top ‚Äî clearDepth so gun always in front,
  // render gunScene (contains ONLY fpCam+gun, no world geometry).
  if(!inCar){ renderer.clearDepth(); renderer.render(gunScene, fpCam); }
}

updateHUD();
updateWeaponHUD();
(function initSafeSpawn(){
  const sp = safeSpawnPos();
  camera.position.set(sp.x, GROUND_Y, sp.z);
})();
buildShopNPC();
buildTrain();
buildHorseStable();
buildHorseDealerNPC();
for(let _si=0;_si<6;_si++) spawnZombie();
spawnOnions();
animate();
</script>


<!-- Shop Screen -->


<!-- CAR DEALER SCREEN -->
<div id="car-dealer-screen">
  <div id="car-dealer-title">üöó CAR & VEHICLE DEALER üéñ</div>
  <div id="car-dealer-sub">// CIVILIAN VEHICLES & MILITARY HARDWARE //</div>
  <div id="car-dealer-balance">‚¨° <span id="car-dealer-coins">0</span> COINS</div>
  <div id="car-grid">
    <div class="car-card" data-car="standard">
      <div class="car-card-icon">üöó</div>
      <div class="car-card-name">STANDARD</div>
      <div class="car-card-desc">Reliable & easy to control</div>
      <div class="car-card-speed">TOP SPEED: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ</div>
      <div class="car-card-cost">‚¨° 500 COINS</div>
    </div>
    <div class="car-card" data-car="muscle">
      <div class="car-card-icon">üöô</div>
      <div class="car-card-name">MUSCLE</div>
      <div class="car-card-desc">Raw power, wide turns</div>
      <div class="car-card-speed">TOP SPEED: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</div>
      <div class="car-card-cost">‚¨° 2,000 COINS</div>
    </div>
    <div class="car-card" data-car="sport">
      <div class="car-card-icon">üèé</div>
      <div class="car-card-name">SPORT</div>
      <div class="car-card-desc">Ultimate racing machine</div>
      <div class="car-card-speed">TOP SPEED: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
      <div class="car-card-cost">‚¨° 5,000 COINS</div>
    </div>
    <div class="car-card military" data-car="humvee">
      <div class="car-card-icon">üöê</div>
      <div class="car-card-name">HUMVEE</div>
      <div class="car-card-desc">Armored military jeep. Roof-mounted gun. Absorbs 70% of damage.</div>
      <div class="car-card-speed">ARMOR: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | SPEED: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</div>
      <div class="car-card-cost">‚¨° 18,000 COINS</div>
    </div>
    <div class="car-card military" data-car="apc">
      <div class="car-card-icon">üõ°</div>
      <div class="car-card-name">APC</div>
      <div class="car-card-desc">Heavy armored personnel carrier. Absorbs 70% of all incoming damage.</div>
      <div class="car-card-speed">ARMOR: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë | SPEED: ‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ</div>
      <div class="car-card-cost">‚¨° 45,000 COINS</div>
    </div>
    <div class="car-card military" data-car="tank">
      <div class="car-card-icon">üéñ</div>
      <div class="car-card-name">M1 TANK</div>
      <div class="car-card-desc">Main battle tank. Absorbs 85% damage. Fire cannon with SPACE. Kills everything.</div>
      <div class="car-card-speed">ARMOR: ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà | SPEED: ‚òÖ‚òÜ‚òÜ‚òÜ‚òÜ</div>
      <div class="car-card-cost">‚¨° 120,000 COINS</div>
    </div>
  </div>
  <div id="car-dealer-close" onclick="closeCarDealer()">&nbsp;<br>[ ESC ] ‚Äî CLOSE</div>
</div>
<!-- CAR HUD -->
<div id="car-hud"><div id="car-hud-name">STANDARD</div><div id="car-hud-speed">0 km/h</div></div>
<div id="car-exit-hint">[ F ] EXIT VEHICLE / DISMOUNT</div>

<!-- HORSE DEALER SCREEN -->
<div id="horse-dealer-screen">
  <div id="horse-dealer-title">üêé HORSE STABLE üêé</div>
  <div id="horse-dealer-sub">// MOUNTS FOR HIRE ‚Äî FAST &amp; SILENT //</div>
  <div id="horse-dealer-balance">‚¨° <span id="horse-dealer-coins">0</span> COINS</div>
  <div id="horse-grid">
    <div class="horse-card" data-horse="mare" onclick="buyHorse('mare')">
      <div class="horse-card-icon">üê¥</div>
      <div class="horse-card-name">MARE</div>
      <div class="horse-card-desc">Reliable riding horse. Good all-rounder for open terrain.</div>
      <div class="horse-card-speed">SPEED: ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ | TURN: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</div>
      <div class="horse-card-cost">‚¨° 3,000 COINS</div>
    </div>
    <div class="horse-card" data-horse="stallion" onclick="buyHorse('stallion')">
      <div class="horse-card-icon">üêé</div>
      <div class="horse-card-name">STALLION</div>
      <div class="horse-card-desc">Powerful black stallion. Faster with great agility.</div>
      <div class="horse-card-speed">SPEED: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ | TURN: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</div>
      <div class="horse-card-cost">‚¨° 8,000 COINS</div>
    </div>
    <div class="horse-card" data-horse="warhorse" onclick="buyHorse('warhorse')">
      <div class="horse-card-icon">üèá</div>
      <div class="horse-card-name">WARHORSE</div>
      <div class="horse-card-desc">Elite silver warhorse. Fastest mount in the stable.</div>
      <div class="horse-card-speed">SPEED: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ | TURN: ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</div>
      <div class="horse-card-cost">‚¨° 25,000 COINS</div>
    </div>
  </div>
  <div id="horse-dealer-close" onclick="closeHorseDealer()">&nbsp;<br>[ ESC ] ‚Äî CLOSE</div>
</div>

<div id="bounty-handler-screen">
  <div id="bh-title">‚ò† BOUNTY CONTRACTS ‚ò†</div>
  <div id="bh-subtitle">// REPORT TO THE HANDLER TO CLAIM YOUR REWARDS //</div>
  <div id="bh-progress-bar-wrap"><div id="bh-progress-bar" style="width:0%"></div></div>
  <div id="bh-progress-label">BOUNTIES CLAIMED: 0</div>
  <div id="bh-tier-grid"></div>
  <div id="bh-close-hint">[ ESC ] ‚Äî DISMISS</div>
</div>

<div id="boss-hud"><div id="boss-hud-name">BOSS</div><div id="boss-hud-bar-wrap"><div id="boss-hud-bar"></div></div></div>
<div id="boss-screen">
  <div id="boss-title">‚ò† BOSS ARENA ‚ò†</div>
  <div id="boss-player-info">LVL 0 ‚Äî 0 XP | ‚¨° 0 COINS</div>
  <div id="boss-warning">
    ‚ö† Fighting a boss costs LEVELS and COINS. You will be teleported to the arena.<br>
    Bosses do not respawn until defeated. Only one boss active at a time.
  </div>
  <div id="boss-fight-grid"></div>
  <div id="boss-close-hint">[ ESC ] ‚Äî CANCEL</div>
</div>

<div id="rebirth-screen">
  <div id="rebirth-title">‚òΩ REBIRTH ‚òæ</div>
  <div id="rebirth-count-display">REBIRTH #1</div>
  <div id="rebirth-cost-display">‚¨° 500 COINS</div>
  <div id="rebirth-afford">‚úì CAN AFFORD</div>
  <div id="rebirth-warning">
    ‚ö† REBIRTH RESETS ALL SHOP UPGRADES (HP, caliber, all mags).<br>
    Your level, XP, kills and coins are kept.<br>
    Choose one permanent buff ‚Äî it stacks with future rebirths.
  </div>
  <div id="rebirth-buff-grid"></div>
  <div id="rebirth-close-hint">[ ESC ] ‚Äî CANCEL</div>
</div>

<div id="shop-screen">
  <div id="shop-title">// UPGRADES //</div>
  <div id="shop-coins-display">‚¨° <span id="shop-coin-count">0</span> COINS &nbsp;|&nbsp; <span id="shop-xp-display" style="color:#0af;font-size:11px">LVL 0</span></div>
  <!-- Buy Factor -->
  <div class="bf-row">
    <span class="bf-label">BUY √ó</span>
    <button class="bf-btn active" data-bf="1"    onclick="setBuyFactor(1)">√ó1</button>
    <button class="bf-btn"        data-bf="5"    onclick="setBuyFactor(5)">√ó5</button>
    <button class="bf-btn"        data-bf="10"   onclick="setBuyFactor(10)">√ó10</button>
    <button class="bf-btn"        data-bf="25"   onclick="setBuyFactor(25)">√ó25</button>
    <button class="bf-btn"        data-bf="50"   onclick="setBuyFactor(50)">√ó50</button>
    <button class="bf-btn"        data-bf="100"  onclick="setBuyFactor(100)">√ó100</button>
    <button class="bf-btn"        data-bf="max"  onclick="setBuyFactor(9999)">MAX</button>
  </div>
  <div id="shop-grid">
    <div class="shop-item" data-item="heal">
      <div class="shop-item-name">‚öï MEDKIT</div>
      <div class="shop-item-desc">Restore 50 HP per purchase</div>
      <div class="shop-item-cost">‚¨° 40 COINS</div>
    </div>
    <div class="shop-item" data-item="maxhp">
      <div class="shop-item-name">‚ù§ MAX HP UP</div>
      <div class="shop-item-desc">+25 max HP per purchase</div>
      <div class="shop-item-cost">‚¨° 80 COINS</div>
    </div>
    <div class="shop-item" data-item="caliber">
      <div class="shop-item-name">‚ñ≤ HIGH CALIBER</div>
      <div class="shop-item-desc">+25% damage per purchase</div>
      <div class="shop-item-cost">‚¨° 100 COINS</div>
    </div>
    <div class="shop-item" data-item="fullkit">
      <div class="shop-item-name">‚òÖ FULL KIT</div>
      <div class="shop-item-desc">Full heal + all ammo refill</div>
      <div class="shop-item-cost">‚¨° 250 COINS</div>
    </div>
    <div class="shop-item" data-item="ammo_rifle">
      <div class="shop-item-name">üî´ RIFLE AMMO</div>
      <div class="shop-item-desc">Refill rifle to max</div>
      <div class="shop-item-cost">‚¨° 30 COINS</div>
    </div>
    <div class="shop-item" data-item="ammo_shotgun">
      <div class="shop-item-name">üí• SHOTGUN AMMO</div>
      <div class="shop-item-desc">Refill shotgun to max</div>
      <div class="shop-item-cost">‚¨° 35 COINS</div>
    </div>
    <div class="shop-item" data-item="ammo_laser">
      <div class="shop-item-name">‚ö° LASER CELLS</div>
      <div class="shop-item-desc">Refill laser to max</div>
      <div class="shop-item-cost">‚¨° 45 COINS</div>
    </div>
    <div class="shop-item" data-item="ammo_sniper">
      <div class="shop-item-name">üéØ SNIPER ROUNDS</div>
      <div class="shop-item-desc">Refill sniper to max</div>
      <div class="shop-item-cost">‚¨° 50 COINS</div>
    </div>
    <div class="shop-item" data-item="grenades">
      <div class="shop-item-name">üí£ EXPLOSIVES</div>
      <div class="shop-item-desc">+3 Grenades +2 C4</div>
      <div class="shop-item-cost">‚¨° 60 COINS</div>
    </div>
    <div class="shop-item" data-item="mag_rifle">
      <div class="shop-item-name">üì¶ RIFLE MAG UP</div>
      <div class="shop-item-desc">+40 max rifle ammo</div>
      <div class="shop-item-cost">‚¨° 120 COINS</div>
    </div>
    <div class="shop-item" data-item="mag_shotgun">
      <div class="shop-item-name">üì¶ SHOTGUN MAG UP</div>
      <div class="shop-item-desc">+10 max shotgun shells</div>
      <div class="shop-item-cost">‚¨° 120 COINS</div>
    </div>
    <div class="shop-item" data-item="mag_laser">
      <div class="shop-item-name">üì¶ LASER MAG UP</div>
      <div class="shop-item-desc">+60 max laser cells</div>
      <div class="shop-item-cost">‚¨° 120 COINS</div>
    </div>
    <div class="shop-item" data-item="mag_sniper">
      <div class="shop-item-name">üì¶ SNIPER MAG UP</div>
      <div class="shop-item-desc">+5 max sniper rounds</div>
      <div class="shop-item-cost">‚¨° 120 COINS</div>
    </div>
    <div class="shop-item" data-item="mag_grenade">
      <div class="shop-item-name">üì¶ GRENADE BAG UP</div>
      <div class="shop-item-desc">+2 max grenades</div>
      <div class="shop-item-cost">‚¨° 120 COINS</div>
    </div>
    <div class="shop-item" data-item="mag_c4">
      <div class="shop-item-name">üì¶ C4 POUCH UP</div>
      <div class="shop-item-desc">+1 max C4 charge</div>
      <div class="shop-item-cost">‚¨° 120 COINS</div>
    </div>
  </div>
  <div id="shop-close-hint">[ ESC ] ‚Äî CLOSE UPGRADES</div>
</div>

<!-- WEAPONSMITH SCREEN -->
<div id="weaponsmith-screen">
  <div id="weapon-title">‚öî WEAPONSMITH ‚öî</div>
  <div id="weapon-coins-display">‚¨° <span id="weapon-coin-count">0</span> COINS</div>
  <!-- Buy Factor (shared setBuyFactor) -->
  <div class="bf-row">
    <span class="bf-label">BUY √ó</span>
    <button class="bf-btn active" data-bf="1"   onclick="setBuyFactor(1)">√ó1</button>
    <button class="bf-btn"        data-bf="5"   onclick="setBuyFactor(5)">√ó5</button>
    <button class="bf-btn"        data-bf="10"  onclick="setBuyFactor(10)">√ó10</button>
    <button class="bf-btn"        data-bf="25"  onclick="setBuyFactor(25)">√ó25</button>
    <button class="bf-btn"        data-bf="50"  onclick="setBuyFactor(50)">√ó50</button>
    <button class="bf-btn"        data-bf="100" onclick="setBuyFactor(100)">√ó100</button>
    <button class="bf-btn"        data-bf="max" onclick="setBuyFactor(9999)">MAX</button>
  </div>
  <div id="weapon-grid">
    <div class="weapon-item" data-item="red_bull" onclick="weaponBuy('red_bull')" style="border-color:#ff4444;background:rgba(40,0,0,0.95)">
      <div class="weapon-item-name" style="color:#ff4444">üî¥ RED BULL</div>
      <div class="weapon-item-desc">Grants 12s of flight + 45% speed boost. Stacks with multiple purchases.</div>
      <div class="weapon-item-cost">‚¨° 500 COINS</div>
    </div>
    <div class="weapon-item" data-item="emp_blast" onclick="weaponBuy('emp_blast')" style="border-color:#00ccff;background:rgba(0,15,35,0.95)">
      <div class="weapon-item-name" style="color:#00cfff">‚ö° EMP BLAST</div>
      <div class="weapon-item-desc">Slows ALL zombies 75% for 6 seconds. Area-wide disruption.</div>
      <div class="weapon-item-cost">‚¨° 8,000 COINS</div>
    </div>
    <div class="weapon-item" data-item="cruise_missile" onclick="weaponBuy('cruise_missile')" style="border-color:#ff8800;background:rgba(35,12,0,0.95)">
      <div class="weapon-item-name" style="color:#ff8800">üöÄ CRUISE MISSILE</div>
      <div class="weapon-item-desc">Targeted airstrike on your crosshair. 18m blast. Watch for splash.</div>
      <div class="weapon-item-cost">‚¨° 40,000 COINS</div>
    </div>
    <div class="weapon-item" data-item="mini_nuke" onclick="weaponBuy('mini_nuke')" style="border-color:#ffcc00;background:rgba(35,25,0,0.95)">
      <div class="weapon-item-name" style="color:#ffcc00">üí• MINI NUKE</div>
      <div class="weapon-item-desc">60m radius tactical detonation. Destroys all nearby zombies.</div>
      <div class="weapon-item-cost">‚¨° 75,000 COINS</div>
    </div>
    <div class="weapon-item" data-item="nuke" onclick="weaponBuy('nuke')" style="border-color:#ff2200;background:rgba(30,2,0,0.95)">
      <div class="weapon-item-name" style="color:#ff2200">‚ò¢ TACTICAL NUKE</div>
      <div class="weapon-item-desc">Obliterates ALL zombies &amp; players on the map. One use. No mercy.</div>
      <div class="weapon-item-cost">‚¨° 500,000 COINS</div>
    </div>
  </div>
  <div id="weapon-close-hint">[ ESC ] ‚Äî CLOSE WEAPONSMITH</div>
</div>
<div id="redbull-hud"></div>

<!-- HOTBAR -->
<div id="hotbar-wrap" style="pointer-events:auto"></div>

<!-- INVENTORY OVERLAY -->
<div id="inv-overlay">
  <div id="inv-panel">
    <div id="inv-title">INVENTORY</div>
    <div id="inv-subtitle">DRAG ITEMS TO HOTBAR ¬∑ CLICK TO USE FROM HOTBAR</div>
    <div id="inv-grid"></div>
    <div id="inv-hotbar-label">HOTBAR</div>
    <div id="inv-hotbar-row"></div>
    <button id="inv-close-btn" onclick="closeInventory()">[ I ] CLOSE INVENTORY</button>
  </div>
</div>
<div id="inv-tooltip"></div>
<div id="inv-drag-ghost"></div>

<div id="coin-pop"></div>
<div id="god-mode-indicator">‚¨° GOD MODE ‚Äî SHOP INTERIOR ‚¨°</div>

<div id="pause-screen">
  <div id="pause-title">PAUSED</div>
  <div id="pause-sub">// GAME SUSPENDED //</div>
  <button class="pause-btn" onclick="resumeGame()">‚ñ∂ RESUME</button>
  <button class="pause-btn secondary" onclick="toggleFullscreen()">‚õ∂ FULLSCREEN</button>
  <button class="pause-btn secondary" id="exit-btn" onclick="exitGame()">‚úï SAVE &amp; EXIT</button>
  <div id="pause-divider"></div>
  <div id="pause-keybinds">
    <span>ESC</span> ‚Äî PAUSE / RESUME &nbsp;&nbsp;
    <span>WASD</span> ‚Äî MOVE<br>
    <span>SPACE</span> ‚Äî JUMP &nbsp;&nbsp;
    <span>T</span> ‚Äî CHAT<br>
    <span>1‚Äì6</span> ‚Äî SWITCH WEAPON &nbsp;&nbsp;
    <span>RMB</span> ‚Äî SCOPE<br>
    <span>SCROLL</span> ‚Äî ZOOM LEVEL &nbsp;&nbsp;
    <span>LMB</span> ‚Äî SHOOT &nbsp;&nbsp;
    <span>G</span> ‚Äî DETONATE C4<br>
    <span>E</span> ‚Äî INTERACT (near merchant)
  </div>
</div>
<!-- PLAYER LIST OVERLAY (Tab) -->
<div id="player-list-overlay">
  <div id="pl-header">
    <span>SOLDIER</span><span>LVL</span><span>BOUNTY</span><span>HP</span>
  </div>
  <div id="pl-rows"></div>
  <div id="pl-footer">HOLD TAB TO VIEW ONLINE PLAYERS</div>
</div>

<!-- ADMIN CONSOLE -->
<div id="admin-console">
  <div id="admin-bar">
    <div id="admin-bar-title">‚¨° ADMIN CONSOLE ‚¨°</div>
    <div id="admin-bar-user">Logged in as: <span id="admin-bar-username"></span></div>
    <div id="admin-bar-close" onclick="closeAdminConsole()">‚úï CLOSE</div>
  </div>
  <div id="admin-body">
    <div id="admin-tabs">
      <div class="admin-tab active" onclick="adminTab('impersonate')">üë§ IMPERSONATE</div>
      <div class="admin-tab" onclick="adminTab('player')">üéÆ EDIT SELF</div>
      <div class="admin-tab" onclick="adminTab('remote')">üåê EDIT PLAYER</div>
      <div class="admin-tab" onclick="adminTab('hacks')">üíÄ HACKS</div>
    </div>
    <div id="admin-panel">

      <!-- IMPERSONATE -->
      <div class="admin-section active" id="admin-sec-impersonate">
        <h2>IMPERSONATE PLAYER</h2>
        <div class="admin-row">
          <div class="admin-lbl">Username</div>
          <input class="admin-inp" id="admin-imp-user" placeholder="target_username" />
          <button class="admin-btn" onclick="adminImpersonate()">LOGIN AS USER</button>
        </div>
        <div style="color:#448844;font-size:11px;margin-top:8px;">Logs you in as that player without needing their password. Their full state will be loaded.</div>
        <div style="margin-top:16px;border-top:1px solid #002200;padding-top:14px">
          <div style="color:#00ff41;font-size:11px;letter-spacing:2px;margin-bottom:10px">‚ñ∏ CURRENT SESSION</div>
          <div style="font-size:11px;color:#448844;margin-bottom:10px">
            Active as: <span id="adm-active-account" style="color:#00ff41">‚Äî</span>
          </div>
          <button class="admin-btn" onclick="adminReturnToAdmin()" id="adm-return-btn" style="display:none;border-color:#ffd700;color:#ffd700;background:rgba(255,215,0,0.08)">
            ‚òÖ RETURN TO ADMIN56
          </button>
        </div>
      </div>

      <!-- EDIT SELF -->
      <div class="admin-section" id="admin-sec-player">
        <h2>EDIT YOUR VALUES</h2>
        <div class="admin-row"><div class="admin-lbl">Coins</div><input class="admin-inp" id="adm-coins" type="number"/><button class="admin-btn" onclick="adminSetSelf('coins')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">HP</div><input class="admin-inp" id="adm-hp" type="number"/><button class="admin-btn" onclick="adminSetSelf('hp')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">Max HP Bonus</div><input class="admin-inp" id="adm-maxhp" type="number"/><button class="admin-btn" onclick="adminSetSelf('maxhp')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">Bounty (manual)</div><input class="admin-inp" id="adm-bounty" type="number"/><button class="admin-btn" onclick="adminSetSelf('bounty')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">Kills</div><input class="admin-inp" id="adm-kills" type="number"/><button class="admin-btn" onclick="adminSetSelf('kills')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">XP</div><input class="admin-inp" id="adm-xp" type="number"/><button class="admin-btn" onclick="adminSetSelf('xp')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">Level</div><input class="admin-inp" id="adm-level" type="number"/><button class="admin-btn" onclick="adminSetSelf('level')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">Rifle Ammo</div><input class="admin-inp" id="adm-ammo-rifle" type="number"/><button class="admin-btn" onclick="adminSetSelf('ammo_rifle')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">Shotgun Ammo</div><input class="admin-inp" id="adm-ammo-shotgun" type="number"/><button class="admin-btn" onclick="adminSetSelf('ammo_shotgun')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">Damage Multiplier</div><input class="admin-inp" id="adm-dmgmult" type="number" step="0.1"/><button class="admin-btn" onclick="adminSetSelf('dmgmult')">SET</button></div>
        <div class="admin-row"><div class="admin-lbl">Position X</div><input class="admin-inp" id="adm-pos-x" type="number" step="0.5"/><button class="admin-btn" onclick="adminSetSelf('pos_x')">TELEPORT</button></div>
        <div class="admin-row"><div class="admin-lbl">Position Y</div><input class="admin-inp" id="adm-pos-y" type="number" step="0.5"/><button class="admin-btn" onclick="adminSetSelf('pos_y')">TELEPORT</button></div>
        <div class="admin-row"><div class="admin-lbl">Position Z</div><input class="admin-inp" id="adm-pos-z" type="number" step="0.5"/><button class="admin-btn" onclick="adminSetSelf('pos_z')">TELEPORT</button></div>
        <button class="admin-btn" style="margin-top:8px" onclick="adminRefreshSelfFields()">‚Üª REFRESH VALUES</button>
      </div>

      <!-- EDIT REMOTE PLAYER -->
      <div class="admin-section" id="admin-sec-remote">
        <h2>EDIT ANOTHER PLAYER</h2>
        <div class="admin-row">
          <div class="admin-lbl">Username</div>
          <input class="admin-inp" id="adm-rem-user" placeholder="target_username"/>
          <button class="admin-btn" onclick="adminLoadRemote()">LOAD</button>
        </div>
        <!-- INFO CARD ‚Äî editable, shown after load -->
        <div id="admin-player-card">
          <h3>‚ñ∏ PLAYER PROFILE</h3>
          <!-- Read-only status row -->
          <div class="apc-readonly-row" style="margin-bottom:8px;padding-bottom:8px;border-bottom:1px solid #003300">
            <span class="apc-key">STATUS</span>
            <span id="apc-status" class="apc-val">‚Äî</span>
          </div>
          <div class="apc-readonly-row" style="margin-bottom:10px;padding-bottom:8px;border-bottom:1px solid #003300">
            <span class="apc-key">OWNED CARS</span>
            <span id="apc-cars" class="apc-val" style="color:#ff8800;font-size:10px">‚Äî</span>
          </div>
          <!-- Editable fields grid -->
          <div style="column-count:1">
            <div class="apc-edit-row"><span class="apc-key">CALLSIGN</span><input class="apc-inp" id="apc-callsign"/><button class="apc-set-btn" onclick="apcSet('soldier_name','apc-callsign')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">COINS</span><input class="apc-inp" id="apc-coins" type="number"/><button class="apc-set-btn" onclick="apcSet('coins','apc-coins')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">HP</span><input class="apc-inp" id="apc-hp" type="number"/><button class="apc-set-btn" onclick="apcSet('hp','apc-hp')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">MAX HP BONUS</span><input class="apc-inp" id="apc-maxhp" type="number"/><button class="apc-set-btn" onclick="apcSet('max_hp_bonus','apc-maxhp')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">KILLS</span><input class="apc-inp" id="apc-kills" type="number"/><button class="apc-set-btn" onclick="apcSet('kills','apc-kills')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">DEATHS</span><input class="apc-inp" id="apc-deaths" type="number"/><button class="apc-set-btn" onclick="apcSet('deaths','apc-deaths')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">PVP KILLS</span><input class="apc-inp" id="apc-pvpkills" type="number"/><button class="apc-set-btn" onclick="apcSet('pvp_kills','apc-pvpkills')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">XP</span><input class="apc-inp" id="apc-xp" type="number"/><button class="apc-set-btn" onclick="apcSet('player_xp','apc-xp')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">LEVEL</span><input class="apc-inp" id="apc-level" type="number"/><button class="apc-set-btn" onclick="apcSet('player_level','apc-level')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">REBIRTHS</span><input class="apc-inp" id="apc-rebirths" type="number"/><button class="apc-set-btn" onclick="apcSet('rebirth_count','apc-rebirths')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">DMG MULTIPLIER</span><input class="apc-inp" id="apc-dmgmult" type="number" step="0.1"/><button class="apc-set-btn" onclick="apcSet('damage_multiplier','apc-dmgmult')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">BOUNTIES CLAIMED</span><input class="apc-inp" id="apc-bounties" type="number"/><button class="apc-set-btn" onclick="apcSet('pvp_bounties_claimed','apc-bounties')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">CONTRACT TIER</span><input class="apc-inp" id="apc-tier" type="number"/><button class="apc-set-btn" onclick="apcSet('bounty_contract_tier','apc-tier')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">RIFLE AMMO</span><input class="apc-inp" id="apc-ammo-rifle" type="number"/><button class="apc-set-btn" onclick="apcSet('ammo_rifle','apc-ammo-rifle')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">SHOTGUN AMMO</span><input class="apc-inp" id="apc-ammo-shotgun" type="number"/><button class="apc-set-btn" onclick="apcSet('ammo_shotgun','apc-ammo-shotgun')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">LASER AMMO</span><input class="apc-inp" id="apc-ammo-laser" type="number"/><button class="apc-set-btn" onclick="apcSet('ammo_laser','apc-ammo-laser')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">SNIPER AMMO</span><input class="apc-inp" id="apc-ammo-sniper" type="number"/><button class="apc-set-btn" onclick="apcSet('ammo_sniper','apc-ammo-sniper')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">POSITION X</span><input class="apc-inp" id="apc-pos-x" type="number" step="0.5"/><button class="apc-set-btn" onclick="apcSet('pos_x','apc-pos-x')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">POSITION Y</span><input class="apc-inp" id="apc-pos-y" type="number" step="0.5"/><button class="apc-set-btn" onclick="apcSet('pos_y','apc-pos-y')">SET</button></div>
            <div class="apc-edit-row"><span class="apc-key">POSITION Z</span><input class="apc-inp" id="apc-pos-z" type="number" step="0.5"/><button class="apc-set-btn" onclick="apcSet('pos_z','apc-pos-z')">SET</button></div>
          </div>
          <!-- Action buttons -->
          <div style="display:flex;gap:8px;margin-top:14px;flex-wrap:wrap">
            <button class="admin-btn" onclick="adminTeleportToPlayer()">üìç TP TO PLAYER</button>
            <button class="admin-btn" onclick="adminTeleportPlayerToMe()">‚§µ TP PLAYER TO ME</button>
            <button class="admin-btn danger" onclick="adminKickPlayer()">‚ö° KILL PLAYER</button>
          </div>
        </div>
      </div>

      <!-- HACKS TAB -->
      <div class="admin-section" id="admin-sec-hacks">
        <h2>HACK CLIENT ‚Äî BUILT-IN CHEATS</h2>
        <div id="admin-hacks-builtin"></div>
        <h2 style="margin-top:18px">HPL SCRIPTS ‚Äî CUSTOM HACKS</h2>
        <div style="font-size:10px;color:#448844;margin-bottom:10px;line-height:1.6">
          Load custom hacks via the <span style="color:#00ff41">HACK_TERMINAL</span> login.
          Enter username <span style="color:#00ff41">HACKTERM</span> with no password, then use the <span style="color:#00ff41">upload</span> command to load a .zip with a .txt written in HPL.
        </div>
        <div id="admin-hacks-scripts">
          <span style="color:#224422;font-size:11px;font-style:italic">No HPL scripts loaded.</span>
        </div>
        <div id="hc-admin-hint">ALL HACKS ARE CLIENT-SIDE ONLY ‚Äî ONLY AFFECT YOUR OWN GAME SESSION</div>
      </div>
      <div id="admin-log">// ADMIN CONSOLE READY
</div>
    </div>
  </div>
</div>

</body>
</html>